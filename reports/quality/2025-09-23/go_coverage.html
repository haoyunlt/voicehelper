
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>errors: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">voicehelper/backend/common/errors/error_codes.go (0.0%)</option>
				
				<option value="file1">voicehelper/backend/common/logger/logger.go (0.0%)</option>
				
				<option value="file2">voicehelper/backend/examples/service_discovery_example.go (0.0%)</option>
				
				<option value="file3">voicehelper/backend/internal/middleware/zero_trust.go (0.0%)</option>
				
				<option value="file4">voicehelper/backend/internal/repository/apikey_repository.go (0.0%)</option>
				
				<option value="file5">voicehelper/backend/internal/repository/conversation_repository.go (0.0%)</option>
				
				<option value="file6">voicehelper/backend/internal/repository/dataset_repository.go (13.7%)</option>
				
				<option value="file7">voicehelper/backend/internal/repository/user_repository.go (27.3%)</option>
				
				<option value="file8">voicehelper/backend/internal/service/chat.go (0.0%)</option>
				
				<option value="file9">voicehelper/backend/internal/service/model_router_service.go (0.0%)</option>
				
				<option value="file10">voicehelper/backend/internal/service/service.go (0.0%)</option>
				
				<option value="file11">voicehelper/backend/pkg/cache/redis.go (0.0%)</option>
				
				<option value="file12">voicehelper/backend/pkg/config/config.go (0.0%)</option>
				
				<option value="file13">voicehelper/backend/pkg/database/optimized_pool.go (0.0%)</option>
				
				<option value="file14">voicehelper/backend/pkg/database/postgres.go (0.0%)</option>
				
				<option value="file15">voicehelper/backend/pkg/discovery/load_balancer.go (0.0%)</option>
				
				<option value="file16">voicehelper/backend/pkg/discovery/service_discovery.go (0.0%)</option>
				
				<option value="file17">voicehelper/backend/pkg/discovery/service_registry.go (0.0%)</option>
				
				<option value="file18">voicehelper/backend/pkg/metrics/unified_metrics.go (0.0%)</option>
				
				<option value="file19">voicehelper/backend/pkg/middleware/auth.go (0.0%)</option>
				
				<option value="file20">voicehelper/backend/pkg/middleware/common.go (0.0%)</option>
				
				<option value="file21">voicehelper/backend/pkg/middleware/logger.go (0.0%)</option>
				
				<option value="file22">voicehelper/backend/pkg/middleware/metrics.go (0.0%)</option>
				
				<option value="file23">voicehelper/backend/pkg/middleware/rate_limit.go (0.0%)</option>
				
				<option value="file24">voicehelper/backend/pkg/middleware/request_id.go (0.0%)</option>
				
				<option value="file25">voicehelper/backend/pkg/middleware/voice_metrics.go (0.0%)</option>
				
				<option value="file26">voicehelper/backend/pkg/monitoring/memory.go (0.0%)</option>
				
				<option value="file27">voicehelper/backend/pkg/ratelimit/redis_rate_limiter.go (0.0%)</option>
				
				<option value="file28">voicehelper/backend/pkg/security/audit.go (0.0%)</option>
				
				<option value="file29">voicehelper/backend/pkg/security/compliance.go (0.0%)</option>
				
				<option value="file30">voicehelper/backend/pkg/security/encryption.go (0.0%)</option>
				
				<option value="file31">voicehelper/backend/pkg/security/risk_engine.go (0.0%)</option>
				
				<option value="file32">voicehelper/backend/pkg/security/sql_security.go (0.0%)</option>
				
				<option value="file33">voicehelper/backend/pkg/security/zero_trust.go (0.0%)</option>
				
				<option value="file34">voicehelper/backend/pkg/storage/minio.go (0.0%)</option>
				
				<option value="file35">voicehelper/backend/pkg/types/events.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package errors

import (
        "fmt"
        "net/http"
)

// ErrorCode é”™è¯¯ç ç±»å‹
type ErrorCode int

// é”™è¯¯ç å®šä¹‰ - é‡‡ç”¨6ä½æ•°å­—ç¼–ç 
// æ ¼å¼: XYZABC
// X: æœåŠ¡ç±»å‹ (1:Gateway, 2:Auth, 3:Chat, 4:Voice, 5:RAG, 6:Storage, 7:Integration, 8:Monitor, 9:Common)
// Y: æ¨¡å—ç±»å‹ (0:é€šç”¨, 1:API, 2:Service, 3:Database, 4:Cache, 5:Network, 6:File, 7:Config, 8:Security, 9:Performance)
// Z: é”™è¯¯ç±»å‹ (0:æˆåŠŸ, 1:å®¢æˆ·ç«¯é”™è¯¯, 2:æœåŠ¡ç«¯é”™è¯¯, 3:ç½‘ç»œé”™è¯¯, 4:æ•°æ®é”™è¯¯, 5:æƒé™é”™è¯¯, 6:é…ç½®é”™è¯¯, 7:æ€§èƒ½é”™è¯¯, 8:å®‰å…¨é”™è¯¯, 9:æœªçŸ¥é”™è¯¯)
// ABC: å…·ä½“é”™è¯¯åºå· (001-999)

const (
        // æˆåŠŸç 
        Success ErrorCode = 000000

        // ========== GatewayæœåŠ¡é”™è¯¯ç  (1xxxxx) ==========
        // Gatewayé€šç”¨é”™è¯¯ (10xxxx)
        GatewayInternalError      ErrorCode = 102001 // Gatewayå†…éƒ¨é”™è¯¯
        GatewayServiceUnavailable ErrorCode = 102002 // GatewayæœåŠ¡ä¸å¯ç”¨
        GatewayTimeout            ErrorCode = 102003 // Gatewayè¶…æ—¶

        // Gateway APIé”™è¯¯ (11xxxx)
        GatewayInvalidRequest    ErrorCode = 111001 // æ— æ•ˆè¯·æ±‚
        GatewayMissingParameter  ErrorCode = 111002 // ç¼ºå°‘å‚æ•°
        GatewayInvalidParameter  ErrorCode = 111003 // å‚æ•°æ— æ•ˆ
        GatewayRequestTooLarge   ErrorCode = 111004 // è¯·æ±‚ä½“è¿‡å¤§
        GatewayRateLimitExceeded ErrorCode = 111005 // è¯·æ±‚é¢‘ç‡è¶…é™

        // Gatewayç½‘ç»œé”™è¯¯ (13xxxx)
        GatewayNetworkError     ErrorCode = 133001 // ç½‘ç»œé”™è¯¯
        GatewayConnectionFailed ErrorCode = 133002 // è¿æ¥å¤±è´¥
        GatewayDNSResolveFailed ErrorCode = 133003 // DNSè§£æå¤±è´¥

        // ========== è®¤è¯æœåŠ¡é”™è¯¯ç  (2xxxxx) ==========
        // è®¤è¯é€šç”¨é”™è¯¯ (20xxxx)
        AuthInternalError      ErrorCode = 202001 // è®¤è¯æœåŠ¡å†…éƒ¨é”™è¯¯
        AuthServiceUnavailable ErrorCode = 202002 // è®¤è¯æœåŠ¡ä¸å¯ç”¨

        // è®¤è¯APIé”™è¯¯ (21xxxx)
        AuthInvalidCredentials ErrorCode = 211001 // æ— æ•ˆå‡­è¯
        AuthTokenExpired       ErrorCode = 211002 // Tokenè¿‡æœŸ
        AuthTokenInvalid       ErrorCode = 211003 // Tokenæ— æ•ˆ
        AuthPermissionDenied   ErrorCode = 211004 // æƒé™ä¸è¶³
        AuthUserNotFound       ErrorCode = 211005 // ç”¨æˆ·ä¸å­˜åœ¨
        AuthUserDisabled       ErrorCode = 211006 // ç”¨æˆ·å·²ç¦ç”¨

        // è®¤è¯å®‰å…¨é”™è¯¯ (28xxxx)
        AuthSecurityViolation  ErrorCode = 281001 // å®‰å…¨è¿è§„
        AuthBruteForceDetected ErrorCode = 281002 // æ£€æµ‹åˆ°æš´åŠ›ç ´è§£
        AuthSuspiciousActivity ErrorCode = 281003 // å¯ç–‘æ´»åŠ¨

        // ========== èŠå¤©æœåŠ¡é”™è¯¯ç  (3xxxxx) ==========
        // èŠå¤©é€šç”¨é”™è¯¯ (30xxxx)
        ChatInternalError      ErrorCode = 302001 // èŠå¤©æœåŠ¡å†…éƒ¨é”™è¯¯
        ChatServiceUnavailable ErrorCode = 302002 // èŠå¤©æœåŠ¡ä¸å¯ç”¨

        // èŠå¤©APIé”™è¯¯ (31xxxx)
        ChatInvalidMessage       ErrorCode = 311001 // æ— æ•ˆæ¶ˆæ¯
        ChatMessageTooLong       ErrorCode = 311002 // æ¶ˆæ¯è¿‡é•¿
        ChatSessionNotFound      ErrorCode = 311003 // ä¼šè¯ä¸å­˜åœ¨
        ChatSessionExpired       ErrorCode = 311004 // ä¼šè¯è¿‡æœŸ
        ChatContextLimitExceeded ErrorCode = 311005 // ä¸Šä¸‹æ–‡é•¿åº¦è¶…é™

        // èŠå¤©æ€§èƒ½é”™è¯¯ (37xxxx)
        ChatResponseTimeout  ErrorCode = 371001 // å“åº”è¶…æ—¶
        ChatQueueFull        ErrorCode = 371002 // é˜Ÿåˆ—å·²æ»¡
        ChatConcurrencyLimit ErrorCode = 371003 // å¹¶å‘é™åˆ¶

        // ========== è¯­éŸ³æœåŠ¡é”™è¯¯ç  (4xxxxx) ==========
        // è¯­éŸ³é€šç”¨é”™è¯¯ (40xxxx)
        VoiceInternalError      ErrorCode = 402001 // è¯­éŸ³æœåŠ¡å†…éƒ¨é”™è¯¯
        VoiceServiceUnavailable ErrorCode = 402002 // è¯­éŸ³æœåŠ¡ä¸å¯ç”¨

        // è¯­éŸ³APIé”™è¯¯ (41xxxx)
        VoiceInvalidFormat         ErrorCode = 411001 // éŸ³é¢‘æ ¼å¼æ— æ•ˆ
        VoiceFileTooLarge          ErrorCode = 411002 // éŸ³é¢‘æ–‡ä»¶è¿‡å¤§
        VoiceProcessingFailed      ErrorCode = 411003 // éŸ³é¢‘å¤„ç†å¤±è´¥
        VoiceASRFailed             ErrorCode = 411004 // è¯­éŸ³è¯†åˆ«å¤±è´¥
        VoiceTTSFailed             ErrorCode = 411005 // è¯­éŸ³åˆæˆå¤±è´¥
        VoiceEmotionAnalysisFailed ErrorCode = 411006 // æƒ…æ„Ÿåˆ†æå¤±è´¥

        // è¯­éŸ³æ–‡ä»¶é”™è¯¯ (46xxxx)
        VoiceFileNotFound  ErrorCode = 461001 // éŸ³é¢‘æ–‡ä»¶ä¸å­˜åœ¨
        VoiceFileCorrupted ErrorCode = 461002 // éŸ³é¢‘æ–‡ä»¶æŸå
        VoiceStorageFailed ErrorCode = 461003 // éŸ³é¢‘å­˜å‚¨å¤±è´¥

        // ========== RAGæœåŠ¡é”™è¯¯ç  (5xxxxx) ==========
        // RAGé€šç”¨é”™è¯¯ (50xxxx)
        RAGInternalError      ErrorCode = 502001 // RAGæœåŠ¡å†…éƒ¨é”™è¯¯
        RAGServiceUnavailable ErrorCode = 502002 // RAGæœåŠ¡ä¸å¯ç”¨

        // RAG APIé”™è¯¯ (51xxxx)
        RAGInvalidQuery     ErrorCode = 511001 // æ— æ•ˆæŸ¥è¯¢
        RAGDocumentNotFound ErrorCode = 511002 // æ–‡æ¡£ä¸å­˜åœ¨
        RAGIndexingFailed   ErrorCode = 511003 // ç´¢å¼•å¤±è´¥
        RAGRetrievalFailed  ErrorCode = 511004 // æ£€ç´¢å¤±è´¥
        RAGEmbeddingFailed  ErrorCode = 511005 // å‘é‡åŒ–å¤±è´¥
        RAGRerankingFailed  ErrorCode = 511006 // é‡æ’åºå¤±è´¥

        // RAGæ•°æ®åº“é”™è¯¯ (53xxxx)
        RAGVectorDBError            ErrorCode = 533001 // å‘é‡æ•°æ®åº“é”™è¯¯
        RAGVectorDBConnectionFailed ErrorCode = 533002 // å‘é‡æ•°æ®åº“è¿æ¥å¤±è´¥
        RAGCollectionNotFound       ErrorCode = 533003 // é›†åˆä¸å­˜åœ¨

        // ========== å­˜å‚¨æœåŠ¡é”™è¯¯ç  (6xxxxx) ==========
        // å­˜å‚¨é€šç”¨é”™è¯¯ (60xxxx)
        StorageInternalError      ErrorCode = 602001 // å­˜å‚¨æœåŠ¡å†…éƒ¨é”™è¯¯
        StorageServiceUnavailable ErrorCode = 602002 // å­˜å‚¨æœåŠ¡ä¸å¯ç”¨

        // å­˜å‚¨æ–‡ä»¶é”™è¯¯ (66xxxx)
        StorageFileNotFound      ErrorCode = 661001 // æ–‡ä»¶ä¸å­˜åœ¨
        StorageFileAccessDenied  ErrorCode = 661002 // æ–‡ä»¶è®¿é—®è¢«æ‹’ç»
        StorageFileCorrupted     ErrorCode = 661003 // æ–‡ä»¶æŸå
        StorageInsufficientSpace ErrorCode = 661004 // å­˜å‚¨ç©ºé—´ä¸è¶³
        StorageUploadFailed      ErrorCode = 661005 // æ–‡ä»¶ä¸Šä¼ å¤±è´¥
        StorageDownloadFailed    ErrorCode = 661006 // æ–‡ä»¶ä¸‹è½½å¤±è´¥

        // ========== é›†æˆæœåŠ¡é”™è¯¯ç  (7xxxxx) ==========
        // é›†æˆé€šç”¨é”™è¯¯ (70xxxx)
        IntegrationInternalError      ErrorCode = 702001 // é›†æˆæœåŠ¡å†…éƒ¨é”™è¯¯
        IntegrationServiceUnavailable ErrorCode = 702002 // é›†æˆæœåŠ¡ä¸å¯ç”¨

        // é›†æˆAPIé”™è¯¯ (71xxxx)
        IntegrationInvalidConfig    ErrorCode = 711001 // æ— æ•ˆé…ç½®
        IntegrationConnectionFailed ErrorCode = 711002 // è¿æ¥å¤±è´¥
        IntegrationAuthFailed       ErrorCode = 711003 // è®¤è¯å¤±è´¥
        IntegrationAPILimitExceeded ErrorCode = 711004 // APIè°ƒç”¨é™åˆ¶è¶…å‡º
        IntegrationDataSyncFailed   ErrorCode = 711005 // æ•°æ®åŒæ­¥å¤±è´¥

        // ========== ç›‘æ§æœåŠ¡é”™è¯¯ç  (8xxxxx) ==========
        // ç›‘æ§é€šç”¨é”™è¯¯ (80xxxx)
        MonitorInternalError      ErrorCode = 802001 // ç›‘æ§æœåŠ¡å†…éƒ¨é”™è¯¯
        MonitorServiceUnavailable ErrorCode = 802002 // ç›‘æ§æœåŠ¡ä¸å¯ç”¨

        // ç›‘æ§APIé”™è¯¯ (81xxxx)
        MonitorMetricNotFound     ErrorCode = 811001 // æŒ‡æ ‡ä¸å­˜åœ¨
        MonitorInvalidTimeRange   ErrorCode = 811002 // æ— æ•ˆæ—¶é—´èŒƒå›´
        MonitorQueryFailed        ErrorCode = 811003 // æŸ¥è¯¢å¤±è´¥
        MonitorAlertConfigInvalid ErrorCode = 811004 // å‘Šè­¦é…ç½®æ— æ•ˆ

        // ========== é€šç”¨é”™è¯¯ç  (9xxxxx) ==========
        // é€šç”¨ç³»ç»Ÿé”™è¯¯ (90xxxx)
        SystemInternalError   ErrorCode = 902001 // ç³»ç»Ÿå†…éƒ¨é”™è¯¯
        SystemMaintenanceMode ErrorCode = 902002 // ç³»ç»Ÿç»´æŠ¤æ¨¡å¼
        SystemOverloaded      ErrorCode = 902003 // ç³»ç»Ÿè¿‡è½½

        // é€šç”¨é…ç½®é”™è¯¯ (96xxxx)
        ConfigNotFound   ErrorCode = 961001 // é…ç½®ä¸å­˜åœ¨
        ConfigInvalid    ErrorCode = 961002 // é…ç½®æ— æ•ˆ
        ConfigLoadFailed ErrorCode = 961003 // é…ç½®åŠ è½½å¤±è´¥

        // é€šç”¨ç½‘ç»œé”™è¯¯ (93xxxx)
        NetworkTimeout           ErrorCode = 933001 // ç½‘ç»œè¶…æ—¶
        NetworkConnectionRefused ErrorCode = 933002 // è¿æ¥è¢«æ‹’ç»
        NetworkHostUnreachable   ErrorCode = 933003 // ä¸»æœºä¸å¯è¾¾
)

// ErrorInfo é”™è¯¯ä¿¡æ¯ç»“æ„
type ErrorInfo struct {
        Code        ErrorCode `json:"code"`
        Message     string    `json:"message"`
        Description string    `json:"description"`
        HTTPStatus  int       `json:"http_status"`
        Category    string    `json:"category"`
        Service     string    `json:"service"`
}

// errorInfoMap é”™è¯¯ç ä¿¡æ¯æ˜ å°„
var errorInfoMap = map[ErrorCode]ErrorInfo{
        Success: {Success, "Success", "æ“ä½œæˆåŠŸ", http.StatusOK, "Success", "Common"},

        // Gatewayé”™è¯¯
        GatewayInternalError:      {GatewayInternalError, "Gateway Internal Error", "ç½‘å…³å†…éƒ¨é”™è¯¯", http.StatusInternalServerError, "Gateway", "Gateway"},
        GatewayServiceUnavailable: {GatewayServiceUnavailable, "Gateway Service Unavailable", "ç½‘å…³æœåŠ¡ä¸å¯ç”¨", http.StatusServiceUnavailable, "Gateway", "Gateway"},
        GatewayTimeout:            {GatewayTimeout, "Gateway Timeout", "ç½‘å…³è¶…æ—¶", http.StatusGatewayTimeout, "Gateway", "Gateway"},
        GatewayInvalidRequest:     {GatewayInvalidRequest, "Invalid Request", "æ— æ•ˆè¯·æ±‚", http.StatusBadRequest, "Gateway", "Gateway"},
        GatewayMissingParameter:   {GatewayMissingParameter, "Missing Parameter", "ç¼ºå°‘å‚æ•°", http.StatusBadRequest, "Gateway", "Gateway"},
        GatewayInvalidParameter:   {GatewayInvalidParameter, "Invalid Parameter", "å‚æ•°æ— æ•ˆ", http.StatusBadRequest, "Gateway", "Gateway"},
        GatewayRequestTooLarge:    {GatewayRequestTooLarge, "Request Too Large", "è¯·æ±‚ä½“è¿‡å¤§", http.StatusRequestEntityTooLarge, "Gateway", "Gateway"},
        GatewayRateLimitExceeded:  {GatewayRateLimitExceeded, "Rate Limit Exceeded", "è¯·æ±‚é¢‘ç‡è¶…é™", http.StatusTooManyRequests, "Gateway", "Gateway"},
        GatewayNetworkError:       {GatewayNetworkError, "Network Error", "ç½‘ç»œé”™è¯¯", http.StatusBadGateway, "Gateway", "Gateway"},
        GatewayConnectionFailed:   {GatewayConnectionFailed, "Connection Failed", "è¿æ¥å¤±è´¥", http.StatusBadGateway, "Gateway", "Gateway"},
        GatewayDNSResolveFailed:   {GatewayDNSResolveFailed, "DNS Resolve Failed", "DNSè§£æå¤±è´¥", http.StatusBadGateway, "Gateway", "Gateway"},

        // è®¤è¯é”™è¯¯
        AuthInternalError:      {AuthInternalError, "Auth Internal Error", "è®¤è¯æœåŠ¡å†…éƒ¨é”™è¯¯", http.StatusInternalServerError, "Auth", "Auth"},
        AuthServiceUnavailable: {AuthServiceUnavailable, "Auth Service Unavailable", "è®¤è¯æœåŠ¡ä¸å¯ç”¨", http.StatusServiceUnavailable, "Auth", "Auth"},
        AuthInvalidCredentials: {AuthInvalidCredentials, "Invalid Credentials", "æ— æ•ˆå‡­è¯", http.StatusUnauthorized, "Auth", "Auth"},
        AuthTokenExpired:       {AuthTokenExpired, "Token Expired", "Tokenè¿‡æœŸ", http.StatusUnauthorized, "Auth", "Auth"},
        AuthTokenInvalid:       {AuthTokenInvalid, "Token Invalid", "Tokenæ— æ•ˆ", http.StatusUnauthorized, "Auth", "Auth"},
        AuthPermissionDenied:   {AuthPermissionDenied, "Permission Denied", "æƒé™ä¸è¶³", http.StatusForbidden, "Auth", "Auth"},
        AuthUserNotFound:       {AuthUserNotFound, "User Not Found", "ç”¨æˆ·ä¸å­˜åœ¨", http.StatusNotFound, "Auth", "Auth"},
        AuthUserDisabled:       {AuthUserDisabled, "User Disabled", "ç”¨æˆ·å·²ç¦ç”¨", http.StatusForbidden, "Auth", "Auth"},
        AuthSecurityViolation:  {AuthSecurityViolation, "Security Violation", "å®‰å…¨è¿è§„", http.StatusForbidden, "Auth", "Auth"},
        AuthBruteForceDetected: {AuthBruteForceDetected, "Brute Force Detected", "æ£€æµ‹åˆ°æš´åŠ›ç ´è§£", http.StatusTooManyRequests, "Auth", "Auth"},
        AuthSuspiciousActivity: {AuthSuspiciousActivity, "Suspicious Activity", "å¯ç–‘æ´»åŠ¨", http.StatusForbidden, "Auth", "Auth"},

        // èŠå¤©é”™è¯¯
        ChatInternalError:        {ChatInternalError, "Chat Internal Error", "èŠå¤©æœåŠ¡å†…éƒ¨é”™è¯¯", http.StatusInternalServerError, "Chat", "Chat"},
        ChatServiceUnavailable:   {ChatServiceUnavailable, "Chat Service Unavailable", "èŠå¤©æœåŠ¡ä¸å¯ç”¨", http.StatusServiceUnavailable, "Chat", "Chat"},
        ChatInvalidMessage:       {ChatInvalidMessage, "Invalid Message", "æ— æ•ˆæ¶ˆæ¯", http.StatusBadRequest, "Chat", "Chat"},
        ChatMessageTooLong:       {ChatMessageTooLong, "Message Too Long", "æ¶ˆæ¯è¿‡é•¿", http.StatusBadRequest, "Chat", "Chat"},
        ChatSessionNotFound:      {ChatSessionNotFound, "Session Not Found", "ä¼šè¯ä¸å­˜åœ¨", http.StatusNotFound, "Chat", "Chat"},
        ChatSessionExpired:       {ChatSessionExpired, "Session Expired", "ä¼šè¯è¿‡æœŸ", http.StatusGone, "Chat", "Chat"},
        ChatContextLimitExceeded: {ChatContextLimitExceeded, "Context Limit Exceeded", "ä¸Šä¸‹æ–‡é•¿åº¦è¶…é™", http.StatusBadRequest, "Chat", "Chat"},
        ChatResponseTimeout:      {ChatResponseTimeout, "Response Timeout", "å“åº”è¶…æ—¶", http.StatusRequestTimeout, "Chat", "Chat"},
        ChatQueueFull:            {ChatQueueFull, "Queue Full", "é˜Ÿåˆ—å·²æ»¡", http.StatusServiceUnavailable, "Chat", "Chat"},
        ChatConcurrencyLimit:     {ChatConcurrencyLimit, "Concurrency Limit", "å¹¶å‘é™åˆ¶", http.StatusTooManyRequests, "Chat", "Chat"},

        // è¯­éŸ³é”™è¯¯
        VoiceInternalError:         {VoiceInternalError, "Voice Internal Error", "è¯­éŸ³æœåŠ¡å†…éƒ¨é”™è¯¯", http.StatusInternalServerError, "Voice", "Voice"},
        VoiceServiceUnavailable:    {VoiceServiceUnavailable, "Voice Service Unavailable", "è¯­éŸ³æœåŠ¡ä¸å¯ç”¨", http.StatusServiceUnavailable, "Voice", "Voice"},
        VoiceInvalidFormat:         {VoiceInvalidFormat, "Invalid Audio Format", "éŸ³é¢‘æ ¼å¼æ— æ•ˆ", http.StatusBadRequest, "Voice", "Voice"},
        VoiceFileTooLarge:          {VoiceFileTooLarge, "Audio File Too Large", "éŸ³é¢‘æ–‡ä»¶è¿‡å¤§", http.StatusRequestEntityTooLarge, "Voice", "Voice"},
        VoiceProcessingFailed:      {VoiceProcessingFailed, "Audio Processing Failed", "éŸ³é¢‘å¤„ç†å¤±è´¥", http.StatusInternalServerError, "Voice", "Voice"},
        VoiceASRFailed:             {VoiceASRFailed, "ASR Failed", "è¯­éŸ³è¯†åˆ«å¤±è´¥", http.StatusInternalServerError, "Voice", "Voice"},
        VoiceTTSFailed:             {VoiceTTSFailed, "TTS Failed", "è¯­éŸ³åˆæˆå¤±è´¥", http.StatusInternalServerError, "Voice", "Voice"},
        VoiceEmotionAnalysisFailed: {VoiceEmotionAnalysisFailed, "Emotion Analysis Failed", "æƒ…æ„Ÿåˆ†æå¤±è´¥", http.StatusInternalServerError, "Voice", "Voice"},
        VoiceFileNotFound:          {VoiceFileNotFound, "Audio File Not Found", "éŸ³é¢‘æ–‡ä»¶ä¸å­˜åœ¨", http.StatusNotFound, "Voice", "Voice"},
        VoiceFileCorrupted:         {VoiceFileCorrupted, "Audio File Corrupted", "éŸ³é¢‘æ–‡ä»¶æŸå", http.StatusBadRequest, "Voice", "Voice"},
        VoiceStorageFailed:         {VoiceStorageFailed, "Audio Storage Failed", "éŸ³é¢‘å­˜å‚¨å¤±è´¥", http.StatusInternalServerError, "Voice", "Voice"},

        // RAGé”™è¯¯
        RAGInternalError:            {RAGInternalError, "RAG Internal Error", "RAGæœåŠ¡å†…éƒ¨é”™è¯¯", http.StatusInternalServerError, "RAG", "RAG"},
        RAGServiceUnavailable:       {RAGServiceUnavailable, "RAG Service Unavailable", "RAGæœåŠ¡ä¸å¯ç”¨", http.StatusServiceUnavailable, "RAG", "RAG"},
        RAGInvalidQuery:             {RAGInvalidQuery, "Invalid Query", "æ— æ•ˆæŸ¥è¯¢", http.StatusBadRequest, "RAG", "RAG"},
        RAGDocumentNotFound:         {RAGDocumentNotFound, "Document Not Found", "æ–‡æ¡£ä¸å­˜åœ¨", http.StatusNotFound, "RAG", "RAG"},
        RAGIndexingFailed:           {RAGIndexingFailed, "Indexing Failed", "ç´¢å¼•å¤±è´¥", http.StatusInternalServerError, "RAG", "RAG"},
        RAGRetrievalFailed:          {RAGRetrievalFailed, "Retrieval Failed", "æ£€ç´¢å¤±è´¥", http.StatusInternalServerError, "RAG", "RAG"},
        RAGEmbeddingFailed:          {RAGEmbeddingFailed, "Embedding Failed", "å‘é‡åŒ–å¤±è´¥", http.StatusInternalServerError, "RAG", "RAG"},
        RAGRerankingFailed:          {RAGRerankingFailed, "Reranking Failed", "é‡æ’åºå¤±è´¥", http.StatusInternalServerError, "RAG", "RAG"},
        RAGVectorDBError:            {RAGVectorDBError, "Vector DB Error", "å‘é‡æ•°æ®åº“é”™è¯¯", http.StatusInternalServerError, "RAG", "RAG"},
        RAGVectorDBConnectionFailed: {RAGVectorDBConnectionFailed, "Vector DB Connection Failed", "å‘é‡æ•°æ®åº“è¿æ¥å¤±è´¥", http.StatusServiceUnavailable, "RAG", "RAG"},
        RAGCollectionNotFound:       {RAGCollectionNotFound, "Collection Not Found", "é›†åˆä¸å­˜åœ¨", http.StatusNotFound, "RAG", "RAG"},

        // å­˜å‚¨é”™è¯¯
        StorageInternalError:      {StorageInternalError, "Storage Internal Error", "å­˜å‚¨æœåŠ¡å†…éƒ¨é”™è¯¯", http.StatusInternalServerError, "Storage", "Storage"},
        StorageServiceUnavailable: {StorageServiceUnavailable, "Storage Service Unavailable", "å­˜å‚¨æœåŠ¡ä¸å¯ç”¨", http.StatusServiceUnavailable, "Storage", "Storage"},
        StorageFileNotFound:       {StorageFileNotFound, "File Not Found", "æ–‡ä»¶ä¸å­˜åœ¨", http.StatusNotFound, "Storage", "Storage"},
        StorageFileAccessDenied:   {StorageFileAccessDenied, "File Access Denied", "æ–‡ä»¶è®¿é—®è¢«æ‹’ç»", http.StatusForbidden, "Storage", "Storage"},
        StorageFileCorrupted:      {StorageFileCorrupted, "File Corrupted", "æ–‡ä»¶æŸå", http.StatusBadRequest, "Storage", "Storage"},
        StorageInsufficientSpace:  {StorageInsufficientSpace, "Insufficient Space", "å­˜å‚¨ç©ºé—´ä¸è¶³", http.StatusInsufficientStorage, "Storage", "Storage"},
        StorageUploadFailed:       {StorageUploadFailed, "Upload Failed", "æ–‡ä»¶ä¸Šä¼ å¤±è´¥", http.StatusInternalServerError, "Storage", "Storage"},
        StorageDownloadFailed:     {StorageDownloadFailed, "Download Failed", "æ–‡ä»¶ä¸‹è½½å¤±è´¥", http.StatusInternalServerError, "Storage", "Storage"},

        // é›†æˆé”™è¯¯
        IntegrationInternalError:      {IntegrationInternalError, "Integration Internal Error", "é›†æˆæœåŠ¡å†…éƒ¨é”™è¯¯", http.StatusInternalServerError, "Integration", "Integration"},
        IntegrationServiceUnavailable: {IntegrationServiceUnavailable, "Integration Service Unavailable", "é›†æˆæœåŠ¡ä¸å¯ç”¨", http.StatusServiceUnavailable, "Integration", "Integration"},
        IntegrationInvalidConfig:      {IntegrationInvalidConfig, "Invalid Config", "æ— æ•ˆé…ç½®", http.StatusBadRequest, "Integration", "Integration"},
        IntegrationConnectionFailed:   {IntegrationConnectionFailed, "Connection Failed", "è¿æ¥å¤±è´¥", http.StatusBadGateway, "Integration", "Integration"},
        IntegrationAuthFailed:         {IntegrationAuthFailed, "Auth Failed", "è®¤è¯å¤±è´¥", http.StatusUnauthorized, "Integration", "Integration"},
        IntegrationAPILimitExceeded:   {IntegrationAPILimitExceeded, "API Limit Exceeded", "APIè°ƒç”¨é™åˆ¶è¶…å‡º", http.StatusTooManyRequests, "Integration", "Integration"},
        IntegrationDataSyncFailed:     {IntegrationDataSyncFailed, "Data Sync Failed", "æ•°æ®åŒæ­¥å¤±è´¥", http.StatusInternalServerError, "Integration", "Integration"},

        // ç›‘æ§é”™è¯¯
        MonitorInternalError:      {MonitorInternalError, "Monitor Internal Error", "ç›‘æ§æœåŠ¡å†…éƒ¨é”™è¯¯", http.StatusInternalServerError, "Monitor", "Monitor"},
        MonitorServiceUnavailable: {MonitorServiceUnavailable, "Monitor Service Unavailable", "ç›‘æ§æœåŠ¡ä¸å¯ç”¨", http.StatusServiceUnavailable, "Monitor", "Monitor"},
        MonitorMetricNotFound:     {MonitorMetricNotFound, "Metric Not Found", "æŒ‡æ ‡ä¸å­˜åœ¨", http.StatusNotFound, "Monitor", "Monitor"},
        MonitorInvalidTimeRange:   {MonitorInvalidTimeRange, "Invalid Time Range", "æ— æ•ˆæ—¶é—´èŒƒå›´", http.StatusBadRequest, "Monitor", "Monitor"},
        MonitorQueryFailed:        {MonitorQueryFailed, "Query Failed", "æŸ¥è¯¢å¤±è´¥", http.StatusInternalServerError, "Monitor", "Monitor"},
        MonitorAlertConfigInvalid: {MonitorAlertConfigInvalid, "Alert Config Invalid", "å‘Šè­¦é…ç½®æ— æ•ˆ", http.StatusBadRequest, "Monitor", "Monitor"},

        // é€šç”¨é”™è¯¯
        SystemInternalError:      {SystemInternalError, "System Internal Error", "ç³»ç»Ÿå†…éƒ¨é”™è¯¯", http.StatusInternalServerError, "System", "Common"},
        SystemMaintenanceMode:    {SystemMaintenanceMode, "System Maintenance Mode", "ç³»ç»Ÿç»´æŠ¤æ¨¡å¼", http.StatusServiceUnavailable, "System", "Common"},
        SystemOverloaded:         {SystemOverloaded, "System Overloaded", "ç³»ç»Ÿè¿‡è½½", http.StatusServiceUnavailable, "System", "Common"},
        ConfigNotFound:           {ConfigNotFound, "Config Not Found", "é…ç½®ä¸å­˜åœ¨", http.StatusNotFound, "Config", "Common"},
        ConfigInvalid:            {ConfigInvalid, "Config Invalid", "é…ç½®æ— æ•ˆ", http.StatusBadRequest, "Config", "Common"},
        ConfigLoadFailed:         {ConfigLoadFailed, "Config Load Failed", "é…ç½®åŠ è½½å¤±è´¥", http.StatusInternalServerError, "Config", "Common"},
        NetworkTimeout:           {NetworkTimeout, "Network Timeout", "ç½‘ç»œè¶…æ—¶", http.StatusRequestTimeout, "Network", "Common"},
        NetworkConnectionRefused: {NetworkConnectionRefused, "Connection Refused", "è¿æ¥è¢«æ‹’ç»", http.StatusBadGateway, "Network", "Common"},
        NetworkHostUnreachable:   {NetworkHostUnreachable, "Host Unreachable", "ä¸»æœºä¸å¯è¾¾", http.StatusBadGateway, "Network", "Common"},
}

// GetErrorInfo è·å–é”™è¯¯ä¿¡æ¯
func GetErrorInfo(code ErrorCode) ErrorInfo <span class="cov0" title="0">{
        if info, exists := errorInfoMap[code]; exists </span><span class="cov0" title="0">{
                return info
        }</span>
        <span class="cov0" title="0">return ErrorInfo{
                Code:        code,
                Message:     "Unknown Error",
                Description: fmt.Sprintf("æœªçŸ¥é”™è¯¯ç : %d", code),
                HTTPStatus:  http.StatusInternalServerError,
                Category:    "Unknown",
                Service:     "Unknown",
        }</span>
}

// String è¿”å›é”™è¯¯ç çš„å­—ç¬¦ä¸²è¡¨ç¤º
func (e ErrorCode) String() string <span class="cov0" title="0">{
        info := GetErrorInfo(e)
        return fmt.Sprintf("[%d] %s: %s", e, info.Message, info.Description)
}</span>

// HTTPStatus è¿”å›å¯¹åº”çš„HTTPçŠ¶æ€ç 
func (e ErrorCode) HTTPStatus() int <span class="cov0" title="0">{
        return GetErrorInfo(e).HTTPStatus
}</span>

// Message è¿”å›é”™è¯¯æ¶ˆæ¯
func (e ErrorCode) Message() string <span class="cov0" title="0">{
        return GetErrorInfo(e).Message
}</span>

// Description è¿”å›é”™è¯¯æè¿°
func (e ErrorCode) Description() string <span class="cov0" title="0">{
        return GetErrorInfo(e).Description
}</span>

// Category è¿”å›é”™è¯¯åˆ†ç±»
func (e ErrorCode) Category() string <span class="cov0" title="0">{
        return GetErrorInfo(e).Category
}</span>

// Service è¿”å›æ‰€å±æœåŠ¡
func (e ErrorCode) Service() string <span class="cov0" title="0">{
        return GetErrorInfo(e).Service
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package logger

import (
        "context"
        "fmt"
        "net"
        "net/http"
        "os"
        "runtime"
        "strings"
        "time"

        "voicehelper/backend/common/errors"

        "github.com/gin-gonic/gin"
        "github.com/sirupsen/logrus"
)

// LogLevel æ—¥å¿—çº§åˆ«
type LogLevel string

const (
        DebugLevel LogLevel = "debug"
        InfoLevel  LogLevel = "info"
        WarnLevel  LogLevel = "warn"
        ErrorLevel LogLevel = "error"
        FatalLevel LogLevel = "fatal"
        PanicLevel LogLevel = "panic"
)

// LogType æ—¥å¿—ç±»å‹
type LogType string

const (
        StartupLog     LogType = "startup"     // å¯åŠ¨æ—¥å¿—
        RequestLog     LogType = "request"     // è¯·æ±‚æ—¥å¿—
        ResponseLog    LogType = "response"    // å“åº”æ—¥å¿—
        ErrorLog       LogType = "error"       // é”™è¯¯æ—¥å¿—
        DebugLog       LogType = "debug"       // è°ƒè¯•æ—¥å¿—
        PerformanceLog LogType = "performance" // æ€§èƒ½æ—¥å¿—
        SecurityLog    LogType = "security"    // å®‰å…¨æ—¥å¿—
        BusinessLog    LogType = "business"    // ä¸šåŠ¡æ—¥å¿—
        SystemLog      LogType = "system"      // ç³»ç»Ÿæ—¥å¿—
)

// NetworkInfo ç½‘ç»œä¿¡æ¯
type NetworkInfo struct {
        LocalIP    string `json:"local_ip"`
        LocalPort  string `json:"local_port"`
        RemoteIP   string `json:"remote_ip"`
        RemotePort string `json:"remote_port"`
        URL        string `json:"url"`
        Method     string `json:"method"`
        UserAgent  string `json:"user_agent"`
        RequestID  string `json:"request_id"`
}

// LogEntry æ—¥å¿—æ¡ç›®
type LogEntry struct {
        Timestamp    time.Time              `json:"timestamp"`
        Level        LogLevel               `json:"level"`
        Type         LogType                `json:"type"`
        Service      string                 `json:"service"`
        Module       string                 `json:"module"`
        Message      string                 `json:"message"`
        ErrorCode    errors.ErrorCode       `json:"error_code,omitempty"`
        Network      *NetworkInfo           `json:"network,omitempty"`
        Context      map[string]interface{} `json:"context,omitempty"`
        Stack        string                 `json:"stack,omitempty"`
        Duration     time.Duration          `json:"duration,omitempty"`
        RequestSize  int64                  `json:"request_size,omitempty"`
        ResponseSize int64                  `json:"response_size,omitempty"`
        StatusCode   int                    `json:"status_code,omitempty"`
}

// Logger æ—¥å¿—å™¨æ¥å£
type Logger interface {
        Debug(msg string, fields ...Field)
        Info(msg string, fields ...Field)
        Warn(msg string, fields ...Field)
        Error(msg string, fields ...Field)
        Fatal(msg string, fields ...Field)
        Panic(msg string, fields ...Field)

        // ç‰¹å®šç±»å‹æ—¥å¿—
        Startup(msg string, fields ...Field)
        Request(req *http.Request, fields ...Field)
        Response(req *http.Request, statusCode int, duration time.Duration, fields ...Field)
        ErrorWithCode(code errors.ErrorCode, msg string, fields ...Field)
        Performance(operation string, duration time.Duration, fields ...Field)
        Security(event string, fields ...Field)
        Business(event string, fields ...Field)

        // ä¸Šä¸‹æ–‡æ—¥å¿—
        WithContext(ctx context.Context) Logger
        WithFields(fields ...Field) Logger
        WithService(service string) Logger
        WithModule(module string) Logger
}

// Field æ—¥å¿—å­—æ®µ
type Field struct {
        Key   string
        Value interface{}
}

// VoiceHelperLogger VoiceHelperæ—¥å¿—å™¨å®ç°
type VoiceHelperLogger struct {
        logger  *logrus.Logger
        service string
        module  string
        fields  map[string]interface{}
        ctx     context.Context
}

// NewLogger åˆ›å»ºæ–°çš„æ—¥å¿—å™¨
func NewLogger(service string) Logger <span class="cov0" title="0">{
        logger := logrus.New()

        // è®¾ç½®æ—¥å¿—æ ¼å¼ä¸ºJSON
        logger.SetFormatter(&amp;logrus.JSONFormatter{
                TimestampFormat: time.RFC3339Nano,
                FieldMap: logrus.FieldMap{
                        logrus.FieldKeyTime:  "timestamp",
                        logrus.FieldKeyLevel: "level",
                        logrus.FieldKeyMsg:   "message",
                },
        })

        // è®¾ç½®æ—¥å¿—çº§åˆ«
        level := strings.ToLower(os.Getenv("LOG_LEVEL"))
        switch level </span>{
        case "debug":<span class="cov0" title="0">
                logger.SetLevel(logrus.DebugLevel)</span>
        case "info":<span class="cov0" title="0">
                logger.SetLevel(logrus.InfoLevel)</span>
        case "warn":<span class="cov0" title="0">
                logger.SetLevel(logrus.WarnLevel)</span>
        case "error":<span class="cov0" title="0">
                logger.SetLevel(logrus.ErrorLevel)</span>
        case "fatal":<span class="cov0" title="0">
                logger.SetLevel(logrus.FatalLevel)</span>
        case "panic":<span class="cov0" title="0">
                logger.SetLevel(logrus.PanicLevel)</span>
        default:<span class="cov0" title="0">
                logger.SetLevel(logrus.InfoLevel)</span>
        }

        // è®¾ç½®è¾“å‡º
        <span class="cov0" title="0">logger.SetOutput(os.Stdout)

        return &amp;VoiceHelperLogger{
                logger:  logger,
                service: service,
                fields:  make(map[string]interface{}),
        }</span>
}

// getNetworkInfo è·å–ç½‘ç»œä¿¡æ¯
func getNetworkInfo(req *http.Request) *NetworkInfo <span class="cov0" title="0">{
        if req == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // è·å–æœ¬åœ°IPå’Œç«¯å£
        <span class="cov0" title="0">localAddr := req.Context().Value(http.LocalAddrContextKey)
        var localIP, localPort string
        if addr, ok := localAddr.(net.Addr); ok </span><span class="cov0" title="0">{
                host, port, _ := net.SplitHostPort(addr.String())
                localIP = host
                localPort = port
        }</span>

        // è·å–è¿œç¨‹IPå’Œç«¯å£
        <span class="cov0" title="0">remoteIP := getClientIP(req)
        remotePort := ""
        if host, port, err := net.SplitHostPort(req.RemoteAddr); err == nil </span><span class="cov0" title="0">{
                if remoteIP == "" </span><span class="cov0" title="0">{
                        remoteIP = host
                }</span>
                <span class="cov0" title="0">remotePort = port</span>
        }

        // è·å–è¯·æ±‚ID
        <span class="cov0" title="0">requestID := req.Header.Get("X-Request-ID")
        if requestID == "" </span><span class="cov0" title="0">{
                requestID = req.Header.Get("X-Trace-ID")
        }</span>

        <span class="cov0" title="0">return &amp;NetworkInfo{
                LocalIP:    localIP,
                LocalPort:  localPort,
                RemoteIP:   remoteIP,
                RemotePort: remotePort,
                URL:        req.URL.String(),
                Method:     req.Method,
                UserAgent:  req.UserAgent(),
                RequestID:  requestID,
        }</span>
}

// getClientIP è·å–å®¢æˆ·ç«¯çœŸå®IP
func getClientIP(req *http.Request) string <span class="cov0" title="0">{
        // æ£€æŸ¥X-Forwarded-Forå¤´
        if xff := req.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov0" title="0">{
                ips := strings.Split(xff, ",")
                if len(ips) &gt; 0 </span><span class="cov0" title="0">{
                        return strings.TrimSpace(ips[0])
                }</span>
        }

        // æ£€æŸ¥X-Real-IPå¤´
        <span class="cov0" title="0">if xri := req.Header.Get("X-Real-IP"); xri != "" </span><span class="cov0" title="0">{
                return xri
        }</span>

        // æ£€æŸ¥X-Client-IPå¤´
        <span class="cov0" title="0">if xci := req.Header.Get("X-Client-IP"); xci != "" </span><span class="cov0" title="0">{
                return xci
        }</span>

        // ä½¿ç”¨RemoteAddr
        <span class="cov0" title="0">if ip, _, err := net.SplitHostPort(req.RemoteAddr); err == nil </span><span class="cov0" title="0">{
                return ip
        }</span>

        <span class="cov0" title="0">return req.RemoteAddr</span>
}

// buildLogEntry æ„å»ºæ—¥å¿—æ¡ç›®
func (l *VoiceHelperLogger) buildLogEntry(level LogLevel, logType LogType, msg string, fields []Field) *LogEntry <span class="cov0" title="0">{
        entry := &amp;LogEntry{
                Timestamp: time.Now(),
                Level:     level,
                Type:      logType,
                Service:   l.service,
                Module:    l.module,
                Message:   msg,
                Context:   make(map[string]interface{}),
        }

        // æ·»åŠ åŸºç¡€å­—æ®µ
        for k, v := range l.fields </span><span class="cov0" title="0">{
                entry.Context[k] = v
        }</span>

        // æ·»åŠ ä¼ å…¥çš„å­—æ®µ
        <span class="cov0" title="0">for _, field := range fields </span><span class="cov0" title="0">{
                entry.Context[field.Key] = field.Value
        }</span>

        // æ·»åŠ è°ƒç”¨æ ˆä¿¡æ¯ï¼ˆä»…é”™è¯¯çº§åˆ«ï¼‰
        <span class="cov0" title="0">if level == ErrorLevel || level == FatalLevel || level == PanicLevel </span><span class="cov0" title="0">{
                entry.Stack = getStackTrace()
        }</span>

        <span class="cov0" title="0">return entry</span>
}

// getStackTrace è·å–è°ƒç”¨æ ˆ
func getStackTrace() string <span class="cov0" title="0">{
        buf := make([]byte, 4096)
        n := runtime.Stack(buf, false)
        return string(buf[:n])
}</span>

// log è®°å½•æ—¥å¿—
func (l *VoiceHelperLogger) log(level LogLevel, logType LogType, msg string, fields []Field) <span class="cov0" title="0">{
        entry := l.buildLogEntry(level, logType, msg, fields)

        // è½¬æ¢ä¸ºlogruså­—æ®µ
        logrusFields := logrus.Fields{
                "type":    string(entry.Type),
                "service": entry.Service,
                "module":  entry.Module,
        }

        if entry.ErrorCode != 0 </span><span class="cov0" title="0">{
                logrusFields["error_code"] = entry.ErrorCode
        }</span>

        <span class="cov0" title="0">if entry.Network != nil </span><span class="cov0" title="0">{
                logrusFields["network"] = entry.Network
        }</span>

        <span class="cov0" title="0">if entry.Context != nil &amp;&amp; len(entry.Context) &gt; 0 </span><span class="cov0" title="0">{
                logrusFields["context"] = entry.Context
        }</span>

        <span class="cov0" title="0">if entry.Stack != "" </span><span class="cov0" title="0">{
                logrusFields["stack"] = entry.Stack
        }</span>

        <span class="cov0" title="0">if entry.Duration &gt; 0 </span><span class="cov0" title="0">{
                logrusFields["duration_ms"] = entry.Duration.Milliseconds()
        }</span>

        <span class="cov0" title="0">if entry.RequestSize &gt; 0 </span><span class="cov0" title="0">{
                logrusFields["request_size"] = entry.RequestSize
        }</span>

        <span class="cov0" title="0">if entry.ResponseSize &gt; 0 </span><span class="cov0" title="0">{
                logrusFields["response_size"] = entry.ResponseSize
        }</span>

        <span class="cov0" title="0">if entry.StatusCode &gt; 0 </span><span class="cov0" title="0">{
                logrusFields["status_code"] = entry.StatusCode
        }</span>

        // è®°å½•æ—¥å¿—
        <span class="cov0" title="0">logEntry := l.logger.WithFields(logrusFields)
        switch level </span>{
        case DebugLevel:<span class="cov0" title="0">
                logEntry.Debug(msg)</span>
        case InfoLevel:<span class="cov0" title="0">
                logEntry.Info(msg)</span>
        case WarnLevel:<span class="cov0" title="0">
                logEntry.Warn(msg)</span>
        case ErrorLevel:<span class="cov0" title="0">
                logEntry.Error(msg)</span>
        case FatalLevel:<span class="cov0" title="0">
                logEntry.Fatal(msg)</span>
        case PanicLevel:<span class="cov0" title="0">
                logEntry.Panic(msg)</span>
        }
}

// Debug è®°å½•è°ƒè¯•æ—¥å¿—
func (l *VoiceHelperLogger) Debug(msg string, fields ...Field) <span class="cov0" title="0">{
        l.log(DebugLevel, DebugLog, msg, fields)
}</span>

// Info è®°å½•ä¿¡æ¯æ—¥å¿—
func (l *VoiceHelperLogger) Info(msg string, fields ...Field) <span class="cov0" title="0">{
        l.log(InfoLevel, SystemLog, msg, fields)
}</span>

// Warn è®°å½•è­¦å‘Šæ—¥å¿—
func (l *VoiceHelperLogger) Warn(msg string, fields ...Field) <span class="cov0" title="0">{
        l.log(WarnLevel, SystemLog, msg, fields)
}</span>

// Error è®°å½•é”™è¯¯æ—¥å¿—
func (l *VoiceHelperLogger) Error(msg string, fields ...Field) <span class="cov0" title="0">{
        l.log(ErrorLevel, ErrorLog, msg, fields)
}</span>

// Fatal è®°å½•è‡´å‘½é”™è¯¯æ—¥å¿—
func (l *VoiceHelperLogger) Fatal(msg string, fields ...Field) <span class="cov0" title="0">{
        l.log(FatalLevel, ErrorLog, msg, fields)
}</span>

// Panic è®°å½•ææ…Œæ—¥å¿—
func (l *VoiceHelperLogger) Panic(msg string, fields ...Field) <span class="cov0" title="0">{
        l.log(PanicLevel, ErrorLog, msg, fields)
}</span>

// Startup è®°å½•å¯åŠ¨æ—¥å¿—
func (l *VoiceHelperLogger) Startup(msg string, fields ...Field) <span class="cov0" title="0">{
        l.log(InfoLevel, StartupLog, msg, fields)
}</span>

// Request è®°å½•è¯·æ±‚æ—¥å¿—
func (l *VoiceHelperLogger) Request(req *http.Request, fields ...Field) <span class="cov0" title="0">{
        networkInfo := getNetworkInfo(req)
        allFields := append(fields, Field{Key: "network", Value: networkInfo})

        if req.ContentLength &gt; 0 </span><span class="cov0" title="0">{
                allFields = append(allFields, Field{Key: "request_size", Value: req.ContentLength})
        }</span>

        <span class="cov0" title="0">l.log(InfoLevel, RequestLog, fmt.Sprintf("%s %s", req.Method, req.URL.Path), allFields)</span>
}

// Response è®°å½•å“åº”æ—¥å¿—
func (l *VoiceHelperLogger) Response(req *http.Request, statusCode int, duration time.Duration, fields ...Field) <span class="cov0" title="0">{
        networkInfo := getNetworkInfo(req)
        allFields := append(fields,
                Field{Key: "network", Value: networkInfo},
                Field{Key: "status_code", Value: statusCode},
                Field{Key: "duration_ms", Value: duration.Milliseconds()},
        )

        level := InfoLevel
        if statusCode &gt;= 400 </span><span class="cov0" title="0">{
                level = WarnLevel
        }</span>
        <span class="cov0" title="0">if statusCode &gt;= 500 </span><span class="cov0" title="0">{
                level = ErrorLevel
        }</span>

        <span class="cov0" title="0">l.log(level, ResponseLog, fmt.Sprintf("%s %s - %d", req.Method, req.URL.Path, statusCode), allFields)</span>
}

// ErrorWithCode è®°å½•å¸¦é”™è¯¯ç çš„é”™è¯¯æ—¥å¿—
func (l *VoiceHelperLogger) ErrorWithCode(code errors.ErrorCode, msg string, fields ...Field) <span class="cov0" title="0">{
        allFields := append(fields, Field{Key: "error_code", Value: code})
        l.log(ErrorLevel, ErrorLog, msg, allFields)
}</span>

// Performance è®°å½•æ€§èƒ½æ—¥å¿—
func (l *VoiceHelperLogger) Performance(operation string, duration time.Duration, fields ...Field) <span class="cov0" title="0">{
        allFields := append(fields, Field{Key: "duration_ms", Value: duration.Milliseconds()})
        l.log(InfoLevel, PerformanceLog, fmt.Sprintf("Performance: %s", operation), allFields)
}</span>

// Security è®°å½•å®‰å…¨æ—¥å¿—
func (l *VoiceHelperLogger) Security(event string, fields ...Field) <span class="cov0" title="0">{
        l.log(WarnLevel, SecurityLog, fmt.Sprintf("Security Event: %s", event), fields)
}</span>

// Business è®°å½•ä¸šåŠ¡æ—¥å¿—
func (l *VoiceHelperLogger) Business(event string, fields ...Field) <span class="cov0" title="0">{
        l.log(InfoLevel, BusinessLog, fmt.Sprintf("Business Event: %s", event), fields)
}</span>

// WithContext æ·»åŠ ä¸Šä¸‹æ–‡
func (l *VoiceHelperLogger) WithContext(ctx context.Context) Logger <span class="cov0" title="0">{
        newLogger := *l
        newLogger.ctx = ctx
        newLogger.fields = make(map[string]interface{})
        for k, v := range l.fields </span><span class="cov0" title="0">{
                newLogger.fields[k] = v
        }</span>

        // ä»ä¸Šä¸‹æ–‡ä¸­æå–ä¿¡æ¯
        <span class="cov0" title="0">if requestID := ctx.Value("request_id"); requestID != nil </span><span class="cov0" title="0">{
                newLogger.fields["request_id"] = requestID
        }</span>
        <span class="cov0" title="0">if userID := ctx.Value("user_id"); userID != nil </span><span class="cov0" title="0">{
                newLogger.fields["user_id"] = userID
        }</span>
        <span class="cov0" title="0">if traceID := ctx.Value("trace_id"); traceID != nil </span><span class="cov0" title="0">{
                newLogger.fields["trace_id"] = traceID
        }</span>

        <span class="cov0" title="0">return &amp;newLogger</span>
}

// WithFields æ·»åŠ å­—æ®µ
func (l *VoiceHelperLogger) WithFields(fields ...Field) Logger <span class="cov0" title="0">{
        newLogger := *l
        newLogger.fields = make(map[string]interface{})
        for k, v := range l.fields </span><span class="cov0" title="0">{
                newLogger.fields[k] = v
        }</span>

        <span class="cov0" title="0">for _, field := range fields </span><span class="cov0" title="0">{
                newLogger.fields[field.Key] = field.Value
        }</span>

        <span class="cov0" title="0">return &amp;newLogger</span>
}

// WithService è®¾ç½®æœåŠ¡å
func (l *VoiceHelperLogger) WithService(service string) Logger <span class="cov0" title="0">{
        newLogger := *l
        newLogger.service = service
        return &amp;newLogger
}</span>

// WithModule è®¾ç½®æ¨¡å—å
func (l *VoiceHelperLogger) WithModule(module string) Logger <span class="cov0" title="0">{
        newLogger := *l
        newLogger.module = module
        return &amp;newLogger
}</span>

// GinLoggerMiddleware Ginæ—¥å¿—ä¸­é—´ä»¶
func GinLoggerMiddleware(logger Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()

                // è®°å½•è¯·æ±‚æ—¥å¿—
                logger.Request(c.Request)

                // å¤„ç†è¯·æ±‚
                c.Next()

                // è®°å½•å“åº”æ—¥å¿—
                duration := time.Since(start)
                logger.Response(c.Request, c.Writer.Status(), duration)

                // å¦‚æœæœ‰é”™è¯¯ï¼Œè®°å½•é”™è¯¯æ—¥å¿—
                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        for _, err := range c.Errors </span><span class="cov0" title="0">{
                                logger.Error("Request error", Field{Key: "error", Value: err.Error()})
                        }</span>
                }
        }
}

// ä¾¿åˆ©å‡½æ•°
func F(key string, value interface{}) Field <span class="cov0" title="0">{
        return Field{Key: key, Value: value}
}</span>

// å…¨å±€æ—¥å¿—å™¨å®ä¾‹
var defaultLogger Logger

// InitDefaultLogger åˆå§‹åŒ–é»˜è®¤æ—¥å¿—å™¨
func InitDefaultLogger(service string) <span class="cov0" title="0">{
        defaultLogger = NewLogger(service)
}</span>

// GetDefaultLogger è·å–é»˜è®¤æ—¥å¿—å™¨
func GetDefaultLogger() Logger <span class="cov0" title="0">{
        if defaultLogger == nil </span><span class="cov0" title="0">{
                defaultLogger = NewLogger("voicehelper")
        }</span>
        <span class="cov0" title="0">return defaultLogger</span>
}

// å…¨å±€ä¾¿åˆ©å‡½æ•°
func Debug(msg string, fields ...Field) <span class="cov0" title="0">{
        GetDefaultLogger().Debug(msg, fields...)
}</span>

func Info(msg string, fields ...Field) <span class="cov0" title="0">{
        GetDefaultLogger().Info(msg, fields...)
}</span>

func Warn(msg string, fields ...Field) <span class="cov0" title="0">{
        GetDefaultLogger().Warn(msg, fields...)
}</span>

func Error(msg string, fields ...Field) <span class="cov0" title="0">{
        GetDefaultLogger().Error(msg, fields...)
}</span>

func Fatal(msg string, fields ...Field) <span class="cov0" title="0">{
        GetDefaultLogger().Fatal(msg, fields...)
}</span>

func Panic(msg string, fields ...Field) <span class="cov0" title="0">{
        GetDefaultLogger().Panic(msg, fields...)
}</span>

func Startup(msg string, fields ...Field) <span class="cov0" title="0">{
        GetDefaultLogger().Startup(msg, fields...)
}</span>

func ErrorWithCode(code errors.ErrorCode, msg string, fields ...Field) <span class="cov0" title="0">{
        GetDefaultLogger().ErrorWithCode(code, msg, fields...)
}</span>

func Performance(operation string, duration time.Duration, fields ...Field) <span class="cov0" title="0">{
        GetDefaultLogger().Performance(operation, duration, fields...)
}</span>

func Security(event string, fields ...Field) <span class="cov0" title="0">{
        GetDefaultLogger().Security(event, fields...)
}</span>

func Business(event string, fields ...Field) <span class="cov0" title="0">{
        GetDefaultLogger().Business(event, fields...)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "net/http"
        "strings"
        "time"

        "voicehelper/backend/pkg/discovery"
)

func main() <span class="cov0" title="0">{
        fmt.Println("ğŸ” æœåŠ¡å‘ç°åŠŸèƒ½æ¼”ç¤º")
        fmt.Println(strings.Repeat("=", 50))

        // 1. åŸºæœ¬æœåŠ¡å‘ç°æ¼”ç¤º
        demonstrateServiceDiscovery()

        // 2. æœåŠ¡æ³¨å†Œè¡¨æ¼”ç¤º
        demonstrateServiceRegistry()

        // 3. è´Ÿè½½å‡è¡¡æ¼”ç¤º
        demonstrateLoadBalancing()

        // 4. å¥åº·æ£€æŸ¥æ¼”ç¤º
        demonstrateHealthChecks()

        fmt.Println("\nâœ… æœåŠ¡å‘ç°åŠŸèƒ½æ¼”ç¤ºå®Œæˆ")
}</span>

// demonstrateServiceDiscovery æ¼”ç¤ºåŸºæœ¬æœåŠ¡å‘ç°åŠŸèƒ½
func demonstrateServiceDiscovery() <span class="cov0" title="0">{
        fmt.Println("\n1. ğŸ” æœåŠ¡å‘ç°æ¼”ç¤º")
        fmt.Println(strings.Repeat("-", 30))

        // åˆ›å»ºæœåŠ¡å‘ç°å®ä¾‹
        serviceDiscovery := discovery.NewServiceDiscovery()

        // æ¼”ç¤ºå‘ç°å…¬å¼€çš„APIæœåŠ¡
        publicAPIs := []string{
                "https://httpbin.org",
                "https://jsonplaceholder.typicode.com",
        }

        for _, apiURL := range publicAPIs </span><span class="cov0" title="0">{
                fmt.Printf("æ­£åœ¨å‘ç°æœåŠ¡: %s\n", apiURL)

                request := &amp;discovery.DiscoveryRequest{
                        URL:              apiURL,
                        Timeout:          10 * time.Second,
                        FollowRedirects:  true,
                        DiscoveryMethods: []string{"openapi", "swagger", "health", "info", "root"},
                }

                ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
                result, err := serviceDiscovery.DiscoverService(ctx, request)
                cancel()

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  âŒ å‘ç°å¤±è´¥: %v\n", err)
                        continue</span>
                }

                <span class="cov0" title="0">fmt.Printf("  âœ… å‘ç°æˆåŠŸ:\n")
                fmt.Printf("     æœåŠ¡åç§°: %s\n", result.ServiceName)
                fmt.Printf("     ç‰ˆæœ¬: %s\n", result.Version)
                fmt.Printf("     æè¿°: %s\n", result.Description)
                fmt.Printf("     èƒ½åŠ›: %v\n", result.Capabilities)
                fmt.Printf("     ç«¯ç‚¹æ•°é‡: %d\n", len(result.Endpoints))
                fmt.Printf("     çŠ¶æ€: %s\n", result.Status)

                if result.HealthCheck != nil </span><span class="cov0" title="0">{
                        fmt.Printf("     å¥åº·æ£€æŸ¥: %s %s\n", result.HealthCheck.Method, result.HealthCheck.Path)
                }</span>
        }

        // æ¼”ç¤ºç¼“å­˜åŠŸèƒ½
        <span class="cov0" title="0">fmt.Println("\nç¼“å­˜çš„æœåŠ¡:")
        cachedServices := serviceDiscovery.ListCachedServices()
        for i, serviceURL := range cachedServices </span><span class="cov0" title="0">{
                fmt.Printf("  %d. %s\n", i+1, serviceURL)
        }</span>
}

// demonstrateServiceRegistry æ¼”ç¤ºæœåŠ¡æ³¨å†Œè¡¨åŠŸèƒ½
func demonstrateServiceRegistry() <span class="cov0" title="0">{
        fmt.Println("\n2. ğŸ“‹ æœåŠ¡æ³¨å†Œè¡¨æ¼”ç¤º")
        fmt.Println(strings.Repeat("-", 30))

        // åˆ›å»ºæœåŠ¡æ³¨å†Œè¡¨
        registry := discovery.NewServiceRegistry(&amp;discovery.RegistryConfig{
                HealthCheckEnabled:  false, // æ¼”ç¤ºä¸­ç¦ç”¨è‡ªåŠ¨å¥åº·æ£€æŸ¥
                HealthCheckInterval: 30 * time.Second,
                HealthCheckTimeout:  5 * time.Second,
        })

        // æ³¨å†Œç¤ºä¾‹æœåŠ¡
        services := []*discovery.RegisteredService{
                {
                        ID:           "user-service",
                        Name:         "ç”¨æˆ·æœåŠ¡",
                        URL:          "https://jsonplaceholder.typicode.com",
                        Category:     "api",
                        Status:       discovery.StatusActive,
                        HealthStatus: discovery.HealthHealthy,
                        Weight:       100,
                        Priority:     1,
                        Tags:         []string{"users", "authentication"},
                },
                {
                        ID:           "post-service",
                        Name:         "æ–‡ç« æœåŠ¡",
                        URL:          "https://jsonplaceholder.typicode.com",
                        Category:     "api",
                        Status:       discovery.StatusActive,
                        HealthStatus: discovery.HealthHealthy,
                        Weight:       150,
                        Priority:     2,
                        Tags:         []string{"posts", "content"},
                },
                {
                        ID:           "comment-service",
                        Name:         "è¯„è®ºæœåŠ¡",
                        URL:          "https://jsonplaceholder.typicode.com",
                        Category:     "api",
                        Status:       discovery.StatusActive,
                        HealthStatus: discovery.HealthUnhealthy,
                        Weight:       80,
                        Priority:     1,
                        Tags:         []string{"comments", "social"},
                },
        }

        ctx := context.Background()
        for _, service := range services </span><span class="cov0" title="0">{
                err := registry.RegisterService(ctx, service)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  âŒ æ³¨å†ŒæœåŠ¡å¤±è´¥ %s: %v\n", service.ID, err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("  âœ… æ³¨å†ŒæœåŠ¡æˆåŠŸ: %s (%s)\n", service.Name, service.ID)
                }</span>
        }

        // åˆ—å‡ºæ‰€æœ‰æœåŠ¡
        <span class="cov0" title="0">fmt.Println("\næ³¨å†Œçš„æœåŠ¡åˆ—è¡¨:")
        allServices := registry.ListServices()
        for i, service := range allServices </span><span class="cov0" title="0">{
                fmt.Printf("  %d. %s (%s) - %s - æƒé‡:%d ä¼˜å…ˆçº§:%d\n",
                        i+1, service.Name, service.ID, service.HealthStatus, service.Weight, service.Priority)
        }</span>

        // æŒ‰ç±»åˆ«åˆ—å‡ºæœåŠ¡
        <span class="cov0" title="0">fmt.Println("\nAPIç±»åˆ«çš„æœåŠ¡:")
        apiServices := registry.ListServicesByCategory("api")
        for i, service := range apiServices </span><span class="cov0" title="0">{
                fmt.Printf("  %d. %s - %s\n", i+1, service.Name, service.HealthStatus)
        }</span>

        // åˆ—å‡ºå¥åº·çš„æœåŠ¡
        <span class="cov0" title="0">fmt.Println("\nå¥åº·çš„æœåŠ¡:")
        healthyServices := registry.ListHealthyServices()
        for i, service := range healthyServices </span><span class="cov0" title="0">{
                fmt.Printf("  %d. %s\n", i+1, service.Name)
        }</span>

        // æ›´æ–°æœåŠ¡
        <span class="cov0" title="0">fmt.Println("\næ›´æ–°æœåŠ¡æƒé‡...")
        err := registry.UpdateService("user-service", map[string]interface{}{
                "weight": 200,
                "tags":   []string{"users", "authentication", "updated"},
        })
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("  âŒ æ›´æ–°å¤±è´¥: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("  âœ… æ›´æ–°æˆåŠŸ\n")
        }</span>

        // è·å–æœåŠ¡ç»Ÿè®¡
        <span class="cov0" title="0">fmt.Println("\næœåŠ¡ç»Ÿè®¡:")
        for _, service := range allServices </span><span class="cov0" title="0">{
                // æ¨¡æ‹Ÿä¸€äº›è¯·æ±‚ç»Ÿè®¡
                registry.RecordServiceRequest(service.ID, 100*time.Millisecond, true)
                registry.RecordServiceRequest(service.ID, 150*time.Millisecond, true)
                registry.RecordServiceRequest(service.ID, 200*time.Millisecond, false)

                stats, err := registry.GetServiceStats(service.ID)
                if err == nil </span><span class="cov0" title="0">{
                        fmt.Printf("  %s: è¯·æ±‚æ•°=%v, é”™è¯¯æ•°=%v, å¹³å‡å»¶è¿Ÿ=%v\n",
                                service.Name, stats["request_count"], stats["error_count"], stats["average_latency"])
                }</span>
        }
}

// demonstrateLoadBalancing æ¼”ç¤ºè´Ÿè½½å‡è¡¡åŠŸèƒ½
func demonstrateLoadBalancing() <span class="cov0" title="0">{
        fmt.Println("\n3. âš–ï¸ è´Ÿè½½å‡è¡¡æ¼”ç¤º")
        fmt.Println(strings.Repeat("-", 30))

        // åˆ›å»ºæœåŠ¡æ³¨å†Œè¡¨å’Œè´Ÿè½½å‡è¡¡å™¨
        registry := discovery.NewServiceRegistry(nil)
        loadBalancer := discovery.NewLoadBalancer(registry, &amp;discovery.LoadBalancerConfig{
                Strategy:             discovery.StrategyHealthyFirst,
                FailureThreshold:     3,
                RecoveryTimeout:      10 * time.Second,
                EnableCircuitBreaker: true,
        })

        // æ³¨å†Œæµ‹è¯•æœåŠ¡
        testServices := []*discovery.RegisteredService{
                {
                        ID:           "service-a",
                        Name:         "æœåŠ¡A",
                        URL:          "http://service-a:8080",
                        Category:     "api",
                        Status:       discovery.StatusActive,
                        HealthStatus: discovery.HealthHealthy,
                        Weight:       100,
                        Priority:     1,
                },
                {
                        ID:           "service-b",
                        Name:         "æœåŠ¡B",
                        URL:          "http://service-b:8080",
                        Category:     "api",
                        Status:       discovery.StatusActive,
                        HealthStatus: discovery.HealthHealthy,
                        Weight:       200,
                        Priority:     2,
                },
                {
                        ID:           "service-c",
                        Name:         "æœåŠ¡C",
                        URL:          "http://service-c:8080",
                        Category:     "api",
                        Status:       discovery.StatusActive,
                        HealthStatus: discovery.HealthUnhealthy,
                        Weight:       150,
                        Priority:     1,
                },
        }

        ctx := context.Background()
        for _, service := range testServices </span><span class="cov0" title="0">{
                registry.RegisterService(ctx, service)
        }</span>

        // æ¼”ç¤ºä¸åŒçš„è´Ÿè½½å‡è¡¡ç­–ç•¥
        <span class="cov0" title="0">strategies := []discovery.LoadBalancingStrategy{
                discovery.StrategyHealthyFirst,
                discovery.StrategyWeightedRandom,
                discovery.StrategyPriority,
        }

        for _, strategy := range strategies </span><span class="cov0" title="0">{
                fmt.Printf("\nä½¿ç”¨ç­–ç•¥: %s\n", strategy)

                // ä¸´æ—¶æ›´æ”¹ç­–ç•¥ï¼ˆåœ¨å®é™…åº”ç”¨ä¸­åº”è¯¥é‡æ–°åˆ›å»ºè´Ÿè½½å‡è¡¡å™¨ï¼‰
                selections := make(map[string]int)

                // è¿›è¡Œå¤šæ¬¡é€‰æ‹©ä»¥è§‚å¯Ÿåˆ†å¸ƒ
                for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                        selection, err := loadBalancer.SelectService("api", nil)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("  âŒ é€‰æ‹©å¤±è´¥: %v\n", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">selections[selection.Service.Name]++</span>
                }

                <span class="cov0" title="0">fmt.Println("  é€‰æ‹©åˆ†å¸ƒ:")
                for serviceName, count := range selections </span><span class="cov0" title="0">{
                        fmt.Printf("    %s: %dæ¬¡\n", serviceName, count)
                }</span>
        }

        // æ¼”ç¤ºç†”æ–­å™¨åŠŸèƒ½
        <span class="cov0" title="0">fmt.Println("\nç†”æ–­å™¨æ¼”ç¤º:")

        // æ¨¡æ‹ŸæœåŠ¡Aè¿ç»­å¤±è´¥
        fmt.Println("  æ¨¡æ‹ŸæœåŠ¡Aè¿ç»­å¤±è´¥...")
        for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                loadBalancer.RecordFailure("service-a")
        }</span>

        // æ£€æŸ¥ç†”æ–­å™¨çŠ¶æ€
        <span class="cov0" title="0">circuitStatus := loadBalancer.GetCircuitBreakerStatus()
        fmt.Printf("  ç†”æ–­å™¨çŠ¶æ€: %v\n", circuitStatus)

        // å°è¯•é€‰æ‹©æœåŠ¡ï¼ˆåº”è¯¥é¿å¼€æœåŠ¡Aï¼‰
        fmt.Println("  ç†”æ–­å™¨æ‰“å¼€åçš„æœåŠ¡é€‰æ‹©:")
        for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                selection, err := loadBalancer.SelectService("api", nil)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("    âŒ é€‰æ‹©å¤±è´¥: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("    é€‰æ‹©äº†: %s (%s)\n", selection.Service.Name, selection.Reason)
                }</span>
        }

        // é‡ç½®ç†”æ–­å™¨
        <span class="cov0" title="0">fmt.Println("  é‡ç½®æœåŠ¡Açš„ç†”æ–­å™¨...")
        loadBalancer.ResetCircuitBreaker("service-a")

        // å†æ¬¡æ£€æŸ¥çŠ¶æ€
        circuitStatus = loadBalancer.GetCircuitBreakerStatus()
        fmt.Printf("  é‡ç½®åç†”æ–­å™¨çŠ¶æ€: %v\n", circuitStatus)

        // æ¼”ç¤ºå¤šæœåŠ¡é€‰æ‹©
        fmt.Println("\nå¤šæœåŠ¡é€‰æ‹©æ¼”ç¤ºï¼ˆç”¨äºå†—ä½™ï¼‰:")
        selections, err := loadBalancer.SelectMultipleServices("api", 2, nil)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("  âŒ å¤šæœåŠ¡é€‰æ‹©å¤±è´¥: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("  é€‰æ‹©äº†%dä¸ªæœåŠ¡:\n", len(selections))
                for i, selection := range selections </span><span class="cov0" title="0">{
                        fmt.Printf("    %d. %s (%s)\n", i+1, selection.Service.Name, selection.Reason)
                }</span>
        }
}

// demonstrateHealthChecks æ¼”ç¤ºå¥åº·æ£€æŸ¥åŠŸèƒ½
func demonstrateHealthChecks() <span class="cov0" title="0">{
        fmt.Println("\n4. ğŸ¥ å¥åº·æ£€æŸ¥æ¼”ç¤º")
        fmt.Println(strings.Repeat("-", 30))

        // åˆ›å»ºä¸€ä¸ªå¯ç”¨å¥åº·æ£€æŸ¥çš„æ³¨å†Œè¡¨
        registry := discovery.NewServiceRegistry(&amp;discovery.RegistryConfig{
                HealthCheckEnabled:  true,
                HealthCheckInterval: 5 * time.Second,
                HealthCheckTimeout:  3 * time.Second,
        })

        // æ³¨å†Œä¸€ä¸ªçœŸå®çš„å¯è®¿é—®æœåŠ¡
        healthyService := &amp;discovery.RegisteredService{
                ID:           "httpbin-service",
                Name:         "HTTPBinæœåŠ¡",
                URL:          "https://httpbin.org",
                Category:     "api",
                Status:       discovery.StatusActive,
                HealthStatus: discovery.HealthUnknown,
        }

        ctx := context.Background()
        err := registry.RegisterService(ctx, healthyService)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("  âŒ æ³¨å†ŒæœåŠ¡å¤±è´¥: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("  âœ… æ³¨å†ŒæœåŠ¡: %s\n", healthyService.Name)

        // æ‰‹åŠ¨æ‰§è¡Œå¥åº·æ£€æŸ¥
        fmt.Println("\næ‰§è¡Œæ‰‹åŠ¨å¥åº·æ£€æŸ¥...")
        health, err := registry.CheckServiceHealth(ctx, "httpbin-service")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("  âŒ å¥åº·æ£€æŸ¥å¤±è´¥: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("  å¥åº·çŠ¶æ€: %s\n", health)
        }</span>

        // ç­‰å¾…è‡ªåŠ¨å¥åº·æ£€æŸ¥è¿è¡Œ
        <span class="cov0" title="0">fmt.Println("\nç­‰å¾…è‡ªåŠ¨å¥åº·æ£€æŸ¥è¿è¡Œ...")
        time.Sleep(6 * time.Second)

        // æ£€æŸ¥å¥åº·æœåŠ¡åˆ—è¡¨
        healthyServices := registry.ListHealthyServices()
        fmt.Printf("  å¥åº·æœåŠ¡æ•°é‡: %d\n", len(healthyServices))
        for _, service := range healthyServices </span><span class="cov0" title="0">{
                fmt.Printf("    - %s: %s (æœ€åæ£€æŸ¥: %v)\n",
                        service.Name, service.HealthStatus, service.LastHealthCheck.Format("15:04:05"))
        }</span>

        // è·å–æœåŠ¡ç»Ÿè®¡
        <span class="cov0" title="0">stats, err := registry.GetServiceStats("httpbin-service")
        if err == nil </span><span class="cov0" title="0">{
                fmt.Println("\næœåŠ¡ç»Ÿè®¡:")
                statsJSON, _ := json.MarshalIndent(stats, "    ", "  ")
                fmt.Printf("    %s\n", string(statsJSON))
        }</span>
}

// åˆ›å»ºä¸€ä¸ªç®€å•çš„HTTPæœåŠ¡å™¨ç”¨äºæµ‹è¯•
func startTestServer(port int, healthy bool) <span class="cov0" title="0">{
        mux := http.NewServeMux()

        mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if healthy </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusOK)
                        json.NewEncoder(w).Encode(map[string]string{"status": "healthy"})
                }</span> else<span class="cov0" title="0"> {
                        w.WriteHeader(http.StatusInternalServerError)
                        json.NewEncoder(w).Encode(map[string]string{"status": "unhealthy"})
                }</span>
        })

        <span class="cov0" title="0">mux.HandleFunc("/info", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "name":        fmt.Sprintf("Test Service %d", port),
                        "version":     "1.0.0",
                        "description": "Test service for discovery demo",
                        "port":        port,
                })
        }</span>)

        <span class="cov0" title="0">mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                fmt.Fprintf(w, "Test Service %d is running", port)
        }</span>)

        <span class="cov0" title="0">server := &amp;http.Server{
                Addr:    fmt.Sprintf(":%d", port),
                Handler: mux,
        }

        go func() </span><span class="cov0" title="0">{
                log.Printf("Test server starting on port %d (healthy: %v)", port, healthy)
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Printf("Test server error: %v", err)
                }</span>
        }()
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package middleware

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"
        "voicehelper/backend/pkg/security"

        "github.com/gin-gonic/gin"
        "github.com/sirupsen/logrus"
)

// ZeroTrustMiddleware implements zero trust security middleware
type ZeroTrustMiddleware struct {
        engine            *security.ZeroTrustEngine
        complianceManager *security.ComplianceManager
        logger            *logrus.Logger
        config            *ZeroTrustConfig
}

// ZeroTrustConfig contains configuration for zero trust middleware
type ZeroTrustConfig struct {
        EnableRiskAssessment bool     `json:"enable_risk_assessment"`
        EnableCompliance     bool     `json:"enable_compliance"`
        ExemptPaths          []string `json:"exempt_paths"`
        RequiredClaims       []string `json:"required_claims"`
        MaxRiskScore         float64  `json:"max_risk_score"`
        ChallengeEndpoint    string   `json:"challenge_endpoint"`
}

// NewZeroTrustMiddleware creates a new zero trust middleware
func NewZeroTrustMiddleware() *ZeroTrustMiddleware <span class="cov0" title="0">{
        config := &amp;ZeroTrustConfig{
                EnableRiskAssessment: true,
                EnableCompliance:     true,
                ExemptPaths: []string{
                        "/health",
                        "/metrics",
                        "/api/v1/auth/login",
                        "/api/v1/auth/wechat/login",
                },
                RequiredClaims:    []string{"user_id", "roles"},
                MaxRiskScore:      0.7,
                ChallengeEndpoint: "/api/v1/auth/challenge",
        }

        return &amp;ZeroTrustMiddleware{
                engine:            security.NewZeroTrustEngine(),
                complianceManager: security.NewComplianceManager(),
                logger:            logrus.New(),
                config:            config,
        }
}</span>

// Middleware returns the Gin middleware function
func (ztm *ZeroTrustMiddleware) Middleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Check if path is exempt
                if ztm.isExemptPath(c.Request.URL.Path) </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Create access request
                <span class="cov0" title="0">accessRequest := ztm.createAccessRequest(c)

                // Evaluate access using zero trust engine
                decision, err := ztm.engine.EvaluateAccess(c.Request.Context(), accessRequest)
                if err != nil </span><span class="cov0" title="0">{
                        ztm.logger.Errorf("Failed to evaluate access: %v", err)
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error": "Access evaluation failed",
                        })
                        c.Abort()
                        return
                }</span>

                // Handle access decision
                <span class="cov0" title="0">switch decision.Action </span>{
                case security.ActionAllow:<span class="cov0" title="0">
                        ztm.handleAllow(c, decision)</span>
                case security.ActionDeny:<span class="cov0" title="0">
                        ztm.handleDeny(c, decision)</span>
                case security.ActionChallenge:<span class="cov0" title="0">
                        ztm.handleChallenge(c, decision)</span>
                case security.ActionLog:<span class="cov0" title="0">
                        ztm.handleLog(c, decision)</span>
                case security.ActionAlert:<span class="cov0" title="0">
                        ztm.handleAlert(c, decision)</span>
                default:<span class="cov0" title="0">
                        ztm.handleDeny(c, decision)</span>
                }

                // Check compliance if enabled
                <span class="cov0" title="0">if ztm.config.EnableCompliance &amp;&amp; decision.Allowed </span><span class="cov0" title="0">{
                        violations, err := ztm.complianceManager.CheckCompliance(accessRequest)
                        if err != nil </span><span class="cov0" title="0">{
                                ztm.logger.Errorf("Failed to check compliance: %v", err)
                        }</span> else<span class="cov0" title="0"> if len(violations) &gt; 0 </span><span class="cov0" title="0">{
                                ztm.handleComplianceViolations(c, violations)
                        }</span>
                }

                <span class="cov0" title="0">if decision.Allowed </span><span class="cov0" title="0">{
                        // Add security headers
                        ztm.addSecurityHeaders(c, decision)
                        c.Next()
                }</span>
        }
}

// createAccessRequest creates an access request from the Gin context
func (ztm *ZeroTrustMiddleware) createAccessRequest(c *gin.Context) *security.AccessRequest <span class="cov0" title="0">{
        // Extract user information from JWT token or session
        userID := ztm.extractUserID(c)
        claims := ztm.extractClaims(c)

        // Extract location information (simplified)
        location := ztm.extractLocation(c)

        // Create request context
        requestContext := security.RequestContext{
                IPAddress: ztm.getClientIP(c),
                UserAgent: c.GetHeader("User-Agent"),
                DeviceID:  c.GetHeader("X-Device-ID"),
                Location:  location,
                SessionID: ztm.extractSessionID(c),
                RequestID: ztm.generateRequestID(),
                Headers:   ztm.extractHeaders(c),
        }

        return &amp;security.AccessRequest{
                UserID:    userID,
                Resource:  c.Request.URL.Path,
                Action:    c.Request.Method,
                Context:   requestContext,
                Claims:    claims,
                Timestamp: time.Now(),
        }
}</span>

// Handle different access decisions

func (ztm *ZeroTrustMiddleware) handleAllow(c *gin.Context, decision *security.AccessDecision) <span class="cov0" title="0">{
        ztm.logger.Debugf("Access allowed for user %s to %s",
                ztm.extractUserID(c), c.Request.URL.Path)

        // Set session token if provided
        if decision.SessionToken != "" </span><span class="cov0" title="0">{
                c.Header("X-Session-Token", decision.SessionToken)
        }</span>
}

func (ztm *ZeroTrustMiddleware) handleDeny(c *gin.Context, decision *security.AccessDecision) <span class="cov0" title="0">{
        ztm.logger.Warnf("Access denied for user %s to %s: %s",
                ztm.extractUserID(c), c.Request.URL.Path, decision.Reason)

        c.JSON(http.StatusForbidden, gin.H{
                "error":     "Access denied",
                "reason":    decision.Reason,
                "policy_id": decision.PolicyID,
                "rule_id":   decision.RuleID,
        })
        c.Abort()
}</span>

func (ztm *ZeroTrustMiddleware) handleChallenge(c *gin.Context, decision *security.AccessDecision) <span class="cov0" title="0">{
        ztm.logger.Infof("Access challenge required for user %s to %s: %s",
                ztm.extractUserID(c), c.Request.URL.Path, decision.Reason)

        c.JSON(http.StatusUnauthorized, gin.H{
                "error":  "Additional verification required",
                "reason": decision.Reason,
                "challenge": map[string]interface{}{
                        "type":     "mfa",
                        "endpoint": ztm.config.ChallengeEndpoint,
                        "token":    decision.SessionToken,
                },
        })
        c.Abort()
}</span>

func (ztm *ZeroTrustMiddleware) handleLog(c *gin.Context, decision *security.AccessDecision) <span class="cov0" title="0">{
        ztm.logger.Infof("Access logged for user %s to %s: %s",
                ztm.extractUserID(c), c.Request.URL.Path, decision.Reason)

        // Continue processing the request
}</span>

func (ztm *ZeroTrustMiddleware) handleAlert(c *gin.Context, decision *security.AccessDecision) <span class="cov0" title="0">{
        ztm.logger.Warnf("Security alert for user %s to %s: %s",
                ztm.extractUserID(c), c.Request.URL.Path, decision.Reason)

        // Send alert to security team (implementation depends on alerting system)
        ztm.sendSecurityAlert(decision)

        // Continue processing the request
}</span>

func (ztm *ZeroTrustMiddleware) handleComplianceViolations(c *gin.Context, violations []*security.ComplianceViolation) <span class="cov0" title="0">{
        ztm.logger.Warnf("Compliance violations detected: %d violations", len(violations))

        // For high severity violations, deny access
        for _, violation := range violations </span><span class="cov0" title="0">{
                if violation.Severity == security.ViolationSeverityCritical ||
                        violation.Severity == security.ViolationSeverityHigh </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{
                                "error":     "Compliance violation",
                                "violation": violation.Title,
                                "standard":  violation.StandardID,
                                "severity":  violation.Severity,
                        })
                        c.Abort()
                        return
                }</span>
        }

        // For lower severity violations, add warning headers
        <span class="cov0" title="0">c.Header("X-Compliance-Warning", "true")
        c.Header("X-Compliance-Violations", fmt.Sprintf("%d", len(violations)))</span>
}

// Helper methods

func (ztm *ZeroTrustMiddleware) isExemptPath(path string) bool <span class="cov0" title="0">{
        for _, exemptPath := range ztm.config.ExemptPaths </span><span class="cov0" title="0">{
                if strings.HasPrefix(path, exemptPath) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (ztm *ZeroTrustMiddleware) extractUserID(c *gin.Context) string <span class="cov0" title="0">{
        // Try to get user ID from JWT token
        if userID, exists := c.Get("user_id"); exists </span><span class="cov0" title="0">{
                if userIDStr, ok := userID.(string); ok </span><span class="cov0" title="0">{
                        return userIDStr
                }</span>
        }

        // Try to get from header
        <span class="cov0" title="0">if userID := c.GetHeader("X-User-ID"); userID != "" </span><span class="cov0" title="0">{
                return userID
        }</span>

        <span class="cov0" title="0">return ""</span>
}

func (ztm *ZeroTrustMiddleware) extractClaims(c *gin.Context) map[string]interface{} <span class="cov0" title="0">{
        claims := make(map[string]interface{})

        // Try to get claims from JWT token
        if claimsValue, exists := c.Get("claims"); exists </span><span class="cov0" title="0">{
                if claimsMap, ok := claimsValue.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        return claimsMap
                }</span>
        }

        // Extract from headers (simplified)
        <span class="cov0" title="0">if roles := c.GetHeader("X-User-Roles"); roles != "" </span><span class="cov0" title="0">{
                var roleList []string
                if err := json.Unmarshal([]byte(roles), &amp;roleList); err == nil </span><span class="cov0" title="0">{
                        claims["roles"] = roleList
                }</span>
        }

        <span class="cov0" title="0">if permissions := c.GetHeader("X-User-Permissions"); permissions != "" </span><span class="cov0" title="0">{
                var permList []string
                if err := json.Unmarshal([]byte(permissions), &amp;permList); err == nil </span><span class="cov0" title="0">{
                        claims["permissions"] = permList
                }</span>
        }

        // Check for MFA
        <span class="cov0" title="0">if mfa := c.GetHeader("X-MFA-Verified"); mfa == "true" </span><span class="cov0" title="0">{
                claims["mfa"] = true
        }</span>

        // Check for consent
        <span class="cov0" title="0">if consent := c.GetHeader("X-User-Consent"); consent != "" </span><span class="cov0" title="0">{
                claims["consent"] = map[string]interface{}{
                        "valid": consent == "true",
                }
        }</span>

        <span class="cov0" title="0">return claims</span>
}

func (ztm *ZeroTrustMiddleware) extractLocation(c *gin.Context) *security.Location <span class="cov0" title="0">{
        // Try to get location from headers (set by a geolocation service)
        country := c.GetHeader("X-Country")
        region := c.GetHeader("X-Region")
        city := c.GetHeader("X-City")

        if country == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">location := &amp;security.Location{
                Country: country,
                Region:  region,
                City:    city,
        }

        // Try to parse coordinates
        if lat := c.GetHeader("X-Latitude"); lat != "" </span><span class="cov0" title="0">{
                if lon := c.GetHeader("X-Longitude"); lon != "" </span><span class="cov0" title="0">{
                        // Parse coordinates (simplified)
                        location.Latitude = 0.0  // Would parse from lat string
                        location.Longitude = 0.0 // Would parse from lon string
                }</span>
        }

        <span class="cov0" title="0">return location</span>
}

func (ztm *ZeroTrustMiddleware) extractSessionID(c *gin.Context) string <span class="cov0" title="0">{
        // Try to get session ID from various sources
        if sessionID := c.GetHeader("X-Session-ID"); sessionID != "" </span><span class="cov0" title="0">{
                return sessionID
        }</span>

        <span class="cov0" title="0">if cookie, err := c.Cookie("session_id"); err == nil </span><span class="cov0" title="0">{
                return cookie
        }</span>

        <span class="cov0" title="0">return ""</span>
}

func (ztm *ZeroTrustMiddleware) getClientIP(c *gin.Context) string <span class="cov0" title="0">{
        // Check X-Forwarded-For header
        if xff := c.GetHeader("X-Forwarded-For"); xff != "" </span><span class="cov0" title="0">{
                ips := strings.Split(xff, ",")
                if len(ips) &gt; 0 </span><span class="cov0" title="0">{
                        return strings.TrimSpace(ips[0])
                }</span>
        }

        // Check X-Real-IP header
        <span class="cov0" title="0">if xri := c.GetHeader("X-Real-IP"); xri != "" </span><span class="cov0" title="0">{
                return xri
        }</span>

        // Fall back to RemoteAddr
        <span class="cov0" title="0">return c.ClientIP()</span>
}

func (ztm *ZeroTrustMiddleware) extractHeaders(c *gin.Context) map[string]string <span class="cov0" title="0">{
        headers := make(map[string]string)

        // Extract relevant headers
        relevantHeaders := []string{
                "User-Agent",
                "Accept",
                "Accept-Language",
                "Accept-Encoding",
                "Referer",
                "X-Forwarded-Proto",
                "X-Device-ID",
                "X-App-Version",
        }

        for _, header := range relevantHeaders </span><span class="cov0" title="0">{
                if value := c.GetHeader(header); value != "" </span><span class="cov0" title="0">{
                        headers[strings.ToLower(header)] = value
                }</span>
        }

        <span class="cov0" title="0">return headers</span>
}

func (ztm *ZeroTrustMiddleware) generateRequestID() string <span class="cov0" title="0">{
        return "req_" + time.Now().Format("20060102150405") + "_" +
                fmt.Sprintf("%d", time.Now().UnixNano()%1000000)
}</span>

func (ztm *ZeroTrustMiddleware) addSecurityHeaders(c *gin.Context, decision *security.AccessDecision) <span class="cov0" title="0">{
        // Add security headers
        c.Header("X-Content-Type-Options", "nosniff")
        c.Header("X-Frame-Options", "DENY")
        c.Header("X-XSS-Protection", "1; mode=block")
        c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
        c.Header("Referrer-Policy", "strict-origin-when-cross-origin")

        // Add zero trust specific headers
        c.Header("X-ZT-Policy-ID", decision.PolicyID)
        c.Header("X-ZT-Risk-Score", fmt.Sprintf("%.3f", decision.Confidence))
        c.Header("X-ZT-Decision-Time", decision.Timestamp.Format(time.RFC3339))
}</span>

func (ztm *ZeroTrustMiddleware) sendSecurityAlert(decision *security.AccessDecision) <span class="cov0" title="0">{
        // Implementation would depend on the alerting system
        // Could send to Slack, email, PagerDuty, etc.
        ztm.logger.Warnf("Security alert: %s (Policy: %s, Rule: %s)",
                decision.Reason, decision.PolicyID, decision.RuleID)
}</span>

// Policy management methods

// AddPolicy adds a new zero trust policy
func (ztm *ZeroTrustMiddleware) AddPolicy(policy *security.ZeroTrustPolicy) error <span class="cov0" title="0">{
        return ztm.engine.AddPolicy(policy)
}</span>

// GetPolicies returns all zero trust policies
func (ztm *ZeroTrustMiddleware) GetPolicies() map[string]*security.ZeroTrustPolicy <span class="cov0" title="0">{
        return ztm.engine.GetPolicies()
}</span>

// UpdatePolicy updates an existing policy
func (ztm *ZeroTrustMiddleware) UpdatePolicy(policyID string, updates map[string]interface{}) error <span class="cov0" title="0">{
        return ztm.engine.UpdatePolicy(policyID, updates)
}</span>

// DeletePolicy removes a policy
func (ztm *ZeroTrustMiddleware) DeletePolicy(policyID string) error <span class="cov0" title="0">{
        return ztm.engine.DeletePolicy(policyID)
}</span>

// GetComplianceStatus returns compliance status
func (ztm *ZeroTrustMiddleware) GetComplianceStatus() map[string]security.ComplianceStatus <span class="cov0" title="0">{
        return ztm.complianceManager.GetComplianceStatus()
}</span>

// GetViolations returns current compliance violations
func (ztm *ZeroTrustMiddleware) GetViolations() []*security.ComplianceViolation <span class="cov0" title="0">{
        return ztm.complianceManager.GetViolations()
}</span>

// ResolveViolation marks a violation as resolved
func (ztm *ZeroTrustMiddleware) ResolveViolation(violationID, resolution string) error <span class="cov0" title="0">{
        return ztm.complianceManager.ResolveViolation(violationID, resolution)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package repository

import (
        "context"
        "crypto/rand"
        "crypto/sha256"
        "database/sql"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "strings"
        "time"
        "voicehelper/backend/pkg/ratelimit"

        "github.com/google/uuid"
        "github.com/sirupsen/logrus"
        "golang.org/x/crypto/bcrypt"
)

// APIKey APIå¯†é’¥æ¨¡å‹
type APIKey struct {
        ID          string                 `json:"id"`
        TenantID    string                 `json:"tenant_id"`
        Name        string                 `json:"name"`
        Key         string                 `json:"key"`         // API Keyï¼ˆå‰ç¼€ï¼‰
        SecretHash  string                 `json:"-"`           // Secretçš„å“ˆå¸Œå€¼
        Status      string                 `json:"status"`      // active, inactive, expired, revoked
        Permissions []string               `json:"permissions"` // æƒé™åˆ—è¡¨
        RateLimit   int                    `json:"rate_limit"`  // é€Ÿç‡é™åˆ¶ï¼ˆè¯·æ±‚/å°æ—¶ï¼‰
        Metadata    map[string]interface{} `json:"metadata"`
        ExpiresAt   *time.Time             `json:"expires_at"`
        LastUsedAt  *time.Time             `json:"last_used_at"`
        CreatedAt   time.Time              `json:"created_at"`
        UpdatedAt   time.Time              `json:"updated_at"`
}

// APIKeyCreateRequest åˆ›å»ºAPI Keyè¯·æ±‚
type APIKeyCreateRequest struct {
        Name        string                 `json:"name"`
        Permissions []string               `json:"permissions"`
        RateLimit   int                    `json:"rate_limit"`
        ExpiresIn   int                    `json:"expires_in"` // è¿‡æœŸæ—¶é—´ï¼ˆå¤©ï¼‰
        Metadata    map[string]interface{} `json:"metadata"`
}

// APIKeyCreateResponse åˆ›å»ºAPI Keyå“åº”
type APIKeyCreateResponse struct {
        ID        string     `json:"id"`
        Key       string     `json:"key"`
        Secret    string     `json:"secret"` // ä»…åœ¨åˆ›å»ºæ—¶è¿”å›ä¸€æ¬¡
        ExpiresAt *time.Time `json:"expires_at"`
}

// APIKeyRepository APIå¯†é’¥ä»“åº“æ¥å£
type APIKeyRepository interface {
        Create(ctx context.Context, tenantID string, req *APIKeyCreateRequest) (*APIKeyCreateResponse, error)
        Validate(ctx context.Context, apiKey string) (*APIKey, error)
        ValidateWithSecret(ctx context.Context, apiKey, secret string) (*APIKey, error)
        Get(ctx context.Context, id string) (*APIKey, error)
        List(ctx context.Context, tenantID string, opts ListOptions) ([]*APIKey, int, error)
        Update(ctx context.Context, key *APIKey) error
        Revoke(ctx context.Context, id string) error
        UpdateLastUsed(ctx context.Context, id string) error
        CheckRateLimit(ctx context.Context, id string) (bool, error)
}

// PostgresAPIKeyRepository PostgreSQLå®ç°
type PostgresAPIKeyRepository struct {
        db          *sql.DB
        rateLimiter *ratelimit.RateLimiter
}

// NewPostgresAPIKeyRepository åˆ›å»ºPostgreSQL APIå¯†é’¥ä»“åº“
func NewPostgresAPIKeyRepository(db *sql.DB) APIKeyRepository <span class="cov0" title="0">{
        return &amp;PostgresAPIKeyRepository{db: db}
}</span>

// NewPostgresAPIKeyRepositoryWithRateLimit åˆ›å»ºå¸¦é€Ÿç‡é™åˆ¶çš„PostgreSQL APIå¯†é’¥ä»“åº“
func NewPostgresAPIKeyRepositoryWithRateLimit(db *sql.DB, rateLimiter *ratelimit.RateLimiter) APIKeyRepository <span class="cov0" title="0">{
        return &amp;PostgresAPIKeyRepository{
                db:          db,
                rateLimiter: rateLimiter,
        }
}</span>

// Create åˆ›å»ºAPIå¯†é’¥
func (r *PostgresAPIKeyRepository) Create(ctx context.Context, tenantID string, req *APIKeyCreateRequest) (*APIKeyCreateResponse, error) <span class="cov0" title="0">{
        // ç”ŸæˆAPI Keyå’ŒSecret
        apiKey, secret, err := generateAPIKeyPair()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate API key: %w", err)
        }</span>

        // å“ˆå¸ŒSecret
        <span class="cov0" title="0">secretHash, err := hashSecret(secret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to hash secret: %w", err)
        }</span>

        // è®¡ç®—è¿‡æœŸæ—¶é—´
        <span class="cov0" title="0">var expiresAt *time.Time
        if req.ExpiresIn &gt; 0 </span><span class="cov0" title="0">{
                exp := time.Now().AddDate(0, 0, req.ExpiresIn)
                expiresAt = &amp;exp
        }</span>

        // åºåˆ—åŒ–æƒé™å’Œå…ƒæ•°æ®
        <span class="cov0" title="0">permissionsJSON, _ := json.Marshal(req.Permissions)
        metadataJSON, _ := json.Marshal(req.Metadata)

        // è®¾ç½®é»˜è®¤å€¼
        if req.RateLimit == 0 </span><span class="cov0" title="0">{
                req.RateLimit = 1000 // é»˜è®¤1000è¯·æ±‚/å°æ—¶
        }</span>

        // åˆ›å»ºè®°å½•
        <span class="cov0" title="0">id := uuid.New().String()
        query := `
                INSERT INTO api_keys (
                        id, tenant_id, name, key, secret_hash, status,
                        permissions, rate_limit, metadata, expires_at,
                        created_at, updated_at
                ) VALUES (
                        $1, $2, $3, $4, $5, 'active', $6, $7, $8, $9, NOW(), NOW()
                )
        `

        _, err = r.db.ExecContext(ctx, query,
                id, tenantID, req.Name, apiKey, secretHash,
                permissionsJSON, req.RateLimit, metadataJSON, expiresAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create API key: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;APIKeyCreateResponse{
                ID:        id,
                Key:       apiKey,
                Secret:    secret,
                ExpiresAt: expiresAt,
        }, nil</span>
}

// Validate éªŒè¯APIå¯†é’¥ï¼ˆä»…Keyï¼‰
func (r *PostgresAPIKeyRepository) Validate(ctx context.Context, apiKey string) (*APIKey, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, tenant_id, name, key, secret_hash, status,
                        permissions, rate_limit, metadata, expires_at,
                        last_used_at, created_at, updated_at
                FROM api_keys
                WHERE key = $1 AND deleted_at IS NULL
        `

        key := &amp;APIKey{}
        var permissionsJSON, metadataJSON []byte
        var expiresAt, lastUsedAt sql.NullTime

        err := r.db.QueryRowContext(ctx, query, apiKey).Scan(
                &amp;key.ID, &amp;key.TenantID, &amp;key.Name, &amp;key.Key, &amp;key.SecretHash,
                &amp;key.Status, &amp;permissionsJSON, &amp;key.RateLimit, &amp;metadataJSON,
                &amp;expiresAt, &amp;lastUsedAt, &amp;key.CreatedAt, &amp;key.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid API key")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to validate API key: %w", err)
        }</span>

        // è§£æJSONå­—æ®µ
        <span class="cov0" title="0">json.Unmarshal(permissionsJSON, &amp;key.Permissions)
        json.Unmarshal(metadataJSON, &amp;key.Metadata)

        if expiresAt.Valid </span><span class="cov0" title="0">{
                key.ExpiresAt = &amp;expiresAt.Time
        }</span>
        <span class="cov0" title="0">if lastUsedAt.Valid </span><span class="cov0" title="0">{
                key.LastUsedAt = &amp;lastUsedAt.Time
        }</span>

        // æ£€æŸ¥çŠ¶æ€
        <span class="cov0" title="0">if key.Status != "active" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API key is %s", key.Status)
        }</span>

        // æ£€æŸ¥è¿‡æœŸ
        <span class="cov0" title="0">if key.ExpiresAt != nil &amp;&amp; key.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                // æ›´æ–°çŠ¶æ€ä¸ºè¿‡æœŸ
                r.updateStatus(ctx, key.ID, "expired")
                return nil, fmt.Errorf("API key has expired")
        }</span>

        // æ›´æ–°æœ€åä½¿ç”¨æ—¶é—´ï¼ˆå¼‚æ­¥ï¼‰
        <span class="cov0" title="0">go r.UpdateLastUsed(context.Background(), key.ID)

        return key, nil</span>
}

// ValidateWithSecret éªŒè¯APIå¯†é’¥ï¼ˆKey + Secretï¼‰
func (r *PostgresAPIKeyRepository) ValidateWithSecret(ctx context.Context, apiKey, secret string) (*APIKey, error) <span class="cov0" title="0">{
        // å…ˆéªŒè¯Key
        key, err := r.Validate(ctx, apiKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // éªŒè¯Secret
        <span class="cov0" title="0">if !verifySecret(secret, key.SecretHash) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid API secret")
        }</span>

        <span class="cov0" title="0">return key, nil</span>
}

// Get è·å–APIå¯†é’¥è¯¦æƒ…
func (r *PostgresAPIKeyRepository) Get(ctx context.Context, id string) (*APIKey, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, tenant_id, name, key, status,
                        permissions, rate_limit, metadata, expires_at,
                        last_used_at, created_at, updated_at
                FROM api_keys
                WHERE id = $1 AND deleted_at IS NULL
        `

        key := &amp;APIKey{}
        var permissionsJSON, metadataJSON []byte
        var expiresAt, lastUsedAt sql.NullTime

        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;key.ID, &amp;key.TenantID, &amp;key.Name, &amp;key.Key,
                &amp;key.Status, &amp;permissionsJSON, &amp;key.RateLimit, &amp;metadataJSON,
                &amp;expiresAt, &amp;lastUsedAt, &amp;key.CreatedAt, &amp;key.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API key not found")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get API key: %w", err)
        }</span>

        // è§£æJSONå­—æ®µ
        <span class="cov0" title="0">json.Unmarshal(permissionsJSON, &amp;key.Permissions)
        json.Unmarshal(metadataJSON, &amp;key.Metadata)

        if expiresAt.Valid </span><span class="cov0" title="0">{
                key.ExpiresAt = &amp;expiresAt.Time
        }</span>
        <span class="cov0" title="0">if lastUsedAt.Valid </span><span class="cov0" title="0">{
                key.LastUsedAt = &amp;lastUsedAt.Time
        }</span>

        <span class="cov0" title="0">return key, nil</span>
}

// List åˆ—å‡ºAPIå¯†é’¥
func (r *PostgresAPIKeyRepository) List(ctx context.Context, tenantID string, opts ListOptions) ([]*APIKey, int, error) <span class="cov0" title="0">{
        // è®¾ç½®é»˜è®¤å€¼
        if opts.Limit == 0 </span><span class="cov0" title="0">{
                opts.Limit = 20
        }</span>
        <span class="cov0" title="0">if opts.SortBy == "" </span><span class="cov0" title="0">{
                opts.SortBy = "created_at"
        }</span>
        <span class="cov0" title="0">if opts.Order == "" </span><span class="cov0" title="0">{
                opts.Order = "desc"
        }</span>

        // è®¡ç®—æ€»æ•°
        <span class="cov0" title="0">countQuery := `
                SELECT COUNT(*) 
                FROM api_keys 
                WHERE tenant_id = $1 AND deleted_at IS NULL
        `
        var total int
        err := r.db.QueryRowContext(ctx, countQuery, tenantID).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to count API keys: %w", err)
        }</span>

        // æŸ¥è¯¢æ•°æ®
        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT 
                        id, tenant_id, name, key, status,
                        permissions, rate_limit, metadata, expires_at,
                        last_used_at, created_at, updated_at
                FROM api_keys
                WHERE tenant_id = $1 AND deleted_at IS NULL
                ORDER BY %s %s
                LIMIT $2 OFFSET $3
        `, opts.SortBy, opts.Order)

        rows, err := r.db.QueryContext(ctx, query, tenantID, opts.Limit, opts.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to list API keys: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var keys []*APIKey
        for rows.Next() </span><span class="cov0" title="0">{
                key := &amp;APIKey{}
                var permissionsJSON, metadataJSON []byte
                var expiresAt, lastUsedAt sql.NullTime

                err := rows.Scan(
                        &amp;key.ID, &amp;key.TenantID, &amp;key.Name, &amp;key.Key,
                        &amp;key.Status, &amp;permissionsJSON, &amp;key.RateLimit, &amp;metadataJSON,
                        &amp;expiresAt, &amp;lastUsedAt, &amp;key.CreatedAt, &amp;key.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("failed to scan API key: %w", err)
                }</span>

                // è§£æJSONå­—æ®µ
                <span class="cov0" title="0">json.Unmarshal(permissionsJSON, &amp;key.Permissions)
                json.Unmarshal(metadataJSON, &amp;key.Metadata)

                if expiresAt.Valid </span><span class="cov0" title="0">{
                        key.ExpiresAt = &amp;expiresAt.Time
                }</span>
                <span class="cov0" title="0">if lastUsedAt.Valid </span><span class="cov0" title="0">{
                        key.LastUsedAt = &amp;lastUsedAt.Time
                }</span>

                <span class="cov0" title="0">keys = append(keys, key)</span>
        }

        <span class="cov0" title="0">return keys, total, nil</span>
}

// Update æ›´æ–°APIå¯†é’¥
func (r *PostgresAPIKeyRepository) Update(ctx context.Context, key *APIKey) error <span class="cov0" title="0">{
        permissionsJSON, _ := json.Marshal(key.Permissions)
        metadataJSON, _ := json.Marshal(key.Metadata)

        query := `
                UPDATE api_keys SET
                        name = $2,
                        status = $3,
                        permissions = $4,
                        rate_limit = $5,
                        metadata = $6,
                        expires_at = $7,
                        updated_at = NOW()
                WHERE id = $1 AND deleted_at IS NULL
        `

        result, err := r.db.ExecContext(ctx, query,
                key.ID, key.Name, key.Status, permissionsJSON,
                key.RateLimit, metadataJSON, key.ExpiresAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update API key: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("API key not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Revoke åŠé”€APIå¯†é’¥
func (r *PostgresAPIKeyRepository) Revoke(ctx context.Context, id string) error <span class="cov0" title="0">{
        return r.updateStatus(ctx, id, "revoked")
}</span>

// UpdateLastUsed æ›´æ–°æœ€åä½¿ç”¨æ—¶é—´
func (r *PostgresAPIKeyRepository) UpdateLastUsed(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := `
                UPDATE api_keys 
                SET last_used_at = NOW()
                WHERE id = $1 AND deleted_at IS NULL
        `

        _, err := r.db.ExecContext(ctx, query, id)
        return err
}</span>

// CheckRateLimit æ£€æŸ¥é€Ÿç‡é™åˆ¶
func (r *PostgresAPIKeyRepository) CheckRateLimit(ctx context.Context, id string) (bool, error) <span class="cov0" title="0">{
        // è·å–API Keyä¿¡æ¯
        key, err := r.Get(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // å¦‚æœæ²¡æœ‰è®¾ç½®é€Ÿç‡é™åˆ¶ï¼Œåˆ™å…è®¸
        <span class="cov0" title="0">if key.RateLimit &lt;= 0 </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        // ä½¿ç”¨Redisé€Ÿç‡é™åˆ¶å™¨æ£€æŸ¥
        <span class="cov0" title="0">if r.rateLimiter != nil </span><span class="cov0" title="0">{
                config := ratelimit.RateLimitConfig{
                        Limit:  key.RateLimit,
                        Window: time.Minute, // æ¯åˆ†é’Ÿé™åˆ¶
                }

                result, err := r.rateLimiter.CheckFixed(ctx, fmt.Sprintf("apikey:%s", id), config)
                if err != nil </span><span class="cov0" title="0">{
                        // å¦‚æœRediså‡ºé”™ï¼Œè®°å½•æ—¥å¿—ä½†å…è®¸è¯·æ±‚é€šè¿‡
                        logrus.WithError(err).Warn("Rate limiter check failed, allowing request")
                        return true, nil
                }</span>

                // æ›´æ–°æœ€åä½¿ç”¨æ—¶é—´
                <span class="cov0" title="0">if result.Allowed </span><span class="cov0" title="0">{
                        r.UpdateLastUsed(ctx, id)
                }</span>

                <span class="cov0" title="0">return result.Allowed, nil</span>
        }

        // å¦‚æœæ²¡æœ‰é…ç½®é€Ÿç‡é™åˆ¶å™¨ï¼Œåˆ™å…è®¸
        <span class="cov0" title="0">return true, nil</span>
}

// updateStatus æ›´æ–°çŠ¶æ€
func (r *PostgresAPIKeyRepository) updateStatus(ctx context.Context, id, status string) error <span class="cov0" title="0">{
        query := `
                UPDATE api_keys 
                SET status = $2, updated_at = NOW()
                WHERE id = $1 AND deleted_at IS NULL
        `

        _, err := r.db.ExecContext(ctx, query, id, status)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update status: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// generateAPIKeyPair ç”ŸæˆAPI Keyå¯¹
func generateAPIKeyPair() (string, string, error) <span class="cov0" title="0">{
        // ç”ŸæˆAPI Keyï¼ˆå…¬å¼€çš„ï¼‰
        keyBytes := make([]byte, 16)
        if _, err := rand.Read(keyBytes); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov0" title="0">apiKey := "sk_" + hex.EncodeToString(keyBytes)

        // ç”ŸæˆSecretï¼ˆç§å¯†çš„ï¼‰
        secretBytes := make([]byte, 32)
        if _, err := rand.Read(secretBytes); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov0" title="0">secret := hex.EncodeToString(secretBytes)

        return apiKey, secret, nil</span>
}

// hashSecret å“ˆå¸Œå¯†é’¥
func hashSecret(secret string) (string, error) <span class="cov0" title="0">{
        hash, err := bcrypt.GenerateFromPassword([]byte(secret), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(hash), nil</span>
}

// verifySecret éªŒè¯å¯†é’¥
func verifySecret(secret, hash string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(secret))
        return err == nil
}</span>

// GenerateSimpleAPIKey ç”Ÿæˆç®€å•çš„API Keyï¼ˆç”¨äºå…¼å®¹æ—§ç³»ç»Ÿï¼‰
func GenerateSimpleAPIKey() string <span class="cov0" title="0">{
        bytes := make([]byte, 32)
        rand.Read(bytes)
        hash := sha256.Sum256(bytes)
        return hex.EncodeToString(hash[:])
}</span>

// ParseAPIKey è§£æAPI Keyï¼ˆæ”¯æŒBearer tokenæ ¼å¼ï¼‰
func ParseAPIKey(authHeader string) string <span class="cov0" title="0">{
        // æ”¯æŒå¤šç§æ ¼å¼ï¼š
        // 1. Bearer sk_xxx
        // 2. ApiKey sk_xxx
        // 3. sk_xxx

        authHeader = strings.TrimSpace(authHeader)

        if strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                return strings.TrimPrefix(authHeader, "Bearer ")
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(authHeader, "ApiKey ") </span><span class="cov0" title="0">{
                return strings.TrimPrefix(authHeader, "ApiKey ")
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(authHeader, "sk_") </span><span class="cov0" title="0">{
                return authHeader
        }</span>

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package repository

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "github.com/google/uuid"
)

// Conversation ä¼šè¯æ¨¡å‹
type Conversation struct {
        ID         string                 `json:"id"`
        UserID     string                 `json:"user_id"`
        TenantID   string                 `json:"tenant_id"`
        Title      string                 `json:"title"`
        Summary    string                 `json:"summary"`
        Status     string                 `json:"status"` // active, archived
        Metadata   map[string]interface{} `json:"metadata"`
        CreatedAt  time.Time              `json:"created_at"`
        UpdatedAt  time.Time              `json:"updated_at"`
        LastMsgAt  time.Time              `json:"last_msg_at"`
        MsgCount   int                    `json:"msg_count"`
        TokenCount int64                  `json:"token_count"`
}

// Message æ¶ˆæ¯æ¨¡å‹
type Message struct {
        ID             string                 `json:"id"`
        ConversationID string                 `json:"conversation_id"`
        Role           string                 `json:"role"` // user, assistant, system
        Content        string                 `json:"content"`
        Modality       string                 `json:"modality"` // text, voice, image
        TokenCount     int                    `json:"token_count"`
        Metadata       map[string]interface{} `json:"metadata"`
        References     []Reference            `json:"references,omitempty"`
        CreatedAt      time.Time              `json:"created_at"`
}

// Reference å¼•ç”¨ä¿¡æ¯
type Reference struct {
        ChunkID    string  `json:"chunk_id"`
        Source     string  `json:"source"`
        Content    string  `json:"content"`
        Score      float64 `json:"score"`
        PageNumber int     `json:"page_number,omitempty"`
}

// ConversationRepository ä¼šè¯ä»“åº“æ¥å£
type ConversationRepository interface {
        Create(ctx context.Context, conv *Conversation) error
        Get(ctx context.Context, id string) (*Conversation, error)
        GetByUserID(ctx context.Context, userID string, opts ListOptions) ([]*Conversation, int, error)
        Update(ctx context.Context, conv *Conversation) error
        Delete(ctx context.Context, id string) error
        Archive(ctx context.Context, id string) error

        // Message operations
        AddMessage(ctx context.Context, msg *Message) error
        GetMessages(ctx context.Context, convID string, opts ListOptions) ([]*Message, int, error)
        GetLastMessages(ctx context.Context, convID string, limit int) ([]*Message, error)
        UpdateMessageReferences(ctx context.Context, msgID string, refs []Reference) error

        // Statistics
        UpdateStats(ctx context.Context, convID string) error
        GetUserStats(ctx context.Context, userID string) (map[string]interface{}, error)
}

// PostgresConversationRepository PostgreSQLå®ç°
type PostgresConversationRepository struct {
        db *sql.DB
}

// NewPostgresConversationRepository åˆ›å»ºPostgreSQLä¼šè¯ä»“åº“
func NewPostgresConversationRepository(db *sql.DB) ConversationRepository <span class="cov0" title="0">{
        return &amp;PostgresConversationRepository{db: db}
}</span>

// Create åˆ›å»ºä¼šè¯
func (r *PostgresConversationRepository) Create(ctx context.Context, conv *Conversation) error <span class="cov0" title="0">{
        if conv.ID == "" </span><span class="cov0" title="0">{
                conv.ID = uuid.New().String()
        }</span>
        <span class="cov0" title="0">if conv.Status == "" </span><span class="cov0" title="0">{
                conv.Status = "active"
        }</span>
        <span class="cov0" title="0">if conv.Title == "" </span><span class="cov0" title="0">{
                conv.Title = "æ–°ä¼šè¯"
        }</span>

        // åºåˆ—åŒ–metadata
        <span class="cov0" title="0">metadataJSON, err := json.Marshal(conv.Metadata)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO conversations (
                        id, user_id, tenant_id, title, summary, status,
                        metadata, created_at, updated_at, last_msg_at
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, NOW(), NOW(), NOW()
                )
        `

        _, err = r.db.ExecContext(ctx, query,
                conv.ID, conv.UserID, conv.TenantID, conv.Title,
                conv.Summary, conv.Status, metadataJSON,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create conversation: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Get è·å–ä¼šè¯
func (r *PostgresConversationRepository) Get(ctx context.Context, id string) (*Conversation, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, user_id, tenant_id, title, summary, status,
                        metadata, created_at, updated_at, last_msg_at,
                        msg_count, token_count
                FROM conversations
                WHERE id = $1 AND deleted_at IS NULL
        `

        conv := &amp;Conversation{}
        var metadataJSON []byte

        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;conv.ID, &amp;conv.UserID, &amp;conv.TenantID, &amp;conv.Title,
                &amp;conv.Summary, &amp;conv.Status, &amp;metadataJSON,
                &amp;conv.CreatedAt, &amp;conv.UpdatedAt, &amp;conv.LastMsgAt,
                &amp;conv.MsgCount, &amp;conv.TokenCount,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("conversation not found")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get conversation: %w", err)
        }</span>

        // è§£æmetadata
        <span class="cov0" title="0">if len(metadataJSON) &gt; 0 </span><span class="cov0" title="0">{
                if err := json.Unmarshal(metadataJSON, &amp;conv.Metadata); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal metadata: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return conv, nil</span>
}

// GetByUserID è·å–ç”¨æˆ·çš„ä¼šè¯åˆ—è¡¨
func (r *PostgresConversationRepository) GetByUserID(ctx context.Context, userID string, opts ListOptions) ([]*Conversation, int, error) <span class="cov0" title="0">{
        // è®¾ç½®é»˜è®¤å€¼
        if opts.Limit == 0 </span><span class="cov0" title="0">{
                opts.Limit = 20
        }</span>
        <span class="cov0" title="0">if opts.SortBy == "" </span><span class="cov0" title="0">{
                opts.SortBy = "last_msg_at"
        }</span>
        <span class="cov0" title="0">if opts.Order == "" </span><span class="cov0" title="0">{
                opts.Order = "desc"
        }</span>

        // è®¡ç®—æ€»æ•°
        <span class="cov0" title="0">countQuery := `
                SELECT COUNT(*) 
                FROM conversations 
                WHERE user_id = $1 AND deleted_at IS NULL
        `
        var total int
        err := r.db.QueryRowContext(ctx, countQuery, userID).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to count conversations: %w", err)
        }</span>

        // æŸ¥è¯¢æ•°æ®
        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT 
                        id, user_id, tenant_id, title, summary, status,
                        metadata, created_at, updated_at, last_msg_at,
                        msg_count, token_count
                FROM conversations
                WHERE user_id = $1 AND deleted_at IS NULL
                ORDER BY %s %s
                LIMIT $2 OFFSET $3
        `, opts.SortBy, opts.Order)

        rows, err := r.db.QueryContext(ctx, query, userID, opts.Limit, opts.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to list conversations: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var conversations []*Conversation
        for rows.Next() </span><span class="cov0" title="0">{
                conv := &amp;Conversation{}
                var metadataJSON []byte

                err := rows.Scan(
                        &amp;conv.ID, &amp;conv.UserID, &amp;conv.TenantID, &amp;conv.Title,
                        &amp;conv.Summary, &amp;conv.Status, &amp;metadataJSON,
                        &amp;conv.CreatedAt, &amp;conv.UpdatedAt, &amp;conv.LastMsgAt,
                        &amp;conv.MsgCount, &amp;conv.TokenCount,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("failed to scan conversation: %w", err)
                }</span>

                // è§£æmetadata
                <span class="cov0" title="0">if len(metadataJSON) &gt; 0 </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(metadataJSON, &amp;conv.Metadata); err != nil </span><span class="cov0" title="0">{
                                return nil, 0, fmt.Errorf("failed to unmarshal metadata: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">conversations = append(conversations, conv)</span>
        }

        <span class="cov0" title="0">return conversations, total, nil</span>
}

// Update æ›´æ–°ä¼šè¯
func (r *PostgresConversationRepository) Update(ctx context.Context, conv *Conversation) error <span class="cov0" title="0">{
        metadataJSON, err := json.Marshal(conv.Metadata)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE conversations SET
                        title = $2,
                        summary = $3,
                        status = $4,
                        metadata = $5,
                        updated_at = NOW()
                WHERE id = $1 AND deleted_at IS NULL
        `

        result, err := r.db.ExecContext(ctx, query,
                conv.ID, conv.Title, conv.Summary, conv.Status, metadataJSON,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update conversation: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("conversation not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete è½¯åˆ é™¤ä¼šè¯
func (r *PostgresConversationRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := `
                UPDATE conversations 
                SET deleted_at = NOW(), updated_at = NOW()
                WHERE id = $1 AND deleted_at IS NULL
        `

        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete conversation: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("conversation not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Archive å½’æ¡£ä¼šè¯
func (r *PostgresConversationRepository) Archive(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := `
                UPDATE conversations 
                SET status = 'archived', updated_at = NOW()
                WHERE id = $1 AND deleted_at IS NULL
        `

        _, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to archive conversation: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AddMessage æ·»åŠ æ¶ˆæ¯
func (r *PostgresConversationRepository) AddMessage(ctx context.Context, msg *Message) error <span class="cov0" title="0">{
        if msg.ID == "" </span><span class="cov0" title="0">{
                msg.ID = uuid.New().String()
        }</span>

        // åºåˆ—åŒ–metadataå’Œreferences
        <span class="cov0" title="0">metadataJSON, err := json.Marshal(msg.Metadata)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal metadata: %w", err)
        }</span>

        <span class="cov0" title="0">referencesJSON, err := json.Marshal(msg.References)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal references: %w", err)
        }</span>

        // å¼€å§‹äº‹åŠ¡
        <span class="cov0" title="0">tx, err := r.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // æ’å…¥æ¶ˆæ¯
        query := `
                INSERT INTO messages (
                        id, conversation_id, role, content, modality,
                        token_count, metadata, references, created_at
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, $8, NOW()
                )
        `

        _, err = tx.ExecContext(ctx, query,
                msg.ID, msg.ConversationID, msg.Role, msg.Content,
                msg.Modality, msg.TokenCount, metadataJSON, referencesJSON,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add message: %w", err)
        }</span>

        // æ›´æ–°ä¼šè¯ç»Ÿè®¡
        <span class="cov0" title="0">updateQuery := `
                UPDATE conversations 
                SET 
                        msg_count = msg_count + 1,
                        token_count = token_count + $2,
                        last_msg_at = NOW(),
                        updated_at = NOW()
                WHERE id = $1
        `

        _, err = tx.ExecContext(ctx, updateQuery, msg.ConversationID, msg.TokenCount)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update conversation stats: %w", err)
        }</span>

        // å¦‚æœæ˜¯ç¬¬ä¸€æ¡ç”¨æˆ·æ¶ˆæ¯ï¼Œè‡ªåŠ¨ç”Ÿæˆæ ‡é¢˜
        <span class="cov0" title="0">if msg.Role == "user" </span><span class="cov0" title="0">{
                var msgCount int
                countQuery := `SELECT msg_count FROM conversations WHERE id = $1`
                err = tx.QueryRowContext(ctx, countQuery, msg.ConversationID).Scan(&amp;msgCount)
                if err == nil &amp;&amp; msgCount == 1 </span><span class="cov0" title="0">{
                        // ä½¿ç”¨æ¶ˆæ¯å†…å®¹çš„å‰50ä¸ªå­—ç¬¦ä½œä¸ºæ ‡é¢˜
                        title := msg.Content
                        if len(title) &gt; 50 </span><span class="cov0" title="0">{
                                title = title[:50] + "..."
                        }</span>
                        <span class="cov0" title="0">titleQuery := `UPDATE conversations SET title = $2 WHERE id = $1`
                        tx.ExecContext(ctx, titleQuery, msg.ConversationID, title)</span>
                }
        }

        <span class="cov0" title="0">return tx.Commit()</span>
}

// GetMessages è·å–ä¼šè¯æ¶ˆæ¯
func (r *PostgresConversationRepository) GetMessages(ctx context.Context, convID string, opts ListOptions) ([]*Message, int, error) <span class="cov0" title="0">{
        // è®¾ç½®é»˜è®¤å€¼
        if opts.Limit == 0 </span><span class="cov0" title="0">{
                opts.Limit = 50
        }</span>
        <span class="cov0" title="0">if opts.SortBy == "" </span><span class="cov0" title="0">{
                opts.SortBy = "created_at"
        }</span>
        <span class="cov0" title="0">if opts.Order == "" </span><span class="cov0" title="0">{
                opts.Order = "asc"
        }</span>

        // è®¡ç®—æ€»æ•°
        <span class="cov0" title="0">countQuery := `
                SELECT COUNT(*) 
                FROM messages 
                WHERE conversation_id = $1
        `
        var total int
        err := r.db.QueryRowContext(ctx, countQuery, convID).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to count messages: %w", err)
        }</span>

        // æŸ¥è¯¢æ•°æ®
        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT 
                        id, conversation_id, role, content, modality,
                        token_count, metadata, references, created_at
                FROM messages
                WHERE conversation_id = $1
                ORDER BY %s %s
                LIMIT $2 OFFSET $3
        `, opts.SortBy, opts.Order)

        rows, err := r.db.QueryContext(ctx, query, convID, opts.Limit, opts.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to list messages: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var messages []*Message
        for rows.Next() </span><span class="cov0" title="0">{
                msg := &amp;Message{}
                var metadataJSON, referencesJSON []byte

                err := rows.Scan(
                        &amp;msg.ID, &amp;msg.ConversationID, &amp;msg.Role, &amp;msg.Content,
                        &amp;msg.Modality, &amp;msg.TokenCount, &amp;metadataJSON,
                        &amp;referencesJSON, &amp;msg.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("failed to scan message: %w", err)
                }</span>

                // è§£æmetadata
                <span class="cov0" title="0">if len(metadataJSON) &gt; 0 </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(metadataJSON, &amp;msg.Metadata); err != nil </span><span class="cov0" title="0">{
                                return nil, 0, fmt.Errorf("failed to unmarshal metadata: %w", err)
                        }</span>
                }

                // è§£æreferences
                <span class="cov0" title="0">if len(referencesJSON) &gt; 0 </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(referencesJSON, &amp;msg.References); err != nil </span><span class="cov0" title="0">{
                                return nil, 0, fmt.Errorf("failed to unmarshal references: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">messages = append(messages, msg)</span>
        }

        <span class="cov0" title="0">return messages, total, nil</span>
}

// GetLastMessages è·å–æœ€è¿‘çš„æ¶ˆæ¯
func (r *PostgresConversationRepository) GetLastMessages(ctx context.Context, convID string, limit int) ([]*Message, error) <span class="cov0" title="0">{
        if limit == 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov0" title="0">query := `
                SELECT 
                        id, conversation_id, role, content, modality,
                        token_count, metadata, references, created_at
                FROM messages
                WHERE conversation_id = $1
                ORDER BY created_at DESC
                LIMIT $2
        `

        rows, err := r.db.QueryContext(ctx, query, convID, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get last messages: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var messages []*Message
        for rows.Next() </span><span class="cov0" title="0">{
                msg := &amp;Message{}
                var metadataJSON, referencesJSON []byte

                err := rows.Scan(
                        &amp;msg.ID, &amp;msg.ConversationID, &amp;msg.Role, &amp;msg.Content,
                        &amp;msg.Modality, &amp;msg.TokenCount, &amp;metadataJSON,
                        &amp;referencesJSON, &amp;msg.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan message: %w", err)
                }</span>

                // è§£æJSONå­—æ®µ
                <span class="cov0" title="0">if len(metadataJSON) &gt; 0 </span><span class="cov0" title="0">{
                        json.Unmarshal(metadataJSON, &amp;msg.Metadata)
                }</span>
                <span class="cov0" title="0">if len(referencesJSON) &gt; 0 </span><span class="cov0" title="0">{
                        json.Unmarshal(referencesJSON, &amp;msg.References)
                }</span>

                <span class="cov0" title="0">messages = append(messages, msg)</span>
        }

        // åè½¬é¡ºåºï¼ˆå› ä¸ºæŸ¥è¯¢æ—¶æ˜¯DESCï¼‰
        <span class="cov0" title="0">for i, j := 0, len(messages)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                messages[i], messages[j] = messages[j], messages[i]
        }</span>

        <span class="cov0" title="0">return messages, nil</span>
}

// UpdateMessageReferences æ›´æ–°æ¶ˆæ¯å¼•ç”¨
func (r *PostgresConversationRepository) UpdateMessageReferences(ctx context.Context, msgID string, refs []Reference) error <span class="cov0" title="0">{
        referencesJSON, err := json.Marshal(refs)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal references: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE messages 
                SET references = $2
                WHERE id = $1
        `

        _, err = r.db.ExecContext(ctx, query, msgID, referencesJSON)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update message references: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateStats æ›´æ–°ä¼šè¯ç»Ÿè®¡
func (r *PostgresConversationRepository) UpdateStats(ctx context.Context, convID string) error <span class="cov0" title="0">{
        query := `
                UPDATE conversations c
                SET 
                        msg_count = (SELECT COUNT(*) FROM messages WHERE conversation_id = c.id),
                        token_count = (SELECT COALESCE(SUM(token_count), 0) FROM messages WHERE conversation_id = c.id),
                        updated_at = NOW()
                WHERE id = $1
        `

        _, err := r.db.ExecContext(ctx, query, convID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update conversation stats: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetUserStats è·å–ç”¨æˆ·ç»Ÿè®¡
func (r *PostgresConversationRepository) GetUserStats(ctx context.Context, userID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        COUNT(DISTINCT c.id) as conversation_count,
                        COUNT(m.id) as message_count,
                        COALESCE(SUM(m.token_count), 0) as total_tokens,
                        MAX(c.last_msg_at) as last_active
                FROM conversations c
                LEFT JOIN messages m ON c.id = m.conversation_id
                WHERE c.user_id = $1 AND c.deleted_at IS NULL
        `

        var conversationCount, messageCount int
        var totalTokens int64
        var lastActive sql.NullTime

        err := r.db.QueryRowContext(ctx, query, userID).Scan(
                &amp;conversationCount,
                &amp;messageCount,
                &amp;totalTokens,
                &amp;lastActive,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user stats: %w", err)
        }</span>

        <span class="cov0" title="0">stats := map[string]interface{}{
                "conversation_count": conversationCount,
                "message_count":      messageCount,
                "total_tokens":       totalTokens,
        }

        if lastActive.Valid </span><span class="cov0" title="0">{
                stats["last_active"] = lastActive.Time
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "github.com/google/uuid"
)

// Dataset æ•°æ®é›†æ¨¡å‹
type Dataset struct {
        ID          string    `json:"id"`
        TenantID    string    `json:"tenant_id"`
        Name        string    `json:"name"`
        Description string    `json:"description"`
        Type        string    `json:"type"`   // document, qa, custom
        Status      string    `json:"status"` // active, inactive, processing
        DocCount    int       `json:"doc_count"`
        ChunkCount  int       `json:"chunk_count"`
        TokenCount  int64     `json:"token_count"`
        Metadata    string    `json:"metadata"` // JSON string
        CreatedBy   string    `json:"created_by"`
        UpdatedBy   string    `json:"updated_by"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`
}

// Document æ–‡æ¡£æ¨¡å‹
type Document struct {
        ID         string    `json:"id"`
        DatasetID  string    `json:"dataset_id"`
        Name       string    `json:"name"`
        Source     string    `json:"source"` // file path or URL
        Type       string    `json:"type"`   // pdf, txt, docx, html, etc.
        Size       int64     `json:"size"`   // file size in bytes
        Status     string    `json:"status"` // pending, processing, completed, failed
        ChunkCount int       `json:"chunk_count"`
        TokenCount int64     `json:"token_count"`
        Metadata   string    `json:"metadata"` // JSON string
        CreatedAt  time.Time `json:"created_at"`
        UpdatedAt  time.Time `json:"updated_at"`
}

// ListOptions åˆ—è¡¨æŸ¥è¯¢é€‰é¡¹
type ListOptions struct {
        Offset int
        Limit  int
        SortBy string
        Order  string // asc or desc
}

// DatasetRepository æ•°æ®é›†ä»“åº“æ¥å£
type DatasetRepository interface {
        List(ctx context.Context, tenantID string, opts ListOptions) ([]*Dataset, int, error)
        Get(ctx context.Context, id string) (*Dataset, error)
        Create(ctx context.Context, dataset *Dataset) error
        Update(ctx context.Context, dataset *Dataset) error
        Delete(ctx context.Context, id string) error
        UpdateStats(ctx context.Context, id string, docCount, chunkCount int, tokenCount int64) error

        // Document related
        ListDocuments(ctx context.Context, datasetID string, opts ListOptions) ([]*Document, int, error)
        CreateDocument(ctx context.Context, doc *Document) error
        UpdateDocumentStatus(ctx context.Context, docID, status string) error
        DeleteDocument(ctx context.Context, docID string) error
}

// PostgresDatasetRepository PostgreSQLå®ç°
type PostgresDatasetRepository struct {
        db *sql.DB
}

// NewPostgresDatasetRepository åˆ›å»ºPostgreSQLæ•°æ®é›†ä»“åº“
func NewPostgresDatasetRepository(db *sql.DB) DatasetRepository <span class="cov8" title="1">{
        return &amp;PostgresDatasetRepository{db: db}
}</span>

// List è·å–æ•°æ®é›†åˆ—è¡¨
func (r *PostgresDatasetRepository) List(ctx context.Context, tenantID string, opts ListOptions) ([]*Dataset, int, error) <span class="cov0" title="0">{
        // è®¾ç½®é»˜è®¤å€¼
        if opts.Limit == 0 </span><span class="cov0" title="0">{
                opts.Limit = 20
        }</span>
        <span class="cov0" title="0">if opts.SortBy == "" </span><span class="cov0" title="0">{
                opts.SortBy = "created_at"
        }</span>
        <span class="cov0" title="0">if opts.Order == "" </span><span class="cov0" title="0">{
                opts.Order = "desc"
        }</span>

        // è®¡ç®—æ€»æ•°
        <span class="cov0" title="0">countQuery := `
                SELECT COUNT(*) 
                FROM datasets 
                WHERE tenant_id = $1 AND deleted_at IS NULL
        `
        var total int
        err := r.db.QueryRowContext(ctx, countQuery, tenantID).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to count datasets: %w", err)
        }</span>

        // æŸ¥è¯¢æ•°æ®
        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT 
                        id, tenant_id, name, description, type, status,
                        doc_count, chunk_count, token_count, metadata,
                        created_by, updated_by, created_at, updated_at
                FROM datasets
                WHERE tenant_id = $1 AND deleted_at IS NULL
                ORDER BY %s %s
                LIMIT $2 OFFSET $3
        `, opts.SortBy, opts.Order)

        rows, err := r.db.QueryContext(ctx, query, tenantID, opts.Limit, opts.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to list datasets: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var datasets []*Dataset
        for rows.Next() </span><span class="cov0" title="0">{
                dataset := &amp;Dataset{}
                err := rows.Scan(
                        &amp;dataset.ID, &amp;dataset.TenantID, &amp;dataset.Name, &amp;dataset.Description,
                        &amp;dataset.Type, &amp;dataset.Status, &amp;dataset.DocCount, &amp;dataset.ChunkCount,
                        &amp;dataset.TokenCount, &amp;dataset.Metadata, &amp;dataset.CreatedBy,
                        &amp;dataset.UpdatedBy, &amp;dataset.CreatedAt, &amp;dataset.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("failed to scan dataset: %w", err)
                }</span>
                <span class="cov0" title="0">datasets = append(datasets, dataset)</span>
        }

        <span class="cov0" title="0">return datasets, total, nil</span>
}

// Get è·å–æ•°æ®é›†è¯¦æƒ…
func (r *PostgresDatasetRepository) Get(ctx context.Context, id string) (*Dataset, error) <span class="cov8" title="1">{
        query := `
                SELECT 
                        id, tenant_id, name, description, type, status,
                        doc_count, chunk_count, token_count, metadata,
                        created_by, updated_by, created_at, updated_at
                FROM datasets
                WHERE id = $1 AND deleted_at IS NULL
        `

        dataset := &amp;Dataset{}
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;dataset.ID, &amp;dataset.TenantID, &amp;dataset.Name, &amp;dataset.Description,
                &amp;dataset.Type, &amp;dataset.Status, &amp;dataset.DocCount, &amp;dataset.ChunkCount,
                &amp;dataset.TokenCount, &amp;dataset.Metadata, &amp;dataset.CreatedBy,
                &amp;dataset.UpdatedBy, &amp;dataset.CreatedAt, &amp;dataset.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dataset not found")
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get dataset: %w", err)
        }</span>

        <span class="cov8" title="1">return dataset, nil</span>
}

// Create åˆ›å»ºæ•°æ®é›†
func (r *PostgresDatasetRepository) Create(ctx context.Context, dataset *Dataset) error <span class="cov8" title="1">{
        if dataset.ID == "" </span><span class="cov8" title="1">{
                dataset.ID = uuid.New().String()
        }</span>
        <span class="cov8" title="1">if dataset.Type == "" </span><span class="cov8" title="1">{
                dataset.Type = "document"
        }</span>
        <span class="cov8" title="1">if dataset.Status == "" </span><span class="cov8" title="1">{
                dataset.Status = "active"
        }</span>
        <span class="cov8" title="1">if dataset.Metadata == "" </span><span class="cov8" title="1">{
                dataset.Metadata = "{}"
        }</span>

        <span class="cov8" title="1">query := `
                INSERT INTO datasets (
                        id, tenant_id, name, description, type, status,
                        doc_count, chunk_count, token_count, metadata,
                        created_by, updated_by, created_at, updated_at
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, NOW(), NOW()
                )
        `

        _, err := r.db.ExecContext(ctx, query,
                dataset.ID, dataset.TenantID, dataset.Name, dataset.Description,
                dataset.Type, dataset.Status, dataset.DocCount, dataset.ChunkCount,
                dataset.TokenCount, dataset.Metadata, dataset.CreatedBy, dataset.UpdatedBy,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create dataset: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Update æ›´æ–°æ•°æ®é›†
func (r *PostgresDatasetRepository) Update(ctx context.Context, dataset *Dataset) error <span class="cov0" title="0">{
        query := `
                UPDATE datasets SET
                        name = $2,
                        description = $3,
                        type = $4,
                        status = $5,
                        metadata = $6,
                        updated_by = $7,
                        updated_at = NOW()
                WHERE id = $1 AND deleted_at IS NULL
        `

        result, err := r.db.ExecContext(ctx, query,
                dataset.ID, dataset.Name, dataset.Description,
                dataset.Type, dataset.Status, dataset.Metadata, dataset.UpdatedBy,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update dataset: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("dataset not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete è½¯åˆ é™¤æ•°æ®é›†
func (r *PostgresDatasetRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := `
                UPDATE datasets 
                SET deleted_at = NOW(), updated_at = NOW()
                WHERE id = $1 AND deleted_at IS NULL
        `

        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete dataset: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("dataset not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateStats æ›´æ–°æ•°æ®é›†ç»Ÿè®¡ä¿¡æ¯
func (r *PostgresDatasetRepository) UpdateStats(ctx context.Context, id string, docCount, chunkCount int, tokenCount int64) error <span class="cov0" title="0">{
        query := `
                UPDATE datasets SET
                        doc_count = $2,
                        chunk_count = $3,
                        token_count = $4,
                        updated_at = NOW()
                WHERE id = $1 AND deleted_at IS NULL
        `

        _, err := r.db.ExecContext(ctx, query, id, docCount, chunkCount, tokenCount)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update dataset stats: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListDocuments è·å–æ–‡æ¡£åˆ—è¡¨
func (r *PostgresDatasetRepository) ListDocuments(ctx context.Context, datasetID string, opts ListOptions) ([]*Document, int, error) <span class="cov0" title="0">{
        // è®¾ç½®é»˜è®¤å€¼
        if opts.Limit == 0 </span><span class="cov0" title="0">{
                opts.Limit = 20
        }</span>
        <span class="cov0" title="0">if opts.SortBy == "" </span><span class="cov0" title="0">{
                opts.SortBy = "created_at"
        }</span>
        <span class="cov0" title="0">if opts.Order == "" </span><span class="cov0" title="0">{
                opts.Order = "desc"
        }</span>

        // è®¡ç®—æ€»æ•°
        <span class="cov0" title="0">countQuery := `
                SELECT COUNT(*) 
                FROM documents 
                WHERE dataset_id = $1 AND deleted_at IS NULL
        `
        var total int
        err := r.db.QueryRowContext(ctx, countQuery, datasetID).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to count documents: %w", err)
        }</span>

        // æŸ¥è¯¢æ•°æ®
        <span class="cov0" title="0">query := fmt.Sprintf(`
                SELECT 
                        id, dataset_id, name, source, type, size, status,
                        chunk_count, token_count, metadata, created_at, updated_at
                FROM documents
                WHERE dataset_id = $1 AND deleted_at IS NULL
                ORDER BY %s %s
                LIMIT $2 OFFSET $3
        `, opts.SortBy, opts.Order)

        rows, err := r.db.QueryContext(ctx, query, datasetID, opts.Limit, opts.Offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to list documents: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var documents []*Document
        for rows.Next() </span><span class="cov0" title="0">{
                doc := &amp;Document{}
                err := rows.Scan(
                        &amp;doc.ID, &amp;doc.DatasetID, &amp;doc.Name, &amp;doc.Source,
                        &amp;doc.Type, &amp;doc.Size, &amp;doc.Status, &amp;doc.ChunkCount,
                        &amp;doc.TokenCount, &amp;doc.Metadata, &amp;doc.CreatedAt, &amp;doc.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("failed to scan document: %w", err)
                }</span>
                <span class="cov0" title="0">documents = append(documents, doc)</span>
        }

        <span class="cov0" title="0">return documents, total, nil</span>
}

// CreateDocument åˆ›å»ºæ–‡æ¡£
func (r *PostgresDatasetRepository) CreateDocument(ctx context.Context, doc *Document) error <span class="cov0" title="0">{
        if doc.ID == "" </span><span class="cov0" title="0">{
                doc.ID = uuid.New().String()
        }</span>
        <span class="cov0" title="0">if doc.Status == "" </span><span class="cov0" title="0">{
                doc.Status = "pending"
        }</span>
        <span class="cov0" title="0">if doc.Metadata == "" </span><span class="cov0" title="0">{
                doc.Metadata = "{}"
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO documents (
                        id, dataset_id, name, source, type, size, status,
                        chunk_count, token_count, metadata, created_at, updated_at
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW(), NOW()
                )
        `

        _, err := r.db.ExecContext(ctx, query,
                doc.ID, doc.DatasetID, doc.Name, doc.Source,
                doc.Type, doc.Size, doc.Status, doc.ChunkCount,
                doc.TokenCount, doc.Metadata,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create document: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateDocumentStatus æ›´æ–°æ–‡æ¡£çŠ¶æ€
func (r *PostgresDatasetRepository) UpdateDocumentStatus(ctx context.Context, docID, status string) error <span class="cov0" title="0">{
        query := `
                UPDATE documents SET
                        status = $2,
                        updated_at = NOW()
                WHERE id = $1 AND deleted_at IS NULL
        `

        _, err := r.db.ExecContext(ctx, query, docID, status)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update document status: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDocument è·å–æ–‡æ¡£è¯¦æƒ…
func (r *PostgresDatasetRepository) GetDocument(ctx context.Context, docID string) (*Document, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, dataset_id, name, source, type, size, status,
                        chunk_count, token_count, metadata, created_at, updated_at
                FROM documents
                WHERE id = $1 AND deleted_at IS NULL
        `

        doc := &amp;Document{}
        err := r.db.QueryRowContext(ctx, query, docID).Scan(
                &amp;doc.ID, &amp;doc.DatasetID, &amp;doc.Name, &amp;doc.Source,
                &amp;doc.Type, &amp;doc.Size, &amp;doc.Status, &amp;doc.ChunkCount,
                &amp;doc.TokenCount, &amp;doc.Metadata, &amp;doc.CreatedAt, &amp;doc.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("document not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get document: %w", err)</span>
        }

        <span class="cov0" title="0">return doc, nil</span>
}

// UpdateDocument æ›´æ–°æ–‡æ¡£ä¿¡æ¯
func (r *PostgresDatasetRepository) UpdateDocument(ctx context.Context, doc *Document) error <span class="cov0" title="0">{
        query := `
                UPDATE documents SET
                        name = $2,
                        source = $3,
                        type = $4,
                        size = $5,
                        status = $6,
                        chunk_count = $7,
                        token_count = $8,
                        metadata = $9,
                        updated_at = NOW()
                WHERE id = $1 AND deleted_at IS NULL
        `

        result, err := r.db.ExecContext(ctx, query,
                doc.ID, doc.Name, doc.Source, doc.Type, doc.Size,
                doc.Status, doc.ChunkCount, doc.TokenCount, doc.Metadata,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update document: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteDocument è½¯åˆ é™¤æ–‡æ¡£
func (r *PostgresDatasetRepository) DeleteDocument(ctx context.Context, docID string) error <span class="cov0" title="0">{
        query := `
                UPDATE documents 
                SET deleted_at = NOW(), updated_at = NOW()
                WHERE id = $1 AND deleted_at IS NULL
        `

        result, err := r.db.ExecContext(ctx, query, docID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete document: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("document not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "github.com/google/uuid"
        _ "github.com/lib/pq"
)

// User ç”¨æˆ·æ¨¡å‹
type User struct {
        ID        string    `json:"id"`
        OpenID    string    `json:"open_id"`
        UnionID   string    `json:"union_id"`
        TenantID  string    `json:"tenant_id"`
        Username  string    `json:"username"`
        Nickname  string    `json:"nickname"`
        Avatar    string    `json:"avatar"`
        Email     string    `json:"email"`
        Phone     string    `json:"phone"`
        Role      string    `json:"role"`
        Status    string    `json:"status"`
        LastLogin time.Time `json:"last_login"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// UserRepository ç”¨æˆ·ä»“åº“æ¥å£
type UserRepository interface {
        Create(ctx context.Context, user *User) error
        GetByID(ctx context.Context, id string) (*User, error)
        GetByOpenID(ctx context.Context, openID string) (*User, error)
        Update(ctx context.Context, user *User) error
        Delete(ctx context.Context, id string) error
        UpdateLastLogin(ctx context.Context, userID string) error
}

// PostgresUserRepository PostgreSQLå®ç°
type PostgresUserRepository struct {
        db *sql.DB
}

// NewPostgresUserRepository åˆ›å»ºPostgreSQLç”¨æˆ·ä»“åº“
func NewPostgresUserRepository(db *sql.DB) UserRepository <span class="cov8" title="1">{
        return &amp;PostgresUserRepository{db: db}
}</span>

// Create åˆ›å»ºç”¨æˆ·
func (r *PostgresUserRepository) Create(ctx context.Context, user *User) error <span class="cov8" title="1">{
        if user.ID == "" </span><span class="cov8" title="1">{
                user.ID = uuid.New().String()
        }</span>
        <span class="cov8" title="1">if user.TenantID == "" </span><span class="cov0" title="0">{
                user.TenantID = "default"
        }</span>
        <span class="cov8" title="1">if user.Role == "" </span><span class="cov8" title="1">{
                user.Role = "user"
        }</span>
        <span class="cov8" title="1">if user.Status == "" </span><span class="cov8" title="1">{
                user.Status = "active"
        }</span>

        <span class="cov8" title="1">query := `
                INSERT INTO users (
                        id, open_id, union_id, tenant_id, username, nickname, 
                        avatar, email, phone, role, status, created_at, updated_at
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW(), NOW()
                )
        `

        _, err := r.db.ExecContext(ctx, query,
                user.ID, user.OpenID, user.UnionID, user.TenantID,
                user.Username, user.Nickname, user.Avatar,
                user.Email, user.Phone, user.Role, user.Status,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetByID æ ¹æ®IDè·å–ç”¨æˆ·
func (r *PostgresUserRepository) GetByID(ctx context.Context, id string) (*User, error) <span class="cov8" title="1">{
        query := `
                SELECT 
                        id, open_id, union_id, tenant_id, username, nickname,
                        avatar, email, phone, role, status, last_login, created_at, updated_at
                FROM users
                WHERE id = $1 AND deleted_at IS NULL
        `

        user := &amp;User{}
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;user.ID, &amp;user.OpenID, &amp;user.UnionID, &amp;user.TenantID,
                &amp;user.Username, &amp;user.Nickname, &amp;user.Avatar,
                &amp;user.Email, &amp;user.Phone, &amp;user.Role, &amp;user.Status,
                &amp;user.LastLogin, &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found")
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

// GetByOpenID æ ¹æ®OpenIDè·å–ç”¨æˆ·
func (r *PostgresUserRepository) GetByOpenID(ctx context.Context, openID string) (*User, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        id, open_id, union_id, tenant_id, username, nickname,
                        avatar, email, phone, role, status, last_login, created_at, updated_at
                FROM users
                WHERE open_id = $1 AND deleted_at IS NULL
                LIMIT 1
        `

        user := &amp;User{}
        err := r.db.QueryRowContext(ctx, query, openID).Scan(
                &amp;user.ID, &amp;user.OpenID, &amp;user.UnionID, &amp;user.TenantID,
                &amp;user.Username, &amp;user.Nickname, &amp;user.Avatar,
                &amp;user.Email, &amp;user.Phone, &amp;user.Role, &amp;user.Status,
                &amp;user.LastLogin, &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil // ç”¨æˆ·ä¸å­˜åœ¨ï¼Œè¿”å›nilè€Œä¸æ˜¯é”™è¯¯
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user by openid: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// Update æ›´æ–°ç”¨æˆ·ä¿¡æ¯
func (r *PostgresUserRepository) Update(ctx context.Context, user *User) error <span class="cov0" title="0">{
        query := `
                UPDATE users SET
                        username = $2,
                        nickname = $3,
                        avatar = $4,
                        email = $5,
                        phone = $6,
                        role = $7,
                        status = $8,
                        updated_at = NOW()
                WHERE id = $1 AND deleted_at IS NULL
        `

        result, err := r.db.ExecContext(ctx, query,
                user.ID, user.Username, user.Nickname, user.Avatar,
                user.Email, user.Phone, user.Role, user.Status,
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("user not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete è½¯åˆ é™¤ç”¨æˆ·
func (r *PostgresUserRepository) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := `
                UPDATE users 
                SET deleted_at = NOW(), updated_at = NOW()
                WHERE id = $1 AND deleted_at IS NULL
        `

        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete user: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("user not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateLastLogin æ›´æ–°æœ€åç™»å½•æ—¶é—´
func (r *PostgresUserRepository) UpdateLastLogin(ctx context.Context, userID string) error <span class="cov0" title="0">{
        query := `
                UPDATE users 
                SET last_login = NOW(), updated_at = NOW()
                WHERE id = $1 AND deleted_at IS NULL
        `

        _, err := r.db.ExecContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update last login: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetOrCreateByOpenID æ ¹æ®OpenIDè·å–æˆ–åˆ›å»ºç”¨æˆ·
func (r *PostgresUserRepository) GetOrCreateByOpenID(ctx context.Context, openID, unionID string) (*User, error) <span class="cov0" title="0">{
        // å…ˆå°è¯•è·å–ç”¨æˆ·
        user, err := r.GetByOpenID(ctx, openID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // å¦‚æœç”¨æˆ·å­˜åœ¨ï¼Œæ›´æ–°ç™»å½•æ—¶é—´å¹¶è¿”å›
        <span class="cov0" title="0">if user != nil </span><span class="cov0" title="0">{
                _ = r.UpdateLastLogin(ctx, user.ID)
                return user, nil
        }</span>

        // ç”¨æˆ·ä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°ç”¨æˆ·
        <span class="cov0" title="0">newUser := &amp;User{
                ID:       uuid.New().String(),
                OpenID:   openID,
                UnionID:  unionID,
                TenantID: "default",
                Username: fmt.Sprintf("user_%s", openID[:8]),
                Nickname: "å¾®ä¿¡ç”¨æˆ·",
                Role:     "user",
                Status:   "active",
        }

        err = r.Create(ctx, newUser)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return newUser, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package service

import (
        "context"
        "fmt"
)

// ChatService å¯¹è¯æœåŠ¡
type ChatService struct {
        algoService *AlgoService
}

func NewChatService(algoService *AlgoService) *ChatService <span class="cov0" title="0">{
        return &amp;ChatService{
                algoService: algoService,
        }
}</span>

// ChatRequest å¯¹è¯è¯·æ±‚
type ChatRequest struct {
        ConversationID string    `json:"conversation_id,omitempty"`
        Messages       []Message `json:"messages"`
        TopK           int       `json:"top_k,omitempty"`
        Temperature    float64   `json:"temperature,omitempty"`
}

// StreamChat æµå¼å¯¹è¯
func (s *ChatService) StreamChat(ctx context.Context, req *ChatRequest) (&lt;-chan *QueryResponse, error) <span class="cov0" title="0">{
        // è®¾ç½®é»˜è®¤å€¼
        if req.TopK == 0 </span><span class="cov0" title="0">{
                req.TopK = 5
        }</span>
        <span class="cov0" title="0">if req.Temperature == 0 </span><span class="cov0" title="0">{
                req.Temperature = 0.3
        }</span>

        // æ„å»ºç®—æ³•æœåŠ¡è¯·æ±‚
        <span class="cov0" title="0">algoReq := &amp;QueryRequest{
                Messages:    req.Messages,
                TopK:        req.TopK,
                Temperature: req.Temperature,
                MaxTokens:   1024,
        }

        // è°ƒç”¨ç®—æ³•æœåŠ¡
        responseCh, err := s.algoService.Query(ctx, algoReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query algo service: %w", err)
        }</span>

        <span class="cov0" title="0">return responseCh, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// æ¨¡å‹è·¯ç”±æœåŠ¡ - Goè¯­è¨€å®ç°
// ä¸Pythonæ¨¡å‹è·¯ç”±ç³»ç»Ÿé›†æˆï¼Œæä¾›HTTP APIæ¥å£

package service

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// ModelType æ¨¡å‹ç±»å‹æšä¸¾
type ModelType string

const (
        TextGeneration  ModelType = "text_generation"
        ChatCompletion  ModelType = "chat_completion"
        Embedding       ModelType = "embedding"
        ImageGeneration ModelType = "image_generation"
        SpeechToText    ModelType = "speech_to_text"
        TextToSpeech    ModelType = "text_to_speech"
        Vision          ModelType = "vision"
        CodeGeneration  ModelType = "code_generation"
)

// RoutingRequest è·¯ç”±è¯·æ±‚ç»“æ„
type RoutingRequest struct {
        ModelType   ModelType              `json:"model_type"`
        Prompt      string                 `json:"prompt"`
        MaxTokens   *int                   `json:"max_tokens,omitempty"`
        Temperature *float64               `json:"temperature,omitempty"`
        UserID      *string                `json:"user_id,omitempty"`
        SessionID   *string                `json:"session_id,omitempty"`
        Priority    int                    `json:"priority"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// RoutingResponse è·¯ç”±å“åº”ç»“æ„
type RoutingResponse struct {
        ModelID      string                 `json:"model_id"`
        Response     interface{}            `json:"response"`
        ResponseTime float64                `json:"response_time"`
        Cost         float64                `json:"cost"`
        TokensUsed   int                    `json:"tokens_used"`
        Success      bool                   `json:"success"`
        Error        *string                `json:"error,omitempty"`
        Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

// ModelMetrics æ¨¡å‹æŒ‡æ ‡
type ModelMetrics struct {
        ModelID            string  `json:"model_id"`
        TotalRequests      int     `json:"total_requests"`
        SuccessfulRequests int     `json:"successful_requests"`
        FailedRequests     int     `json:"failed_requests"`
        AvgResponseTime    float64 `json:"avg_response_time"`
        AvgCost            float64 `json:"avg_cost"`
        LastRequestTime    float64 `json:"last_request_time"`
        CurrentLoad        int     `json:"current_load"`
        ErrorRate          float64 `json:"error_rate"`
        Availability       float64 `json:"availability"`
}

// ModelStatus æ¨¡å‹çŠ¶æ€
type ModelStatus struct {
        Name            string  `json:"name"`
        Provider        string  `json:"provider"`
        Type            string  `json:"type"`
        Enabled         bool    `json:"enabled"`
        Priority        int     `json:"priority"`
        CurrentLoad     int     `json:"current_load"`
        Availability    float64 `json:"availability"`
        AvgResponseTime float64 `json:"avg_response_time"`
        ErrorRate       float64 `json:"error_rate"`
        TotalRequests   int     `json:"total_requests"`
}

// ModelRouterService æ¨¡å‹è·¯ç”±æœåŠ¡
type ModelRouterService struct {
        pythonServiceURL string
        httpClient       *http.Client
        metrics          map[string]*ModelMetrics
        metricsMutex     sync.RWMutex
        logger           *logrus.Logger
}

// NewModelRouterService åˆ›å»ºæ¨¡å‹è·¯ç”±æœåŠ¡å®ä¾‹
func NewModelRouterService(pythonServiceURL string, logger *logrus.Logger) *ModelRouterService <span class="cov0" title="0">{
        return &amp;ModelRouterService{
                pythonServiceURL: pythonServiceURL,
                httpClient: &amp;http.Client{
                        Timeout: 60 * time.Second,
                },
                metrics: make(map[string]*ModelMetrics),
                logger:  logger,
        }
}</span>

// RouteRequest è·¯ç”±è¯·æ±‚åˆ°æœ€é€‚åˆçš„æ¨¡å‹
func (s *ModelRouterService) RouteRequest(ctx context.Context, req *RoutingRequest) (*RoutingResponse, error) <span class="cov0" title="0">{
        startTime := time.Now()

        // åºåˆ—åŒ–è¯·æ±‚
        reqBody, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to marshal routing request")
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        // åˆ›å»ºHTTPè¯·æ±‚
        <span class="cov0" title="0">httpReq, err := http.NewRequestWithContext(ctx, "POST", s.pythonServiceURL+"/route", bytes.NewBuffer(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to create HTTP request")
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">httpReq.Header.Set("Content-Type", "application/json")

        // å‘é€è¯·æ±‚
        resp, err := s.httpClient.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to send routing request")
                return nil, fmt.Errorf("failed to send request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // è¯»å–å“åº”
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to read response body")
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                s.logger.WithField("status", resp.StatusCode).WithField("body", string(body)).Error("Routing request failed")
                return nil, fmt.Errorf("routing request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        // è§£æå“åº”
        <span class="cov0" title="0">var routingResp RoutingResponse
        if err := json.Unmarshal(body, &amp;routingResp); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to unmarshal routing response")
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        // è®°å½•æŒ‡æ ‡
        <span class="cov0" title="0">responseTime := time.Since(startTime).Seconds()
        s.updateMetrics(routingResp.ModelID, routingResp.Success, responseTime, routingResp.Cost)

        s.logger.WithFields(logrus.Fields{
                "model_id":      routingResp.ModelID,
                "success":       routingResp.Success,
                "response_time": responseTime,
                "cost":          routingResp.Cost,
                "tokens_used":   routingResp.TokensUsed,
        }).Info("Routing request completed")

        return &amp;routingResp, nil</span>
}

// GetModelMetrics è·å–æ¨¡å‹æŒ‡æ ‡
func (s *ModelRouterService) GetModelMetrics(ctx context.Context) (map[string]*ModelMetrics, error) <span class="cov0" title="0">{
        // ä»PythonæœåŠ¡è·å–æœ€æ–°æŒ‡æ ‡
        httpReq, err := http.NewRequestWithContext(ctx, "GET", s.pythonServiceURL+"/metrics", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create metrics request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := s.httpClient.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to get model metrics")
                return nil, fmt.Errorf("failed to get metrics: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("metrics request failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var metrics map[string]*ModelMetrics
        if err := json.NewDecoder(resp.Body).Decode(&amp;metrics); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode metrics: %w", err)
        }</span>

        // æ›´æ–°æœ¬åœ°ç¼“å­˜
        <span class="cov0" title="0">s.metricsMutex.Lock()
        s.metrics = metrics
        s.metricsMutex.Unlock()

        return metrics, nil</span>
}

// GetModelStatus è·å–æ¨¡å‹çŠ¶æ€
func (s *ModelRouterService) GetModelStatus(ctx context.Context) (map[string]*ModelStatus, error) <span class="cov0" title="0">{
        httpReq, err := http.NewRequestWithContext(ctx, "GET", s.pythonServiceURL+"/status", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create status request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := s.httpClient.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to get model status")
                return nil, fmt.Errorf("failed to get status: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("status request failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var status map[string]*ModelStatus
        if err := json.NewDecoder(resp.Body).Decode(&amp;status); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode status: %w", err)
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}

// HealthCheck å¥åº·æ£€æŸ¥
func (s *ModelRouterService) HealthCheck(ctx context.Context) error <span class="cov0" title="0">{
        httpReq, err := http.NewRequestWithContext(ctx, "GET", s.pythonServiceURL+"/health", nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create health check request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := s.httpClient.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("health check request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("health check failed with status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// updateMetrics æ›´æ–°æœ¬åœ°æŒ‡æ ‡ç¼“å­˜
func (s *ModelRouterService) updateMetrics(modelID string, success bool, responseTime, cost float64) <span class="cov0" title="0">{
        s.metricsMutex.Lock()
        defer s.metricsMutex.Unlock()

        metrics, exists := s.metrics[modelID]
        if !exists </span><span class="cov0" title="0">{
                metrics = &amp;ModelMetrics{
                        ModelID: modelID,
                }
                s.metrics[modelID] = metrics
        }</span>

        <span class="cov0" title="0">metrics.TotalRequests++
        metrics.LastRequestTime = float64(time.Now().Unix())

        if success </span><span class="cov0" title="0">{
                metrics.SuccessfulRequests++
        }</span> else<span class="cov0" title="0"> {
                metrics.FailedRequests++
        }</span>

        // æ›´æ–°å¹³å‡å“åº”æ—¶é—´å’Œæˆæœ¬
        <span class="cov0" title="0">if metrics.TotalRequests == 1 </span><span class="cov0" title="0">{
                metrics.AvgResponseTime = responseTime
                metrics.AvgCost = cost
        }</span> else<span class="cov0" title="0"> {
                alpha := 0.1 // æŒ‡æ•°ç§»åŠ¨å¹³å‡
                metrics.AvgResponseTime = (1-alpha)*metrics.AvgResponseTime + alpha*responseTime
                metrics.AvgCost = (1-alpha)*metrics.AvgCost + alpha*cost
        }</span>

        // æ›´æ–°é”™è¯¯ç‡å’Œå¯ç”¨æ€§
        <span class="cov0" title="0">metrics.ErrorRate = float64(metrics.FailedRequests) / float64(metrics.TotalRequests)
        metrics.Availability = float64(metrics.SuccessfulRequests) / float64(metrics.TotalRequests)</span>
}

// GetCachedMetrics è·å–ç¼“å­˜çš„æŒ‡æ ‡
func (s *ModelRouterService) GetCachedMetrics() map[string]*ModelMetrics <span class="cov0" title="0">{
        s.metricsMutex.RLock()
        defer s.metricsMutex.RUnlock()

        // åˆ›å»ºå‰¯æœ¬
        result := make(map[string]*ModelMetrics)
        for k, v := range s.metrics </span><span class="cov0" title="0">{
                result[k] = &amp;ModelMetrics{
                        ModelID:            v.ModelID,
                        TotalRequests:      v.TotalRequests,
                        SuccessfulRequests: v.SuccessfulRequests,
                        FailedRequests:     v.FailedRequests,
                        AvgResponseTime:    v.AvgResponseTime,
                        AvgCost:            v.AvgCost,
                        LastRequestTime:    v.LastRequestTime,
                        CurrentLoad:        v.CurrentLoad,
                        ErrorRate:          v.ErrorRate,
                        Availability:       v.Availability,
                }
        }</span>

        <span class="cov0" title="0">return result</span>
}

// ChatCompletion èŠå¤©å®Œæˆæ¥å£ï¼ˆä¾¿æ·æ–¹æ³•ï¼‰
func (s *ModelRouterService) ChatCompletion(ctx context.Context, prompt string, options ...func(*RoutingRequest)) (*RoutingResponse, error) <span class="cov0" title="0">{
        req := &amp;RoutingRequest{
                ModelType: ChatCompletion,
                Prompt:    prompt,
                Priority:  5, // é»˜è®¤ä¼˜å…ˆçº§
        }

        // åº”ç”¨é€‰é¡¹
        for _, option := range options </span><span class="cov0" title="0">{
                option(req)
        }</span>

        <span class="cov0" title="0">return s.RouteRequest(ctx, req)</span>
}

// WithMaxTokens è®¾ç½®æœ€å¤§tokenæ•°
func WithMaxTokens(maxTokens int) func(*RoutingRequest) <span class="cov0" title="0">{
        return func(req *RoutingRequest) </span><span class="cov0" title="0">{
                req.MaxTokens = &amp;maxTokens
        }</span>
}

// WithTemperature è®¾ç½®æ¸©åº¦å‚æ•°
func WithTemperature(temperature float64) func(*RoutingRequest) <span class="cov0" title="0">{
        return func(req *RoutingRequest) </span><span class="cov0" title="0">{
                req.Temperature = &amp;temperature
        }</span>
}

// WithUserID è®¾ç½®ç”¨æˆ·ID
func WithUserID(userID string) func(*RoutingRequest) <span class="cov0" title="0">{
        return func(req *RoutingRequest) </span><span class="cov0" title="0">{
                req.UserID = &amp;userID
        }</span>
}

// WithSessionID è®¾ç½®ä¼šè¯ID
func WithSessionID(sessionID string) func(*RoutingRequest) <span class="cov0" title="0">{
        return func(req *RoutingRequest) </span><span class="cov0" title="0">{
                req.SessionID = &amp;sessionID
        }</span>
}

// WithPriority è®¾ç½®ä¼˜å…ˆçº§
func WithPriority(priority int) func(*RoutingRequest) <span class="cov0" title="0">{
        return func(req *RoutingRequest) </span><span class="cov0" title="0">{
                req.Priority = priority
        }</span>
}

// WithMetadata è®¾ç½®å…ƒæ•°æ®
func WithMetadata(metadata map[string]interface{}) func(*RoutingRequest) <span class="cov0" title="0">{
        return func(req *RoutingRequest) </span><span class="cov0" title="0">{
                req.Metadata = metadata
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package service

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "time"

        "github.com/sirupsen/logrus"
)

type Services struct {
        AlgoService *AlgoService
        ChatService *ChatService
}

func NewServices() *Services <span class="cov0" title="0">{
        algoService := NewAlgoService()
        chatService := NewChatService(algoService)

        return &amp;Services{
                AlgoService: algoService,
                ChatService: chatService,
        }
}</span>

// AlgoService ç®—æ³•æœåŠ¡å®¢æˆ·ç«¯
type AlgoService struct {
        baseURL    string
        httpClient *http.Client
}

func NewAlgoService() *AlgoService <span class="cov0" title="0">{
        baseURL := os.Getenv("ALGO_SERVICE_URL")
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = "http://localhost:8000"
        }</span>

        <span class="cov0" title="0">return &amp;AlgoService{
                baseURL: baseURL,
                httpClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
        }</span>
}

// QueryRequest æŸ¥è¯¢è¯·æ±‚
type QueryRequest struct {
        Messages    []Message `json:"messages"`
        TopK        int       `json:"top_k,omitempty"`
        Temperature float64   `json:"temperature,omitempty"`
        MaxTokens   int       `json:"max_tokens,omitempty"`
}

// Message æ¶ˆæ¯ç»“æ„
type Message struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

// QueryResponse æŸ¥è¯¢å“åº”
type QueryResponse struct {
        Type    string      `json:"type"`
        Content string      `json:"content"`
        Refs    []Reference `json:"refs,omitempty"`
}

// Reference å¼•ç”¨ä¿¡æ¯
type Reference struct {
        ChunkID string  `json:"chunk_id"`
        Source  string  `json:"source"`
        Score   float64 `json:"score"`
}

// Query è°ƒç”¨ç®—æ³•æœåŠ¡æŸ¥è¯¢
func (s *AlgoService) Query(ctx context.Context, req *QueryRequest) (&lt;-chan *QueryResponse, error) <span class="cov0" title="0">{
        reqBody, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">httpReq, err := http.NewRequestWithContext(ctx, "POST", s.baseURL+"/query", bytes.NewReader(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create request: %w", err)
        }</span>

        <span class="cov0" title="0">httpReq.Header.Set("Content-Type", "application/json")
        httpReq.Header.Set("Accept", "text/event-stream")

        resp, err := s.httpClient.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("do request: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                resp.Body.Close()
                return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">ch := make(chan *QueryResponse, 10)

        go func() </span><span class="cov0" title="0">{
                defer resp.Body.Close()
                defer close(ch)

                decoder := json.NewDecoder(resp.Body)
                for </span><span class="cov0" title="0">{
                        var response QueryResponse
                        if err := decoder.Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">logrus.WithError(err).Error("Failed to decode response")
                                break</span>
                        }

                        <span class="cov0" title="0">select </span>{
                        case ch &lt;- &amp;response:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">return ch, nil</span>
}

// IngestRequest å…¥åº“è¯·æ±‚
type IngestRequest struct {
        DatasetID string   `json:"dataset_id"`
        Files     []string `json:"files,omitempty"`
        URLs      []string `json:"urls,omitempty"`
        ChunkSize int      `json:"chunk_size,omitempty"`
}

// IngestResponse å…¥åº“å“åº”
type IngestResponse struct {
        TaskID string `json:"task_id"`
}

// VoiceQueryRequest è¯­éŸ³æŸ¥è¯¢è¯·æ±‚
type VoiceQueryRequest struct {
        ConversationID string `json:"conversation_id"`
        AudioChunk     string `json:"audio_chunk"`
        Seq            int    `json:"seq"`
        Codec          string `json:"codec"`
        SampleRate     int    `json:"sample_rate"`
}

// VoiceQueryResponse è¯­éŸ³æŸ¥è¯¢å“åº”
type VoiceQueryResponse struct {
        Type  string      `json:"type"`
        Seq   int         `json:"seq,omitempty"`
        Text  string      `json:"text,omitempty"`
        PCM   string      `json:"pcm,omitempty"`
        Refs  []Reference `json:"refs,omitempty"`
        Error string      `json:"error,omitempty"`
}

// Ingest è°ƒç”¨ç®—æ³•æœåŠ¡å…¥åº“
func (s *AlgoService) Ingest(ctx context.Context, req *IngestRequest) (*IngestResponse, error) <span class="cov0" title="0">{
        reqBody, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">httpReq, err := http.NewRequestWithContext(ctx, "POST", s.baseURL+"/ingest", bytes.NewReader(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create request: %w", err)
        }</span>

        <span class="cov0" title="0">httpReq.Header.Set("Content-Type", "application/json")

        resp, err := s.httpClient.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("do request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var response IngestResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;response, nil</span>
}

// VoiceQuery è°ƒç”¨ç®—æ³•æœåŠ¡è¯­éŸ³æŸ¥è¯¢
func (s *AlgoService) VoiceQuery(ctx context.Context, req *VoiceQueryRequest) (&lt;-chan *VoiceQueryResponse, error) <span class="cov0" title="0">{
        reqBody, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">httpReq, err := http.NewRequestWithContext(ctx, "POST", s.baseURL+"/voice/query", bytes.NewReader(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create request: %w", err)
        }</span>

        <span class="cov0" title="0">httpReq.Header.Set("Content-Type", "application/json")
        httpReq.Header.Set("Accept", "text/event-stream")

        resp, err := s.httpClient.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("do request: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                resp.Body.Close()
                return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">ch := make(chan *VoiceQueryResponse, 10)

        go func() </span><span class="cov0" title="0">{
                defer resp.Body.Close()
                defer close(ch)

                decoder := json.NewDecoder(resp.Body)
                for </span><span class="cov0" title="0">{
                        var response VoiceQueryResponse
                        if err := decoder.Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">logrus.WithError(err).Error("Failed to decode voice response")
                                break</span>
                        }

                        <span class="cov0" title="0">select </span>{
                        case ch &lt;- &amp;response:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">return ch, nil</span>
}

// CancelRequest å–æ¶ˆè¯·æ±‚
func (s *AlgoService) CancelRequest(ctx context.Context, requestID string) error <span class="cov0" title="0">{
        httpReq, err := http.NewRequestWithContext(ctx, "POST", s.baseURL+"/cancel", nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create request: %w", err)
        }</span>

        <span class="cov0" title="0">httpReq.Header.Set("X-Request-ID", requestID)

        resp, err := s.httpClient.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("do request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package cache

import (
        "context"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/sirupsen/logrus"

        "voicehelper/backend/pkg/config"
)

// RedisClient Rediså®¢æˆ·ç«¯
type RedisClient struct {
        Client *redis.Client
}

// NewRedisClient åˆ›å»ºRediså®¢æˆ·ç«¯
func NewRedisClient(cfg config.RedisConfig) (*RedisClient, error) <span class="cov0" title="0">{
        rdb := redis.NewClient(&amp;redis.Options{
                Addr:     fmt.Sprintf("%s:%d", cfg.Host, cfg.Port),
                Password: cfg.Password,
                DB:       cfg.Database,

                PoolSize:     10,
                MinIdleConns: 5,
                MaxRetries:   3,

                DialTimeout:  5 * time.Second,
                ReadTimeout:  3 * time.Second,
                WriteTimeout: 3 * time.Second,

                PoolTimeout: 4 * time.Second,
        })

        // æµ‹è¯•è¿æ¥
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := rdb.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping Redis: %v", err)
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "host": cfg.Host,
                "port": cfg.Port,
                "db":   cfg.Database,
        }).Info("Connected to Redis")

        return &amp;RedisClient{Client: rdb}, nil</span>
}

// Close å…³é—­Redisè¿æ¥
func (r *RedisClient) Close() error <span class="cov0" title="0">{
        if r.Client != nil </span><span class="cov0" title="0">{
                return r.Client.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Health æ£€æŸ¥Rediså¥åº·çŠ¶æ€
func (r *RedisClient) Health() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
        defer cancel()

        return r.Client.Ping(ctx).Err()
}</span>

// Set è®¾ç½®é”®å€¼å¯¹
func (r *RedisClient) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov0" title="0">{
        return r.Client.Set(ctx, key, value, expiration).Err()
}</span>

// Get è·å–å€¼
func (r *RedisClient) Get(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        return r.Client.Get(ctx, key).Result()
}</span>

// Del åˆ é™¤é”®
func (r *RedisClient) Del(ctx context.Context, keys ...string) error <span class="cov0" title="0">{
        return r.Client.Del(ctx, keys...).Err()
}</span>

// Exists æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
func (r *RedisClient) Exists(ctx context.Context, keys ...string) (int64, error) <span class="cov0" title="0">{
        return r.Client.Exists(ctx, keys...).Result()
}</span>

// Expire è®¾ç½®è¿‡æœŸæ—¶é—´
func (r *RedisClient) Expire(ctx context.Context, key string, expiration time.Duration) error <span class="cov0" title="0">{
        return r.Client.Expire(ctx, key, expiration).Err()
}</span>

// Incr é€’å¢
func (r *RedisClient) Incr(ctx context.Context, key string) (int64, error) <span class="cov0" title="0">{
        return r.Client.Incr(ctx, key).Result()
}</span>

// IncrBy æŒ‰æŒ‡å®šå€¼é€’å¢
func (r *RedisClient) IncrBy(ctx context.Context, key string, value int64) (int64, error) <span class="cov0" title="0">{
        return r.Client.IncrBy(ctx, key, value).Result()
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package config

import (
        "os"
        "strconv"
        "strings"
)

// Config åº”ç”¨é…ç½®
type Config struct {
        Environment string `json:"environment"`
        Version     string `json:"version"`
        Port        int    `json:"port"`
        LogLevel    string `json:"log_level"`

        Server    ServerConfig    `json:"server"`
        Database  DatabaseConfig  `json:"database"`
        Redis     RedisConfig     `json:"redis"`
        JWT       JWTConfig       `json:"jwt"`
        Auth      AuthConfig      `json:"auth"`
        SSE       SSEConfig       `json:"sse"`
        WebSocket WebSocketConfig `json:"websocket"`
        Services  ServicesConfig  `json:"services"`
}

// ServerConfig æœåŠ¡å™¨é…ç½®
type ServerConfig struct {
        ReadTimeout  int `json:"read_timeout"`
        WriteTimeout int `json:"write_timeout"`
        IdleTimeout  int `json:"idle_timeout"`
}

// DatabaseConfig æ•°æ®åº“é…ç½®
type DatabaseConfig struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Database string `json:"database"`
        Username string `json:"username"`
        Password string `json:"password"`
        SSLMode  string `json:"ssl_mode"`
}

// RedisConfig Redisé…ç½®
type RedisConfig struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        Password string `json:"password"`
        Database int    `json:"database"`
}

// JWTConfig JWTé…ç½®
type JWTConfig struct {
        Secret     string `json:"secret"`
        ExpireHour int    `json:"expire_hour"`
}

// AuthConfig è®¤è¯é…ç½®
type AuthConfig struct {
        SkipPaths []string `json:"skip_paths"`
}

// SSEConfig SSEé…ç½®
type SSEConfig struct {
        MaxStreams        int `json:"max_streams"`
        EventQueueSize    int `json:"event_queue_size"`
        KeepAliveInterval int `json:"keep_alive_interval"`
        StreamTimeout     int `json:"stream_timeout"`
        MaxEventSize      int `json:"max_event_size"`
}

// WebSocketConfig WebSocketé…ç½®
type WebSocketConfig struct {
        MaxConnections    int `json:"max_connections"`
        SendQueueSize     int `json:"send_queue_size"`
        HeartbeatInterval int `json:"heartbeat_interval"`
        HeartbeatTimeout  int `json:"heartbeat_timeout"`
        ThrottleLimit     int `json:"throttle_limit"`
        MaxFrameSize      int `json:"max_frame_size"`
}

// ServicesConfig æœåŠ¡é…ç½®
type ServicesConfig struct {
        AlgoServiceURL  string `json:"algo_service_url"`
        VoiceServiceURL string `json:"voice_service_url"`
}

// Load åŠ è½½é…ç½®
func Load() (*Config, error) <span class="cov0" title="0">{
        config := &amp;Config{
                Environment: getEnv("ENVIRONMENT", "development"),
                Version:     getEnv("VERSION", "1.0.0"),
                Port:        getEnvInt("PORT", 8080),
                LogLevel:    getEnv("LOG_LEVEL", "info"),

                Server: ServerConfig{
                        ReadTimeout:  getEnvInt("SERVER_READ_TIMEOUT", 30),
                        WriteTimeout: getEnvInt("SERVER_WRITE_TIMEOUT", 30),
                        IdleTimeout:  getEnvInt("SERVER_IDLE_TIMEOUT", 120),
                },

                Database: DatabaseConfig{
                        Host:     getEnv("POSTGRES_HOST", "localhost"),
                        Port:     getEnvInt("POSTGRES_PORT", 5432),
                        Database: getEnv("POSTGRES_DB", "voicehelper"),
                        Username: getEnv("POSTGRES_USER", "voicehelper"),
                        Password: getEnv("POSTGRES_PASSWORD", "voicehelper123"),
                        SSLMode:  getEnv("POSTGRES_SSL_MODE", "disable"),
                },

                Redis: RedisConfig{
                        Host:     getEnv("REDIS_HOST", "localhost"),
                        Port:     getEnvInt("REDIS_PORT", 6379),
                        Password: getEnv("REDIS_PASSWORD", "redis123"),
                        Database: getEnvInt("REDIS_DB", 0),
                },

                JWT: JWTConfig{
                        Secret:     getEnv("JWT_SECRET", "your-secret-key"),
                        ExpireHour: getEnvInt("JWT_EXPIRE_HOUR", 24),
                },

                Auth: AuthConfig{
                        SkipPaths: getEnvStringSlice("AUTH_SKIP_PATHS", []string{
                                "/health",
                                "/metrics",
                                "/api/v1/auth/",
                        }),
                },

                SSE: SSEConfig{
                        MaxStreams:        getEnvInt("SSE_MAX_STREAMS", 1000),
                        EventQueueSize:    getEnvInt("SSE_EVENT_QUEUE_SIZE", 100),
                        KeepAliveInterval: getEnvInt("SSE_KEEP_ALIVE_INTERVAL", 30),
                        StreamTimeout:     getEnvInt("SSE_STREAM_TIMEOUT", 10),
                        MaxEventSize:      getEnvInt("SSE_MAX_EVENT_SIZE", 65536),
                },

                WebSocket: WebSocketConfig{
                        MaxConnections:    getEnvInt("WS_MAX_CONNECTIONS", 1000),
                        SendQueueSize:     getEnvInt("WS_SEND_QUEUE_SIZE", 100),
                        HeartbeatInterval: getEnvInt("WS_HEARTBEAT_INTERVAL", 30),
                        HeartbeatTimeout:  getEnvInt("WS_HEARTBEAT_TIMEOUT", 60),
                        ThrottleLimit:     getEnvInt("WS_THROTTLE_LIMIT", 50),
                        MaxFrameSize:      getEnvInt("WS_MAX_FRAME_SIZE", 8192),
                },

                Services: ServicesConfig{
                        AlgoServiceURL:  getEnv("ALGO_SERVICE_URL", "http://localhost:8000"),
                        VoiceServiceURL: getEnv("VOICE_SERVICE_URL", "http://localhost:8001"),
                },
        }

        return config, nil
}</span>

// è¾…åŠ©å‡½æ•°

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvStringSlice(key string, defaultValue []string) []string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return strings.Split(value, ",")
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package database

import (
        "database/sql"
        "log"
        "time"
)

// OptimizedConnectionPool ä¼˜åŒ–çš„æ•°æ®åº“è¿æ¥æ± é…ç½®
type OptimizedConnectionPool struct {
        DB *sql.DB
}

// NewOptimizedPool åˆ›å»ºä¼˜åŒ–çš„è¿æ¥æ± 
func NewOptimizedPool(databaseURL string) (*OptimizedConnectionPool, error) <span class="cov0" title="0">{
        db, err := sql.Open("postgres", databaseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // ä¼˜åŒ–è¿æ¥æ± å‚æ•° - åŸºäºæ€§èƒ½æµ‹è¯•ç»“æœ
        // å‡å°‘æœ€å¤§è¿æ¥æ•°ä»¥é™ä½å†…å­˜ä½¿ç”¨
        <span class="cov0" title="0">db.SetMaxOpenConns(15) // ä»25é™åˆ°15
        db.SetMaxIdleConns(5)  // ä»10é™åˆ°5

        // å‡å°‘è¿æ¥ç”Ÿå­˜æ—¶é—´ä»¥é‡Šæ”¾èµ„æº
        db.SetConnMaxLifetime(3 * time.Minute)  // ä»5åˆ†é’Ÿé™åˆ°3åˆ†é’Ÿ
        db.SetConnMaxIdleTime(30 * time.Second) // æ–°å¢ç©ºé—²è¶…æ—¶

        // éªŒè¯è¿æ¥
        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Println("æ•°æ®åº“è¿æ¥æ± å·²ä¼˜åŒ–é…ç½®")
        log.Printf("æœ€å¤§è¿æ¥æ•°: %d", 15)
        log.Printf("æœ€å¤§ç©ºé—²è¿æ¥æ•°: %d", 5)
        log.Printf("è¿æ¥æœ€å¤§ç”Ÿå­˜æ—¶é—´: %v", 3*time.Minute)
        log.Printf("è¿æ¥æœ€å¤§ç©ºé—²æ—¶é—´: %v", 30*time.Second)

        return &amp;OptimizedConnectionPool{DB: db}, nil</span>
}

// GetStats è·å–è¿æ¥æ± ç»Ÿè®¡ä¿¡æ¯
func (pool *OptimizedConnectionPool) GetStats() sql.DBStats <span class="cov0" title="0">{
        return pool.DB.Stats()
}</span>

// LogStats è®°å½•è¿æ¥æ± ç»Ÿè®¡ä¿¡æ¯
func (pool *OptimizedConnectionPool) LogStats() <span class="cov0" title="0">{
        stats := pool.GetStats()
        log.Printf("è¿æ¥æ± ç»Ÿè®¡ - æ‰“å¼€è¿æ¥æ•°: %d, ä½¿ç”¨ä¸­: %d, ç©ºé—²: %d",
                stats.OpenConnections, stats.InUse, stats.Idle)
}</span>

// Close å…³é—­è¿æ¥æ± 
func (pool *OptimizedConnectionPool) Close() error <span class="cov0" title="0">{
        return pool.DB.Close()
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "time"

        _ "github.com/lib/pq"
        "github.com/sirupsen/logrus"

        "voicehelper/backend/pkg/config"
)

// PostgresConnection PostgreSQLè¿æ¥
type PostgresConnection struct {
        DB *sql.DB
}

// NewPostgresConnection åˆ›å»ºPostgreSQLè¿æ¥
func NewPostgresConnection(cfg config.DatabaseConfig) (*PostgresConnection, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf(
                "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                cfg.Host, cfg.Port, cfg.Username, cfg.Password, cfg.Database, cfg.SSLMode,
        )

        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %v", err)
        }</span>

        // é…ç½®è¿æ¥æ± 
        <span class="cov0" title="0">db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(5)
        db.SetConnMaxLifetime(5 * time.Minute)

        // æµ‹è¯•è¿æ¥
        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ping database: %v", err)
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "host":     cfg.Host,
                "port":     cfg.Port,
                "database": cfg.Database,
        }).Info("Connected to PostgreSQL database")

        return &amp;PostgresConnection{DB: db}, nil</span>
}

// Close å…³é—­æ•°æ®åº“è¿æ¥
func (p *PostgresConnection) Close() error <span class="cov0" title="0">{
        if p.DB != nil </span><span class="cov0" title="0">{
                return p.DB.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Health æ£€æŸ¥æ•°æ®åº“å¥åº·çŠ¶æ€
func (p *PostgresConnection) Health() error <span class="cov0" title="0">{
        return p.DB.Ping()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package discovery

import (
        "fmt"
        "math/rand"
        "sort"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// LoadBalancer handles load balancing across discovered services
type LoadBalancer struct {
        registry *ServiceRegistry
        strategy LoadBalancingStrategy
        logger   *logrus.Logger
        mu       sync.RWMutex

        // Circuit breaker state
        circuitBreakers map[string]*CircuitBreaker
}

// LoadBalancingStrategy defines different load balancing strategies
type LoadBalancingStrategy string

const (
        StrategyRoundRobin     LoadBalancingStrategy = "round_robin"
        StrategyWeightedRandom LoadBalancingStrategy = "weighted_random"
        StrategyLeastLatency   LoadBalancingStrategy = "least_latency"
        StrategyHealthyFirst   LoadBalancingStrategy = "healthy_first"
        StrategyPriority       LoadBalancingStrategy = "priority"
)

// CircuitBreaker implements circuit breaker pattern for services
type CircuitBreaker struct {
        ServiceID        string
        FailureCount     int
        LastFailureTime  time.Time
        State            CircuitState
        FailureThreshold int
        RecoveryTimeout  time.Duration
        mu               sync.RWMutex
}

// CircuitState represents the state of a circuit breaker
type CircuitState string

const (
        CircuitClosed   CircuitState = "closed"    // Normal operation
        CircuitOpen     CircuitState = "open"      // Failing, reject requests
        CircuitHalfOpen CircuitState = "half_open" // Testing recovery
)

// ServiceSelection represents a selected service for load balancing
type ServiceSelection struct {
        Service *RegisteredService `json:"service"`
        Reason  string             `json:"reason"`
        Score   float64            `json:"score,omitempty"`
}

// LoadBalancerConfig contains configuration for the load balancer
type LoadBalancerConfig struct {
        Strategy             LoadBalancingStrategy
        FailureThreshold     int
        RecoveryTimeout      time.Duration
        EnableCircuitBreaker bool
}

// NewLoadBalancer creates a new load balancer
func NewLoadBalancer(registry *ServiceRegistry, config *LoadBalancerConfig) *LoadBalancer <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = &amp;LoadBalancerConfig{
                        Strategy:             StrategyHealthyFirst,
                        FailureThreshold:     5,
                        RecoveryTimeout:      30 * time.Second,
                        EnableCircuitBreaker: true,
                }
        }</span>

        <span class="cov0" title="0">return &amp;LoadBalancer{
                registry:        registry,
                strategy:        config.Strategy,
                logger:          logrus.New(),
                circuitBreakers: make(map[string]*CircuitBreaker),
        }</span>
}

// SelectService selects a service based on the load balancing strategy
func (lb *LoadBalancer) SelectService(category string, excludeServices []string) (*ServiceSelection, error) <span class="cov0" title="0">{
        // Get available services
        var services []*RegisteredService
        if category != "" </span><span class="cov0" title="0">{
                services = lb.registry.ListServicesByCategory(category)
        }</span> else<span class="cov0" title="0"> {
                services = lb.registry.ListServices()
        }</span>

        <span class="cov0" title="0">if len(services) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no services available")
        }</span>

        // Filter out excluded services and unhealthy services
        <span class="cov0" title="0">availableServices := lb.filterAvailableServices(services, excludeServices)
        if len(availableServices) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no available services after filtering")
        }</span>

        // Apply load balancing strategy
        <span class="cov0" title="0">switch lb.strategy </span>{
        case StrategyRoundRobin:<span class="cov0" title="0">
                return lb.selectRoundRobin(availableServices)</span>
        case StrategyWeightedRandom:<span class="cov0" title="0">
                return lb.selectWeightedRandom(availableServices)</span>
        case StrategyLeastLatency:<span class="cov0" title="0">
                return lb.selectLeastLatency(availableServices)</span>
        case StrategyHealthyFirst:<span class="cov0" title="0">
                return lb.selectHealthyFirst(availableServices)</span>
        case StrategyPriority:<span class="cov0" title="0">
                return lb.selectByPriority(availableServices)</span>
        default:<span class="cov0" title="0">
                return lb.selectHealthyFirst(availableServices)</span>
        }
}

// SelectMultipleServices selects multiple services for redundancy
func (lb *LoadBalancer) SelectMultipleServices(category string, count int, excludeServices []string) ([]*ServiceSelection, error) <span class="cov0" title="0">{
        if count &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("count must be positive")
        }</span>

        <span class="cov0" title="0">var selections []*ServiceSelection
        excluded := make([]string, len(excludeServices))
        copy(excluded, excludeServices)

        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                selection, err := lb.SelectService(category, excluded)
                if err != nil </span><span class="cov0" title="0">{
                        if len(selections) == 0 </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">break</span> // Return what we have
                }

                <span class="cov0" title="0">selections = append(selections, selection)
                excluded = append(excluded, selection.Service.ID)</span>
        }

        <span class="cov0" title="0">return selections, nil</span>
}

// filterAvailableServices filters services based on health and circuit breaker state
func (lb *LoadBalancer) filterAvailableServices(services []*RegisteredService, excludeServices []string) []*RegisteredService <span class="cov0" title="0">{
        var available []*RegisteredService

        excludeMap := make(map[string]bool)
        for _, id := range excludeServices </span><span class="cov0" title="0">{
                excludeMap[id] = true
        }</span>

        <span class="cov0" title="0">for _, service := range services </span><span class="cov0" title="0">{
                // Skip excluded services
                if excludeMap[service.ID] </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip inactive services
                <span class="cov0" title="0">if service.Status != StatusActive </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check circuit breaker
                <span class="cov0" title="0">if lb.isCircuitOpen(service.ID) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">available = append(available, service)</span>
        }

        <span class="cov0" title="0">return available</span>
}

// selectRoundRobin implements round-robin selection
func (lb *LoadBalancer) selectRoundRobin(services []*RegisteredService) (*ServiceSelection, error) <span class="cov0" title="0">{
        if len(services) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no services available")
        }</span>

        // Simple round-robin based on current time
        <span class="cov0" title="0">index := int(time.Now().UnixNano()) % len(services)

        return &amp;ServiceSelection{
                Service: services[index],
                Reason:  "round_robin",
        }, nil</span>
}

// selectWeightedRandom implements weighted random selection
func (lb *LoadBalancer) selectWeightedRandom(services []*RegisteredService) (*ServiceSelection, error) <span class="cov0" title="0">{
        if len(services) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no services available")
        }</span>

        // Calculate total weight
        <span class="cov0" title="0">totalWeight := 0
        for _, service := range services </span><span class="cov0" title="0">{
                weight := service.Weight
                if weight &lt;= 0 </span><span class="cov0" title="0">{
                        weight = 1
                }</span>
                <span class="cov0" title="0">totalWeight += weight</span>
        }

        // Select random point
        <span class="cov0" title="0">randomPoint := rand.Intn(totalWeight)
        currentWeight := 0

        for _, service := range services </span><span class="cov0" title="0">{
                weight := service.Weight
                if weight &lt;= 0 </span><span class="cov0" title="0">{
                        weight = 1
                }</span>
                <span class="cov0" title="0">currentWeight += weight

                if randomPoint &lt; currentWeight </span><span class="cov0" title="0">{
                        return &amp;ServiceSelection{
                                Service: service,
                                Reason:  "weighted_random",
                                Score:   float64(weight) / float64(totalWeight),
                        }, nil
                }</span>
        }

        // Fallback to first service
        <span class="cov0" title="0">return &amp;ServiceSelection{
                Service: services[0],
                Reason:  "weighted_random_fallback",
        }, nil</span>
}

// selectLeastLatency selects service with lowest average latency
func (lb *LoadBalancer) selectLeastLatency(services []*RegisteredService) (*ServiceSelection, error) <span class="cov0" title="0">{
        if len(services) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no services available")
        }</span>

        <span class="cov0" title="0">var bestService *RegisteredService
        var bestLatency time.Duration = time.Hour // Start with high value

        for _, service := range services </span><span class="cov0" title="0">{
                latency := service.AverageLatency
                if latency == 0 </span><span class="cov0" title="0">{
                        latency = 100 * time.Millisecond // Default for new services
                }</span>

                <span class="cov0" title="0">if latency &lt; bestLatency </span><span class="cov0" title="0">{
                        bestLatency = latency
                        bestService = service
                }</span>
        }

        <span class="cov0" title="0">if bestService == nil </span><span class="cov0" title="0">{
                bestService = services[0]
        }</span>

        <span class="cov0" title="0">return &amp;ServiceSelection{
                Service: bestService,
                Reason:  "least_latency",
                Score:   float64(bestLatency.Milliseconds()),
        }, nil</span>
}

// selectHealthyFirst prioritizes healthy services
func (lb *LoadBalancer) selectHealthyFirst(services []*RegisteredService) (*ServiceSelection, error) <span class="cov0" title="0">{
        if len(services) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no services available")
        }</span>

        // Separate healthy and unhealthy services
        <span class="cov0" title="0">var healthyServices []*RegisteredService
        var unhealthyServices []*RegisteredService

        for _, service := range services </span><span class="cov0" title="0">{
                if service.HealthStatus == HealthHealthy </span><span class="cov0" title="0">{
                        healthyServices = append(healthyServices, service)
                }</span> else<span class="cov0" title="0"> {
                        unhealthyServices = append(unhealthyServices, service)
                }</span>
        }

        // Prefer healthy services
        <span class="cov0" title="0">if len(healthyServices) &gt; 0 </span><span class="cov0" title="0">{
                // Use weighted random among healthy services
                selection, err := lb.selectWeightedRandom(healthyServices)
                if err == nil </span><span class="cov0" title="0">{
                        selection.Reason = "healthy_first"
                        return selection, nil
                }</span>
        }

        // Fallback to unhealthy services if no healthy ones
        <span class="cov0" title="0">if len(unhealthyServices) &gt; 0 </span><span class="cov0" title="0">{
                selection, err := lb.selectWeightedRandom(unhealthyServices)
                if err == nil </span><span class="cov0" title="0">{
                        selection.Reason = "healthy_first_fallback"
                        return selection, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no suitable services found")</span>
}

// selectByPriority selects service based on priority
func (lb *LoadBalancer) selectByPriority(services []*RegisteredService) (*ServiceSelection, error) <span class="cov0" title="0">{
        if len(services) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no services available")
        }</span>

        // Sort by priority (higher priority first)
        <span class="cov0" title="0">sort.Slice(services, func(i, j int) bool </span><span class="cov0" title="0">{
                return services[i].Priority &gt; services[j].Priority
        }</span>)

        // Group services by priority
        <span class="cov0" title="0">highestPriority := services[0].Priority
        var highPriorityServices []*RegisteredService

        for _, service := range services </span><span class="cov0" title="0">{
                if service.Priority == highestPriority </span><span class="cov0" title="0">{
                        highPriorityServices = append(highPriorityServices, service)
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }

        // Use weighted random among highest priority services
        <span class="cov0" title="0">selection, err := lb.selectWeightedRandom(highPriorityServices)
        if err == nil </span><span class="cov0" title="0">{
                selection.Reason = "priority"
                return selection, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("no suitable services found")</span>
}

// RecordSuccess records a successful request for circuit breaker
func (lb *LoadBalancer) RecordSuccess(serviceID string) <span class="cov0" title="0">{
        lb.mu.Lock()
        defer lb.mu.Unlock()

        if cb, exists := lb.circuitBreakers[serviceID]; exists </span><span class="cov0" title="0">{
                cb.mu.Lock()
                cb.FailureCount = 0
                if cb.State == CircuitHalfOpen </span><span class="cov0" title="0">{
                        cb.State = CircuitClosed
                }</span>
                <span class="cov0" title="0">cb.mu.Unlock()</span>
        }
}

// RecordFailure records a failed request for circuit breaker
func (lb *LoadBalancer) RecordFailure(serviceID string) <span class="cov0" title="0">{
        lb.mu.Lock()
        defer lb.mu.Unlock()

        cb, exists := lb.circuitBreakers[serviceID]
        if !exists </span><span class="cov0" title="0">{
                cb = &amp;CircuitBreaker{
                        ServiceID:        serviceID,
                        FailureThreshold: 5,
                        RecoveryTimeout:  30 * time.Second,
                        State:            CircuitClosed,
                }
                lb.circuitBreakers[serviceID] = cb
        }</span>

        <span class="cov0" title="0">cb.mu.Lock()
        defer cb.mu.Unlock()

        cb.FailureCount++
        cb.LastFailureTime = time.Now()

        if cb.FailureCount &gt;= cb.FailureThreshold &amp;&amp; cb.State == CircuitClosed </span><span class="cov0" title="0">{
                cb.State = CircuitOpen
                lb.logger.Warnf("Circuit breaker opened for service %s", serviceID)
        }</span>
}

// isCircuitOpen checks if circuit breaker is open for a service
func (lb *LoadBalancer) isCircuitOpen(serviceID string) bool <span class="cov0" title="0">{
        lb.mu.RLock()
        defer lb.mu.RUnlock()

        cb, exists := lb.circuitBreakers[serviceID]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">cb.mu.RLock()
        defer cb.mu.RUnlock()

        switch cb.State </span>{
        case CircuitClosed:<span class="cov0" title="0">
                return false</span>
        case CircuitOpen:<span class="cov0" title="0">
                // Check if recovery timeout has passed
                if time.Since(cb.LastFailureTime) &gt; cb.RecoveryTimeout </span><span class="cov0" title="0">{
                        cb.State = CircuitHalfOpen
                        lb.logger.Infof("Circuit breaker half-opened for service %s", serviceID)
                        return false
                }</span>
                <span class="cov0" title="0">return true</span>
        case CircuitHalfOpen:<span class="cov0" title="0">
                return false</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// GetCircuitBreakerStatus returns the status of all circuit breakers
func (lb *LoadBalancer) GetCircuitBreakerStatus() map[string]CircuitState <span class="cov0" title="0">{
        lb.mu.RLock()
        defer lb.mu.RUnlock()

        status := make(map[string]CircuitState)
        for serviceID, cb := range lb.circuitBreakers </span><span class="cov0" title="0">{
                cb.mu.RLock()
                status[serviceID] = cb.State
                cb.mu.RUnlock()
        }</span>

        <span class="cov0" title="0">return status</span>
}

// ResetCircuitBreaker resets the circuit breaker for a service
func (lb *LoadBalancer) ResetCircuitBreaker(serviceID string) <span class="cov0" title="0">{
        lb.mu.Lock()
        defer lb.mu.Unlock()

        if cb, exists := lb.circuitBreakers[serviceID]; exists </span><span class="cov0" title="0">{
                cb.mu.Lock()
                cb.FailureCount = 0
                cb.State = CircuitClosed
                cb.mu.Unlock()
                lb.logger.Infof("Circuit breaker reset for service %s", serviceID)
        }</span>
}

// GetLoadBalancingStats returns statistics about load balancing
func (lb *LoadBalancer) GetLoadBalancingStats() map[string]interface{} <span class="cov0" title="0">{
        lb.mu.RLock()
        defer lb.mu.RUnlock()

        stats := map[string]interface{}{
                "strategy":         lb.strategy,
                "circuit_breakers": len(lb.circuitBreakers),
        }

        // Circuit breaker stats
        circuitStats := make(map[string]interface{})
        for serviceID, cb := range lb.circuitBreakers </span><span class="cov0" title="0">{
                cb.mu.RLock()
                circuitStats[serviceID] = map[string]interface{}{
                        "state":         cb.State,
                        "failure_count": cb.FailureCount,
                        "last_failure":  cb.LastFailureTime,
                }
                cb.mu.RUnlock()
        }</span>
        <span class="cov0" title="0">stats["circuit_breaker_status"] = circuitStats

        return stats</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package discovery

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// ServiceDiscovery handles automatic discovery of service capabilities
type ServiceDiscovery struct {
        client *http.Client
        logger *logrus.Logger
        mu     sync.RWMutex
        cache  map[string]*DiscoveryResult
}

// DiscoveryResult contains the discovered service information
type DiscoveryResult struct {
        ServiceURL   string                 `json:"service_url"`
        ServiceName  string                 `json:"service_name"`
        Version      string                 `json:"version"`
        Description  string                 `json:"description"`
        Capabilities []string               `json:"capabilities"`
        Endpoints    []EndpointInfo         `json:"endpoints"`
        HealthCheck  *HealthCheckInfo       `json:"health_check,omitempty"`
        Metadata     map[string]interface{} `json:"metadata"`
        DiscoveredAt time.Time              `json:"discovered_at"`
        LastChecked  time.Time              `json:"last_checked"`
        Status       string                 `json:"status"`
}

// EndpointInfo contains information about a discovered endpoint
type EndpointInfo struct {
        Path        string                 `json:"path"`
        Method      string                 `json:"method"`
        Description string                 `json:"description"`
        Parameters  []ParameterInfo        `json:"parameters,omitempty"`
        Responses   []ResponseInfo         `json:"responses,omitempty"`
        Tags        []string               `json:"tags,omitempty"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// ParameterInfo contains parameter information
type ParameterInfo struct {
        Name        string      `json:"name"`
        Type        string      `json:"type"`
        Required    bool        `json:"required"`
        Description string      `json:"description"`
        Default     interface{} `json:"default,omitempty"`
}

// ResponseInfo contains response information
type ResponseInfo struct {
        StatusCode  int                    `json:"status_code"`
        Description string                 `json:"description"`
        ContentType string                 `json:"content_type"`
        Schema      map[string]interface{} `json:"schema,omitempty"`
}

// HealthCheckInfo contains health check configuration
type HealthCheckInfo struct {
        Path     string        `json:"path"`
        Method   string        `json:"method"`
        Interval time.Duration `json:"interval"`
        Timeout  time.Duration `json:"timeout"`
}

// DiscoveryRequest represents a service discovery request
type DiscoveryRequest struct {
        URL                string            `json:"url"`
        Headers            map[string]string `json:"headers,omitempty"`
        Timeout            time.Duration     `json:"timeout,omitempty"`
        FollowRedirects    bool              `json:"follow_redirects,omitempty"`
        DiscoveryMethods   []string          `json:"discovery_methods,omitempty"`
        AuthToken          string            `json:"auth_token,omitempty"`
        CustomDiscoveryURL string            `json:"custom_discovery_url,omitempty"`
}

// NewServiceDiscovery creates a new service discovery instance
func NewServiceDiscovery() *ServiceDiscovery <span class="cov0" title="0">{
        return &amp;ServiceDiscovery{
                client: &amp;http.Client{
                        Timeout: 30 * time.Second,
                        Transport: &amp;http.Transport{
                                MaxIdleConns:        100,
                                MaxIdleConnsPerHost: 10,
                                IdleConnTimeout:     90 * time.Second,
                        },
                },
                logger: logrus.New(),
                cache:  make(map[string]*DiscoveryResult),
        }
}</span>

// DiscoverService discovers service capabilities from a given URL
func (sd *ServiceDiscovery) DiscoverService(ctx context.Context, request *DiscoveryRequest) (*DiscoveryResult, error) <span class="cov0" title="0">{
        if request.URL == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service URL is required")
        }</span>

        // Check cache first
        <span class="cov0" title="0">sd.mu.RLock()
        if cached, exists := sd.cache[request.URL]; exists </span><span class="cov0" title="0">{
                // Return cached result if it's still fresh (within 5 minutes)
                if time.Since(cached.LastChecked) &lt; 5*time.Minute </span><span class="cov0" title="0">{
                        sd.mu.RUnlock()
                        return cached, nil
                }</span>
        }
        <span class="cov0" title="0">sd.mu.RUnlock()

        // Perform discovery
        result, err := sd.performDiscovery(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Cache the result
        <span class="cov0" title="0">sd.mu.Lock()
        sd.cache[request.URL] = result
        sd.mu.Unlock()

        return result, nil</span>
}

// performDiscovery performs the actual service discovery
func (sd *ServiceDiscovery) performDiscovery(ctx context.Context, request *DiscoveryRequest) (*DiscoveryResult, error) <span class="cov0" title="0">{
        result := &amp;DiscoveryResult{
                ServiceURL:   request.URL,
                Metadata:     make(map[string]interface{}),
                DiscoveredAt: time.Now(),
                LastChecked:  time.Now(),
                Status:       "unknown",
        }

        // Set default discovery methods if not specified
        methods := request.DiscoveryMethods
        if len(methods) == 0 </span><span class="cov0" title="0">{
                methods = []string{"openapi", "swagger", "health", "info", "root"}
        }</span>

        // Try different discovery methods
        <span class="cov0" title="0">for _, method := range methods </span><span class="cov0" title="0">{
                switch method </span>{
                case "openapi":<span class="cov0" title="0">
                        if err := sd.discoverOpenAPI(ctx, request, result); err != nil </span><span class="cov0" title="0">{
                                sd.logger.Debugf("OpenAPI discovery failed for %s: %v", request.URL, err)
                        }</span>
                case "swagger":<span class="cov0" title="0">
                        if err := sd.discoverSwagger(ctx, request, result); err != nil </span><span class="cov0" title="0">{
                                sd.logger.Debugf("Swagger discovery failed for %s: %v", request.URL, err)
                        }</span>
                case "health":<span class="cov0" title="0">
                        if err := sd.discoverHealthCheck(ctx, request, result); err != nil </span><span class="cov0" title="0">{
                                sd.logger.Debugf("Health check discovery failed for %s: %v", request.URL, err)
                        }</span>
                case "info":<span class="cov0" title="0">
                        if err := sd.discoverServiceInfo(ctx, request, result); err != nil </span><span class="cov0" title="0">{
                                sd.logger.Debugf("Service info discovery failed for %s: %v", request.URL, err)
                        }</span>
                case "root":<span class="cov0" title="0">
                        if err := sd.discoverFromRoot(ctx, request, result); err != nil </span><span class="cov0" title="0">{
                                sd.logger.Debugf("Root discovery failed for %s: %v", request.URL, err)
                        }</span>
                }
        }

        // Determine overall status
        <span class="cov0" title="0">if len(result.Endpoints) &gt; 0 || result.ServiceName != "" </span><span class="cov0" title="0">{
                result.Status = "discovered"
        }</span> else<span class="cov0" title="0"> {
                result.Status = "limited_info"
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// discoverOpenAPI tries to discover service info from OpenAPI spec
func (sd *ServiceDiscovery) discoverOpenAPI(ctx context.Context, request *DiscoveryRequest, result *DiscoveryResult) error <span class="cov0" title="0">{
        paths := []string{"/openapi.json", "/openapi.yaml", "/v3/api-docs", "/api-docs"}

        for _, path := range paths </span><span class="cov0" title="0">{
                specURL := strings.TrimRight(request.URL, "/") + path

                resp, err := sd.makeRequest(ctx, "GET", specURL, request.Headers, request.AuthToken)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                        body, err := io.ReadAll(resp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">var spec map[string]interface{}
                        if err := json.Unmarshal(body, &amp;spec); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">sd.parseOpenAPISpec(spec, result)
                        return nil</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("no OpenAPI specification found")</span>
}

// discoverSwagger tries to discover service info from Swagger spec
func (sd *ServiceDiscovery) discoverSwagger(ctx context.Context, request *DiscoveryRequest, result *DiscoveryResult) error <span class="cov0" title="0">{
        paths := []string{"/swagger.json", "/swagger.yaml", "/v2/api-docs", "/api/swagger.json"}

        for _, path := range paths </span><span class="cov0" title="0">{
                specURL := strings.TrimRight(request.URL, "/") + path

                resp, err := sd.makeRequest(ctx, "GET", specURL, request.Headers, request.AuthToken)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                        body, err := io.ReadAll(resp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">var spec map[string]interface{}
                        if err := json.Unmarshal(body, &amp;spec); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">sd.parseSwaggerSpec(spec, result)
                        return nil</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("no Swagger specification found")</span>
}

// discoverHealthCheck tries to discover health check endpoint
func (sd *ServiceDiscovery) discoverHealthCheck(ctx context.Context, request *DiscoveryRequest, result *DiscoveryResult) error <span class="cov0" title="0">{
        healthPaths := []string{"/health", "/healthz", "/health/check", "/api/health", "/status"}

        for _, path := range healthPaths </span><span class="cov0" title="0">{
                healthURL := strings.TrimRight(request.URL, "/") + path

                resp, err := sd.makeRequest(ctx, "GET", healthURL, request.Headers, request.AuthToken)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                        result.HealthCheck = &amp;HealthCheckInfo{
                                Path:     path,
                                Method:   "GET",
                                Interval: 30 * time.Second,
                                Timeout:  10 * time.Second,
                        }

                        // Try to parse health response
                        body, err := io.ReadAll(resp.Body)
                        if err == nil </span><span class="cov0" title="0">{
                                var healthData map[string]interface{}
                                if json.Unmarshal(body, &amp;healthData) == nil </span><span class="cov0" title="0">{
                                        result.Metadata["health_info"] = healthData
                                }</span>
                        }

                        <span class="cov0" title="0">return nil</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("no health check endpoint found")</span>
}

// discoverServiceInfo tries to discover service info from common info endpoints
func (sd *ServiceDiscovery) discoverServiceInfo(ctx context.Context, request *DiscoveryRequest, result *DiscoveryResult) error <span class="cov0" title="0">{
        infoPaths := []string{"/info", "/version", "/api/info", "/api/version", "/actuator/info"}

        for _, path := range infoPaths </span><span class="cov0" title="0">{
                infoURL := strings.TrimRight(request.URL, "/") + path

                resp, err := sd.makeRequest(ctx, "GET", infoURL, request.Headers, request.AuthToken)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                        body, err := io.ReadAll(resp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">var info map[string]interface{}
                        if err := json.Unmarshal(body, &amp;info); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Extract service information
                        <span class="cov0" title="0">if name, ok := info["name"].(string); ok </span><span class="cov0" title="0">{
                                result.ServiceName = name
                        }</span>
                        <span class="cov0" title="0">if version, ok := info["version"].(string); ok </span><span class="cov0" title="0">{
                                result.Version = version
                        }</span>
                        <span class="cov0" title="0">if description, ok := info["description"].(string); ok </span><span class="cov0" title="0">{
                                result.Description = description
                        }</span>

                        <span class="cov0" title="0">result.Metadata["service_info"] = info
                        return nil</span>
                }
        }

        <span class="cov0" title="0">return fmt.Errorf("no service info endpoint found")</span>
}

// discoverFromRoot tries to discover basic service info from root endpoint
func (sd *ServiceDiscovery) discoverFromRoot(ctx context.Context, request *DiscoveryRequest, result *DiscoveryResult) error <span class="cov0" title="0">{
        resp, err := sd.makeRequest(ctx, "GET", request.URL, request.Headers, request.AuthToken)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                // Extract basic info from response headers
                if server := resp.Header.Get("Server"); server != "" </span><span class="cov0" title="0">{
                        result.Metadata["server"] = server
                }</span>

                // Try to parse JSON response
                <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
                if err == nil </span><span class="cov0" title="0">{
                        var rootData map[string]interface{}
                        if json.Unmarshal(body, &amp;rootData) == nil </span><span class="cov0" title="0">{
                                result.Metadata["root_response"] = rootData

                                // Try to extract service name from common fields
                                for _, field := range []string{"name", "service", "title", "application"} </span><span class="cov0" title="0">{
                                        if name, ok := rootData[field].(string); ok &amp;&amp; result.ServiceName == "" </span><span class="cov0" title="0">{
                                                result.ServiceName = name
                                                break</span>
                                        }
                                }
                        }
                }

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("root endpoint returned status %d", resp.StatusCode)</span>
}

// parseOpenAPISpec parses OpenAPI specification and extracts service info
func (sd *ServiceDiscovery) parseOpenAPISpec(spec map[string]interface{}, result *DiscoveryResult) <span class="cov0" title="0">{
        // Extract basic info
        if info, ok := spec["info"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if title, ok := info["title"].(string); ok </span><span class="cov0" title="0">{
                        result.ServiceName = title
                }</span>
                <span class="cov0" title="0">if version, ok := info["version"].(string); ok </span><span class="cov0" title="0">{
                        result.Version = version
                }</span>
                <span class="cov0" title="0">if description, ok := info["description"].(string); ok </span><span class="cov0" title="0">{
                        result.Description = description
                }</span>
        }

        // Extract paths/endpoints
        <span class="cov0" title="0">if paths, ok := spec["paths"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                for path, pathInfo := range paths </span><span class="cov0" title="0">{
                        if pathData, ok := pathInfo.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                for method, methodInfo := range pathData </span><span class="cov0" title="0">{
                                        if methodData, ok := methodInfo.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                endpoint := EndpointInfo{
                                                        Path:   path,
                                                        Method: strings.ToUpper(method),
                                                }

                                                if summary, ok := methodData["summary"].(string); ok </span><span class="cov0" title="0">{
                                                        endpoint.Description = summary
                                                }</span>

                                                <span class="cov0" title="0">if tags, ok := methodData["tags"].([]interface{}); ok </span><span class="cov0" title="0">{
                                                        for _, tag := range tags </span><span class="cov0" title="0">{
                                                                if tagStr, ok := tag.(string); ok </span><span class="cov0" title="0">{
                                                                        endpoint.Tags = append(endpoint.Tags, tagStr)
                                                                }</span>
                                                        }
                                                }

                                                <span class="cov0" title="0">result.Endpoints = append(result.Endpoints, endpoint)</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">result.Capabilities = append(result.Capabilities, "openapi")</span>
}

// parseSwaggerSpec parses Swagger specification and extracts service info
func (sd *ServiceDiscovery) parseSwaggerSpec(spec map[string]interface{}, result *DiscoveryResult) <span class="cov0" title="0">{
        // Similar to OpenAPI but for Swagger 2.0
        if info, ok := spec["info"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if title, ok := info["title"].(string); ok </span><span class="cov0" title="0">{
                        result.ServiceName = title
                }</span>
                <span class="cov0" title="0">if version, ok := info["version"].(string); ok </span><span class="cov0" title="0">{
                        result.Version = version
                }</span>
                <span class="cov0" title="0">if description, ok := info["description"].(string); ok </span><span class="cov0" title="0">{
                        result.Description = description
                }</span>
        }

        // Extract paths
        <span class="cov0" title="0">if paths, ok := spec["paths"].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                for path, pathInfo := range paths </span><span class="cov0" title="0">{
                        if pathData, ok := pathInfo.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                for method, methodInfo := range pathData </span><span class="cov0" title="0">{
                                        if methodData, ok := methodInfo.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                                endpoint := EndpointInfo{
                                                        Path:   path,
                                                        Method: strings.ToUpper(method),
                                                }

                                                if summary, ok := methodData["summary"].(string); ok </span><span class="cov0" title="0">{
                                                        endpoint.Description = summary
                                                }</span>

                                                <span class="cov0" title="0">result.Endpoints = append(result.Endpoints, endpoint)</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">result.Capabilities = append(result.Capabilities, "swagger")</span>
}

// makeRequest makes an HTTP request with proper headers and authentication
func (sd *ServiceDiscovery) makeRequest(ctx context.Context, method, url string, headers map[string]string, authToken string) (*http.Response, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, method, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Add custom headers
        <span class="cov0" title="0">for key, value := range headers </span><span class="cov0" title="0">{
                req.Header.Set(key, value)
        }</span>

        // Add authentication
        <span class="cov0" title="0">if authToken != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", "Bearer "+authToken)
        }</span>

        // Set default headers
        <span class="cov0" title="0">req.Header.Set("User-Agent", "VoiceHelper-ServiceDiscovery/1.0")
        req.Header.Set("Accept", "application/json, text/plain, */*")

        return sd.client.Do(req)</span>
}

// GetCachedResult returns a cached discovery result
func (sd *ServiceDiscovery) GetCachedResult(serviceURL string) (*DiscoveryResult, bool) <span class="cov0" title="0">{
        sd.mu.RLock()
        defer sd.mu.RUnlock()

        result, exists := sd.cache[serviceURL]
        return result, exists
}</span>

// ClearCache clears the discovery cache
func (sd *ServiceDiscovery) ClearCache() <span class="cov0" title="0">{
        sd.mu.Lock()
        defer sd.mu.Unlock()

        sd.cache = make(map[string]*DiscoveryResult)
}</span>

// ListCachedServices returns all cached service URLs
func (sd *ServiceDiscovery) ListCachedServices() []string <span class="cov0" title="0">{
        sd.mu.RLock()
        defer sd.mu.RUnlock()

        urls := make([]string, 0, len(sd.cache))
        for url := range sd.cache </span><span class="cov0" title="0">{
                urls = append(urls, url)
        }</span>

        <span class="cov0" title="0">return urls</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package discovery

import (
        "context"
        "fmt"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// ServiceRegistry manages discovered and registered services
type ServiceRegistry struct {
        services  map[string]*RegisteredService
        discovery *ServiceDiscovery
        mu        sync.RWMutex
        logger    *logrus.Logger

        // Health check configuration
        healthCheckInterval time.Duration
        healthCheckTimeout  time.Duration
        healthCheckEnabled  bool

        // Background workers
        healthCheckTicker *time.Ticker
        stopChan          chan struct{}
        wg                sync.WaitGroup
}

// RegisteredService represents a service in the registry
type RegisteredService struct {
        ID              string                 `json:"id"`
        Name            string                 `json:"name"`
        URL             string                 `json:"url"`
        Category        string                 `json:"category"`
        Status          ServiceStatus          `json:"status"`
        DiscoveryResult *DiscoveryResult       `json:"discovery_result,omitempty"`
        HealthStatus    HealthStatus           `json:"health_status"`
        LastHealthCheck time.Time              `json:"last_health_check"`
        RegisteredAt    time.Time              `json:"registered_at"`
        UpdatedAt       time.Time              `json:"updated_at"`
        Metadata        map[string]interface{} `json:"metadata"`
        Tags            []string               `json:"tags"`

        // Load balancing and routing
        Weight   int `json:"weight"`
        Priority int `json:"priority"`

        // Statistics
        RequestCount    int64         `json:"request_count"`
        ErrorCount      int64         `json:"error_count"`
        LastRequestTime time.Time     `json:"last_request_time"`
        AverageLatency  time.Duration `json:"average_latency"`
}

// ServiceStatus represents the operational status of a service
type ServiceStatus string

const (
        StatusActive      ServiceStatus = "active"
        StatusInactive    ServiceStatus = "inactive"
        StatusError       ServiceStatus = "error"
        StatusMaintenance ServiceStatus = "maintenance"
        StatusDiscovering ServiceStatus = "discovering"
)

// HealthStatus represents the health status of a service
type HealthStatus string

const (
        HealthHealthy   HealthStatus = "healthy"
        HealthUnhealthy HealthStatus = "unhealthy"
        HealthUnknown   HealthStatus = "unknown"
        HealthTimeout   HealthStatus = "timeout"
)

// RegistryConfig contains configuration for the service registry
type RegistryConfig struct {
        HealthCheckInterval time.Duration
        HealthCheckTimeout  time.Duration
        HealthCheckEnabled  bool
        AutoDiscovery       bool
        DiscoveryMethods    []string
}

// NewServiceRegistry creates a new service registry
func NewServiceRegistry(config *RegistryConfig) *ServiceRegistry <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = &amp;RegistryConfig{
                        HealthCheckInterval: 30 * time.Second,
                        HealthCheckTimeout:  10 * time.Second,
                        HealthCheckEnabled:  true,
                        AutoDiscovery:       true,
                        DiscoveryMethods:    []string{"openapi", "swagger", "health", "info"},
                }
        }</span>

        <span class="cov0" title="0">registry := &amp;ServiceRegistry{
                services:            make(map[string]*RegisteredService),
                discovery:           NewServiceDiscovery(),
                logger:              logrus.New(),
                healthCheckInterval: config.HealthCheckInterval,
                healthCheckTimeout:  config.HealthCheckTimeout,
                healthCheckEnabled:  config.HealthCheckEnabled,
                stopChan:            make(chan struct{}),
        }

        // Start background health checks if enabled
        if config.HealthCheckEnabled </span><span class="cov0" title="0">{
                registry.startHealthChecker()
        }</span>

        <span class="cov0" title="0">return registry</span>
}

// RegisterService registers a new service in the registry
func (sr *ServiceRegistry) RegisterService(ctx context.Context, service *RegisteredService) error <span class="cov0" title="0">{
        if service.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("service ID cannot be empty")
        }</span>
        <span class="cov0" title="0">if service.URL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("service URL cannot be empty")
        }</span>

        <span class="cov0" title="0">sr.mu.Lock()
        defer sr.mu.Unlock()

        // Set default values
        if service.Name == "" </span><span class="cov0" title="0">{
                service.Name = service.ID
        }</span>
        <span class="cov0" title="0">if service.Status == "" </span><span class="cov0" title="0">{
                service.Status = StatusDiscovering
        }</span>
        <span class="cov0" title="0">if service.HealthStatus == "" </span><span class="cov0" title="0">{
                service.HealthStatus = HealthUnknown
        }</span>
        <span class="cov0" title="0">if service.Metadata == nil </span><span class="cov0" title="0">{
                service.Metadata = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">if service.Weight == 0 </span><span class="cov0" title="0">{
                service.Weight = 100
        }</span>

        <span class="cov0" title="0">service.RegisteredAt = time.Now()
        service.UpdatedAt = time.Now()

        sr.services[service.ID] = service
        sr.logger.Infof("Registered service: %s (%s)", service.Name, service.ID)

        // Perform service discovery in background
        go sr.discoverServiceCapabilities(ctx, service.ID)

        return nil</span>
}

// DiscoverAndRegisterService discovers a service and registers it
func (sr *ServiceRegistry) DiscoverAndRegisterService(ctx context.Context, serviceURL, serviceID string) (*RegisteredService, error) <span class="cov0" title="0">{
        if serviceID == "" </span><span class="cov0" title="0">{
                serviceID = fmt.Sprintf("service_%d", time.Now().Unix())
        }</span>

        // Perform discovery
        <span class="cov0" title="0">discoveryRequest := &amp;DiscoveryRequest{
                URL:              serviceURL,
                Timeout:          30 * time.Second,
                FollowRedirects:  true,
                DiscoveryMethods: []string{"openapi", "swagger", "health", "info", "root"},
        }

        discoveryResult, err := sr.discovery.DiscoverService(ctx, discoveryRequest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to discover service: %w", err)
        }</span>

        // Create registered service from discovery result
        <span class="cov0" title="0">service := &amp;RegisteredService{
                ID:              serviceID,
                Name:            discoveryResult.ServiceName,
                URL:             serviceURL,
                Status:          StatusActive,
                DiscoveryResult: discoveryResult,
                HealthStatus:    HealthUnknown,
                Metadata:        discoveryResult.Metadata,
                Weight:          100,
                Priority:        1,
        }

        // Infer category from capabilities or endpoints
        service.Category = sr.inferServiceCategory(discoveryResult)

        // Register the service
        if err := sr.RegisterService(ctx, service); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return service, nil</span>
}

// GetService retrieves a service by ID
func (sr *ServiceRegistry) GetService(serviceID string) (*RegisteredService, error) <span class="cov0" title="0">{
        sr.mu.RLock()
        defer sr.mu.RUnlock()

        service, exists := sr.services[serviceID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service not found: %s", serviceID)
        }</span>

        <span class="cov0" title="0">return service, nil</span>
}

// ListServices returns all registered services
func (sr *ServiceRegistry) ListServices() []*RegisteredService <span class="cov0" title="0">{
        sr.mu.RLock()
        defer sr.mu.RUnlock()

        services := make([]*RegisteredService, 0, len(sr.services))
        for _, service := range sr.services </span><span class="cov0" title="0">{
                services = append(services, service)
        }</span>

        <span class="cov0" title="0">return services</span>
}

// ListServicesByCategory returns services filtered by category
func (sr *ServiceRegistry) ListServicesByCategory(category string) []*RegisteredService <span class="cov0" title="0">{
        sr.mu.RLock()
        defer sr.mu.RUnlock()

        var services []*RegisteredService
        for _, service := range sr.services </span><span class="cov0" title="0">{
                if service.Category == category </span><span class="cov0" title="0">{
                        services = append(services, service)
                }</span>
        }

        <span class="cov0" title="0">return services</span>
}

// ListHealthyServices returns only healthy services
func (sr *ServiceRegistry) ListHealthyServices() []*RegisteredService <span class="cov0" title="0">{
        sr.mu.RLock()
        defer sr.mu.RUnlock()

        var services []*RegisteredService
        for _, service := range sr.services </span><span class="cov0" title="0">{
                if service.HealthStatus == HealthHealthy &amp;&amp; service.Status == StatusActive </span><span class="cov0" title="0">{
                        services = append(services, service)
                }</span>
        }

        <span class="cov0" title="0">return services</span>
}

// UpdateService updates an existing service
func (sr *ServiceRegistry) UpdateService(serviceID string, updates map[string]interface{}) error <span class="cov0" title="0">{
        sr.mu.Lock()
        defer sr.mu.Unlock()

        service, exists := sr.services[serviceID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("service not found: %s", serviceID)
        }</span>

        // Apply updates
        <span class="cov0" title="0">for key, value := range updates </span><span class="cov0" title="0">{
                switch key </span>{
                case "name":<span class="cov0" title="0">
                        if name, ok := value.(string); ok </span><span class="cov0" title="0">{
                                service.Name = name
                        }</span>
                case "status":<span class="cov0" title="0">
                        if status, ok := value.(ServiceStatus); ok </span><span class="cov0" title="0">{
                                service.Status = status
                        }</span>
                case "category":<span class="cov0" title="0">
                        if category, ok := value.(string); ok </span><span class="cov0" title="0">{
                                service.Category = category
                        }</span>
                case "weight":<span class="cov0" title="0">
                        if weight, ok := value.(int); ok </span><span class="cov0" title="0">{
                                service.Weight = weight
                        }</span>
                case "priority":<span class="cov0" title="0">
                        if priority, ok := value.(int); ok </span><span class="cov0" title="0">{
                                service.Priority = priority
                        }</span>
                case "tags":<span class="cov0" title="0">
                        if tags, ok := value.([]string); ok </span><span class="cov0" title="0">{
                                service.Tags = tags
                        }</span>
                default:<span class="cov0" title="0">
                        // Store in metadata
                        service.Metadata[key] = value</span>
                }
        }

        <span class="cov0" title="0">service.UpdatedAt = time.Now()
        sr.logger.Infof("Updated service: %s", serviceID)

        return nil</span>
}

// RemoveService removes a service from the registry
func (sr *ServiceRegistry) RemoveService(serviceID string) error <span class="cov0" title="0">{
        sr.mu.Lock()
        defer sr.mu.Unlock()

        if _, exists := sr.services[serviceID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("service not found: %s", serviceID)
        }</span>

        <span class="cov0" title="0">delete(sr.services, serviceID)
        sr.logger.Infof("Removed service: %s", serviceID)

        return nil</span>
}

// CheckServiceHealth performs a health check on a specific service
func (sr *ServiceRegistry) CheckServiceHealth(ctx context.Context, serviceID string) (HealthStatus, error) <span class="cov0" title="0">{
        service, err := sr.GetService(serviceID)
        if err != nil </span><span class="cov0" title="0">{
                return HealthUnknown, err
        }</span>

        <span class="cov0" title="0">health := sr.performHealthCheck(ctx, service)

        // Update service health status
        sr.mu.Lock()
        service.HealthStatus = health
        service.LastHealthCheck = time.Now()
        sr.mu.Unlock()

        return health, nil</span>
}

// GetServiceStats returns statistics for a service
func (sr *ServiceRegistry) GetServiceStats(serviceID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        service, err := sr.GetService(serviceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sr.mu.RLock()
        defer sr.mu.RUnlock()

        stats := map[string]interface{}{
                "request_count":     service.RequestCount,
                "error_count":       service.ErrorCount,
                "last_request_time": service.LastRequestTime,
                "average_latency":   service.AverageLatency,
                "health_status":     service.HealthStatus,
                "last_health_check": service.LastHealthCheck,
                "uptime":            time.Since(service.RegisteredAt),
                "error_rate":        float64(service.ErrorCount) / float64(service.RequestCount),
        }

        return stats, nil</span>
}

// RecordServiceRequest records a request to a service for statistics
func (sr *ServiceRegistry) RecordServiceRequest(serviceID string, latency time.Duration, success bool) <span class="cov0" title="0">{
        sr.mu.Lock()
        defer sr.mu.Unlock()

        service, exists := sr.services[serviceID]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">service.RequestCount++
        service.LastRequestTime = time.Now()

        if !success </span><span class="cov0" title="0">{
                service.ErrorCount++
        }</span>

        // Update average latency (simple moving average)
        <span class="cov0" title="0">if service.AverageLatency == 0 </span><span class="cov0" title="0">{
                service.AverageLatency = latency
        }</span> else<span class="cov0" title="0"> {
                service.AverageLatency = (service.AverageLatency + latency) / 2
        }</span>
}

// startHealthChecker starts the background health checker
func (sr *ServiceRegistry) startHealthChecker() <span class="cov0" title="0">{
        sr.healthCheckTicker = time.NewTicker(sr.healthCheckInterval)

        sr.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer sr.wg.Done()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-sr.healthCheckTicker.C:<span class="cov0" title="0">
                                sr.performHealthChecks()</span>
                        case &lt;-sr.stopChan:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
}

// performHealthChecks performs health checks on all active services
func (sr *ServiceRegistry) performHealthChecks() <span class="cov0" title="0">{
        sr.mu.RLock()
        services := make([]*RegisteredService, 0, len(sr.services))
        for _, service := range sr.services </span><span class="cov0" title="0">{
                if service.Status == StatusActive </span><span class="cov0" title="0">{
                        services = append(services, service)
                }</span>
        }
        <span class="cov0" title="0">sr.mu.RUnlock()

        // Perform health checks concurrently
        var wg sync.WaitGroup
        for _, service := range services </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(svc *RegisteredService) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        ctx, cancel := context.WithTimeout(context.Background(), sr.healthCheckTimeout)
                        defer cancel()

                        health := sr.performHealthCheck(ctx, svc)

                        sr.mu.Lock()
                        svc.HealthStatus = health
                        svc.LastHealthCheck = time.Now()
                        sr.mu.Unlock()
                }</span>(service)
        }

        <span class="cov0" title="0">wg.Wait()</span>
}

// performHealthCheck performs a health check on a single service
func (sr *ServiceRegistry) performHealthCheck(ctx context.Context, service *RegisteredService) HealthStatus <span class="cov0" title="0">{
        // Use discovered health check endpoint if available
        healthPath := "/health"
        if service.DiscoveryResult != nil &amp;&amp; service.DiscoveryResult.HealthCheck != nil </span><span class="cov0" title="0">{
                healthPath = service.DiscoveryResult.HealthCheck.Path
        }</span>

        <span class="cov0" title="0">healthURL := service.URL + healthPath

        client := &amp;http.Client{Timeout: sr.healthCheckTimeout}
        req, err := http.NewRequestWithContext(ctx, "GET", healthURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                sr.logger.Errorf("Failed to create health check request for %s: %v", service.ID, err)
                return HealthUnhealthy
        }</span>

        <span class="cov0" title="0">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        return HealthTimeout
                }</span>
                <span class="cov0" title="0">return HealthUnhealthy</span>
        }
        <span class="cov0" title="0">defer resp.Body.Close()

        // Consider 2xx status codes as healthy
        if resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300 </span><span class="cov0" title="0">{
                return HealthHealthy
        }</span>

        <span class="cov0" title="0">return HealthUnhealthy</span>
}

// discoverServiceCapabilities performs service discovery for a registered service
func (sr *ServiceRegistry) discoverServiceCapabilities(ctx context.Context, serviceID string) <span class="cov0" title="0">{
        service, err := sr.GetService(serviceID)
        if err != nil </span><span class="cov0" title="0">{
                sr.logger.Errorf("Failed to get service for discovery: %v", err)
                return
        }</span>

        <span class="cov0" title="0">discoveryRequest := &amp;DiscoveryRequest{
                URL:              service.URL,
                Timeout:          30 * time.Second,
                FollowRedirects:  true,
                DiscoveryMethods: []string{"openapi", "swagger", "health", "info", "root"},
        }

        discoveryResult, err := sr.discovery.DiscoverService(ctx, discoveryRequest)
        if err != nil </span><span class="cov0" title="0">{
                sr.logger.Errorf("Failed to discover service capabilities for %s: %v", serviceID, err)
                sr.mu.Lock()
                service.Status = StatusError
                sr.mu.Unlock()
                return
        }</span>

        // Update service with discovery results
        <span class="cov0" title="0">sr.mu.Lock()
        service.DiscoveryResult = discoveryResult
        service.Status = StatusActive
        if service.Name == "" || service.Name == serviceID </span><span class="cov0" title="0">{
                service.Name = discoveryResult.ServiceName
        }</span>
        <span class="cov0" title="0">if service.Category == "" </span><span class="cov0" title="0">{
                service.Category = sr.inferServiceCategory(discoveryResult)
        }</span>
        // Merge metadata
        <span class="cov0" title="0">for key, value := range discoveryResult.Metadata </span><span class="cov0" title="0">{
                service.Metadata[key] = value
        }</span>
        <span class="cov0" title="0">service.UpdatedAt = time.Now()
        sr.mu.Unlock()

        sr.logger.Infof("Discovered capabilities for service %s: %d endpoints", serviceID, len(discoveryResult.Endpoints))</span>
}

// inferServiceCategory infers service category from discovery results
func (sr *ServiceRegistry) inferServiceCategory(result *DiscoveryResult) string <span class="cov0" title="0">{
        // Check capabilities
        for _, capability := range result.Capabilities </span><span class="cov0" title="0">{
                switch capability </span>{
                case "openapi", "swagger":<span class="cov0" title="0">
                        return "api"</span>
                }
        }

        // Check endpoints for patterns
        <span class="cov0" title="0">for _, endpoint := range result.Endpoints </span><span class="cov0" title="0">{
                path := endpoint.Path
                if strings.Contains(path, "/auth") || strings.Contains(path, "/login") </span><span class="cov0" title="0">{
                        return "auth"
                }</span>
                <span class="cov0" title="0">if strings.Contains(path, "/payment") || strings.Contains(path, "/billing") </span><span class="cov0" title="0">{
                        return "payment"
                }</span>
                <span class="cov0" title="0">if strings.Contains(path, "/storage") || strings.Contains(path, "/file") </span><span class="cov0" title="0">{
                        return "storage"
                }</span>
                <span class="cov0" title="0">if strings.Contains(path, "/message") || strings.Contains(path, "/notification") </span><span class="cov0" title="0">{
                        return "messaging"
                }</span>
        }

        // Check service name for hints
        <span class="cov0" title="0">name := strings.ToLower(result.ServiceName)
        if strings.Contains(name, "auth") </span><span class="cov0" title="0">{
                return "auth"
        }</span>
        <span class="cov0" title="0">if strings.Contains(name, "payment") || strings.Contains(name, "billing") </span><span class="cov0" title="0">{
                return "payment"
        }</span>
        <span class="cov0" title="0">if strings.Contains(name, "storage") || strings.Contains(name, "file") </span><span class="cov0" title="0">{
                return "storage"
        }</span>

        <span class="cov0" title="0">return "api"</span> // Default category
}

// Stop stops the service registry and background workers
func (sr *ServiceRegistry) Stop() <span class="cov0" title="0">{
        close(sr.stopChan)

        if sr.healthCheckTicker != nil </span><span class="cov0" title="0">{
                sr.healthCheckTicker.Stop()
        }</span>

        <span class="cov0" title="0">sr.wg.Wait()
        sr.logger.Info("Service registry stopped")</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package metrics

import (
        "sync"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
        once sync.Once
        // HTTPè¯·æ±‚æŒ‡æ ‡
        httpRequestsTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "voicehelper_http_requests_total",
                        Help: "Total number of HTTP requests",
                },
                []string{"method", "endpoint", "status_code"},
        )

        httpRequestDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "voicehelper_http_request_duration_seconds",
                        Help:    "HTTP request duration in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"method", "endpoint"},
        )

        // SSEæµæŒ‡æ ‡
        sseActiveStreams = promauto.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "voicehelper_sse_active_streams",
                        Help: "Number of active SSE streams",
                },
                []string{"endpoint"},
        )

        sseEventsSent = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "voicehelper_sse_events_sent_total",
                        Help: "Total number of SSE events sent",
                },
                []string{"endpoint", "event_type"},
        )

        sseErrors = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "voicehelper_sse_errors_total",
                        Help: "Total number of SSE errors",
                },
                []string{"endpoint", "error_type"},
        )

        sseStreamDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "voicehelper_sse_stream_duration_seconds",
                        Help:    "SSE stream duration in seconds",
                        Buckets: []float64{1, 5, 10, 30, 60, 300, 600, 1800, 3600},
                },
                []string{"endpoint"},
        )

        // WebSocketæŒ‡æ ‡
        wsActiveConnections = promauto.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "voicehelper_ws_active_connections",
                        Help: "Number of active WebSocket connections",
                },
                []string{"endpoint"},
        )

        wsMessagesReceived = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "voicehelper_ws_messages_received_total",
                        Help: "Total number of WebSocket messages received",
                },
                []string{"endpoint", "message_type"},
        )

        wsMessagesSent = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "voicehelper_ws_messages_sent_total",
                        Help: "Total number of WebSocket messages sent",
                },
                []string{"endpoint", "message_type"},
        )

        wsErrors = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "voicehelper_ws_errors_total",
                        Help: "Total number of WebSocket errors",
                },
                []string{"endpoint", "error_type"},
        )

        // è¯­éŸ³å¤„ç†æŒ‡æ ‡
        voiceSessionsActive = promauto.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "voicehelper_voice_sessions_active",
                        Help: "Number of active voice sessions",
                },
                []string{"session_type"},
        )

        voiceProcessingDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "voicehelper_voice_processing_duration_seconds",
                        Help:    "Voice processing duration in seconds",
                        Buckets: []float64{0.1, 0.5, 1, 2, 5, 10, 30},
                },
                []string{"processing_type"},
        )

        voiceAudioBytes = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "voicehelper_voice_audio_bytes_total",
                        Help: "Total number of audio bytes processed",
                },
                []string{"direction"}, // "input" or "output"
        )

        // ç®—æ³•æœåŠ¡æŒ‡æ ‡
        algoRequestsTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "voicehelper_algo_requests_total",
                        Help: "Total number of algorithm service requests",
                },
                []string{"endpoint", "status"},
        )

        algoRequestDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "voicehelper_algo_request_duration_seconds",
                        Help:    "Algorithm service request duration in seconds",
                        Buckets: []float64{0.1, 0.5, 1, 2, 5, 10, 30, 60},
                },
                []string{"endpoint"},
        )
)

// InitMetrics åˆå§‹åŒ–æŒ‡æ ‡ç³»ç»Ÿï¼ˆç¡®ä¿åªåˆå§‹åŒ–ä¸€æ¬¡ï¼‰
func InitMetrics() <span class="cov0" title="0">{
        once.Do(func() </span>{<span class="cov0" title="0">
                // è¿™é‡Œå¯ä»¥æ·»åŠ ä»»ä½•ä¸€æ¬¡æ€§åˆå§‹åŒ–é€»è¾‘
                // ç”±äºä½¿ç”¨äº†promautoï¼ŒæŒ‡æ ‡å·²ç»è‡ªåŠ¨æ³¨å†Œ
        }</span>)
}

// HTTPæŒ‡æ ‡è®°å½•å‡½æ•°
func RecordHTTPRequest(method, endpoint, statusCode string) <span class="cov0" title="0">{
        httpRequestsTotal.WithLabelValues(method, endpoint, statusCode).Inc()
}</span>

func RecordHTTPDuration(method, endpoint string, duration float64) <span class="cov0" title="0">{
        httpRequestDuration.WithLabelValues(method, endpoint).Observe(duration)
}</span>

// SSEæŒ‡æ ‡è®°å½•å‡½æ•°
func IncSSEActiveStreams(endpoint string) <span class="cov0" title="0">{
        sseActiveStreams.WithLabelValues(endpoint).Inc()
}</span>

func DecSSEActiveStreams(endpoint string) <span class="cov0" title="0">{
        sseActiveStreams.WithLabelValues(endpoint).Dec()
}</span>

func RecordSSEEvent(endpoint, eventType string) <span class="cov0" title="0">{
        sseEventsSent.WithLabelValues(endpoint, eventType).Inc()
}</span>

func RecordSSEError(endpoint, errorType string) <span class="cov0" title="0">{
        sseErrors.WithLabelValues(endpoint, errorType).Inc()
}</span>

func RecordSSEStreamDuration(endpoint string, duration float64) <span class="cov0" title="0">{
        sseStreamDuration.WithLabelValues(endpoint).Observe(duration)
}</span>

// WebSocketæŒ‡æ ‡è®°å½•å‡½æ•°
func IncWSActiveConnections(endpoint string) <span class="cov0" title="0">{
        wsActiveConnections.WithLabelValues(endpoint).Inc()
}</span>

func DecWSActiveConnections(endpoint string) <span class="cov0" title="0">{
        wsActiveConnections.WithLabelValues(endpoint).Dec()
}</span>

func RecordWSMessageReceived(endpoint, messageType string) <span class="cov0" title="0">{
        wsMessagesReceived.WithLabelValues(endpoint, messageType).Inc()
}</span>

func RecordWSMessageSent(endpoint, messageType string) <span class="cov0" title="0">{
        wsMessagesSent.WithLabelValues(endpoint, messageType).Inc()
}</span>

func RecordWSError(endpoint, errorType string) <span class="cov0" title="0">{
        wsErrors.WithLabelValues(endpoint, errorType).Inc()
}</span>

// è¯­éŸ³å¤„ç†æŒ‡æ ‡è®°å½•å‡½æ•°
func IncVoiceSessionsActive(sessionType string) <span class="cov0" title="0">{
        voiceSessionsActive.WithLabelValues(sessionType).Inc()
}</span>

func DecVoiceSessionsActive(sessionType string) <span class="cov0" title="0">{
        voiceSessionsActive.WithLabelValues(sessionType).Dec()
}</span>

func RecordVoiceProcessingDuration(processingType string, duration float64) <span class="cov0" title="0">{
        voiceProcessingDuration.WithLabelValues(processingType).Observe(duration)
}</span>

func RecordVoiceAudioBytes(direction string, bytes int64) <span class="cov0" title="0">{
        voiceAudioBytes.WithLabelValues(direction).Add(float64(bytes))
}</span>

// ç®—æ³•æœåŠ¡æŒ‡æ ‡è®°å½•å‡½æ•°
func RecordAlgoRequest(endpoint, status string) <span class="cov0" title="0">{
        algoRequestsTotal.WithLabelValues(endpoint, status).Inc()
}</span>

func RecordAlgoRequestDuration(endpoint string, duration float64) <span class="cov0" title="0">{
        algoRequestDuration.WithLabelValues(endpoint).Observe(duration)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package middleware

import (
        "strings"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "github.com/sirupsen/logrus"
)

// AuthMiddleware JWTè®¤è¯ä¸­é—´ä»¶
type AuthMiddleware struct {
        secretKey      []byte
        skipPaths      []string
        tokenBlacklist map[string]time.Time // ç®€å•çš„é»‘åå•å®ç°
}

// NewAuthMiddleware åˆ›å»ºè®¤è¯ä¸­é—´ä»¶
func NewAuthMiddleware(secretKey string, skipPaths []string) *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{
                secretKey:      []byte(secretKey),
                skipPaths:      skipPaths,
                tokenBlacklist: make(map[string]time.Time),
        }
}</span>

// Claims JWTå£°æ˜
type Claims struct {
        UserID   string   `json:"user_id"`
        TenantID string   `json:"tenant_id"`
        OpenID   string   `json:"openid"`
        Channel  string   `json:"channel"`
        Role     string   `json:"role"`
        Scopes   []string `json:"scopes"`
        jwt.RegisteredClaims
}

// Handle JWTéªŒè¯ä¸­é—´ä»¶å¤„ç†å‡½æ•°
func (a *AuthMiddleware) Handle() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // æ£€æŸ¥æ˜¯å¦éœ€è¦è·³è¿‡éªŒè¯
                if a.shouldSkip(c.Request.URL.Path) </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // è·å–Token
                <span class="cov0" title="0">tokenString := a.extractToken(c)
                if tokenString == "" </span><span class="cov0" title="0">{
                        c.JSON(401, gin.H{"error": "No token provided"})
                        c.Abort()
                        return
                }</span>

                // æ£€æŸ¥é»‘åå•
                <span class="cov0" title="0">if a.isBlacklisted(tokenString) </span><span class="cov0" title="0">{
                        c.JSON(401, gin.H{"error": "Token has been revoked"})
                        c.Abort()
                        return
                }</span>

                // éªŒè¯Token
                <span class="cov0" title="0">claims, err := a.validateToken(tokenString)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(401, gin.H{"error": "Invalid token: " + err.Error()})
                        c.Abort()
                        return
                }</span>

                // æ£€æŸ¥Tokenæ˜¯å¦è¿‡æœŸ
                <span class="cov0" title="0">if claims.ExpiresAt != nil &amp;&amp; claims.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                        c.JSON(401, gin.H{"error": "Token has expired"})
                        c.Abort()
                        return
                }</span>

                // å°†ç”¨æˆ·ä¿¡æ¯å­˜å…¥ä¸Šä¸‹æ–‡
                <span class="cov0" title="0">c.Set("user_id", claims.UserID)
                c.Set("tenant_id", claims.TenantID)
                c.Set("role", claims.Role)
                c.Set("scopes", claims.Scopes)
                c.Set("channel", claims.Channel)
                c.Set("token", tokenString)

                // è‡ªåŠ¨ç»­æœŸï¼ˆå¦‚æœTokenå¿«è¿‡æœŸï¼‰
                if a.shouldRenew(claims) </span><span class="cov0" title="0">{
                        newToken, err := a.renewToken(claims)
                        if err == nil </span><span class="cov0" title="0">{
                                c.Header("X-New-Token", newToken)
                        }</span>
                }

                <span class="cov0" title="0">c.Next()</span>
        }
}

// extractToken ä»è¯·æ±‚ä¸­æå–Token
func (a *AuthMiddleware) extractToken(c *gin.Context) string <span class="cov0" title="0">{
        // ä»Headerè·å–
        authHeader := c.GetHeader("Authorization")
        if authHeader != "" </span><span class="cov0" title="0">{
                parts := strings.SplitN(authHeader, " ", 2)
                if len(parts) == 2 &amp;&amp; strings.ToLower(parts[0]) == "bearer" </span><span class="cov0" title="0">{
                        return parts[1]
                }</span>
        }

        // ä»Queryå‚æ•°è·å–ï¼ˆç”¨äºWebSocketï¼‰
        <span class="cov0" title="0">if token := c.Query("token"); token != "" </span><span class="cov0" title="0">{
                return token
        }</span>

        // ä»Cookieè·å–
        <span class="cov0" title="0">if cookie, err := c.Cookie("token"); err == nil </span><span class="cov0" title="0">{
                return cookie
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// validateToken éªŒè¯Token
func (a *AuthMiddleware) validateToken(tokenString string) (*Claims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return a.secretKey, nil
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, jwt.ErrSignatureInvalid</span>
}

// shouldSkip æ£€æŸ¥è·¯å¾„æ˜¯å¦éœ€è¦è·³è¿‡éªŒè¯
func (a *AuthMiddleware) shouldSkip(path string) bool <span class="cov0" title="0">{
        for _, skipPath := range a.skipPaths </span><span class="cov0" title="0">{
                if strings.HasPrefix(path, skipPath) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// shouldRenew æ£€æŸ¥æ˜¯å¦éœ€è¦ç»­æœŸ
func (a *AuthMiddleware) shouldRenew(claims *Claims) bool <span class="cov0" title="0">{
        if claims.ExpiresAt == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // å¦‚æœTokenåœ¨10åˆ†é’Ÿå†…è¿‡æœŸï¼Œåˆ™ç»­æœŸ
        <span class="cov0" title="0">return time.Until(claims.ExpiresAt.Time) &lt; 10*time.Minute</span>
}

// renewToken ç»­æœŸToken
func (a *AuthMiddleware) renewToken(oldClaims *Claims) (string, error) <span class="cov0" title="0">{
        // åˆ›å»ºæ–°çš„Claimsï¼Œå»¶é•¿è¿‡æœŸæ—¶é—´
        newClaims := &amp;Claims{
                UserID:   oldClaims.UserID,
                TenantID: oldClaims.TenantID,
                OpenID:   oldClaims.OpenID,
                Channel:  oldClaims.Channel,
                Role:     oldClaims.Role,
                Scopes:   oldClaims.Scopes,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                        Issuer:    oldClaims.Issuer,
                        Subject:   oldClaims.Subject,
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, newClaims)
        return token.SignedString(a.secretKey)
}</span>

// RevokeToken æ’¤é”€Tokenï¼ˆåŠ å…¥é»‘åå•ï¼‰
func (a *AuthMiddleware) RevokeToken(tokenString string) <span class="cov0" title="0">{
        a.tokenBlacklist[tokenString] = time.Now().Add(24 * time.Hour)

        // æ¸…ç†è¿‡æœŸçš„é»‘åå•é¡¹
        a.cleanupBlacklist()
}</span>

// isBlacklisted æ£€æŸ¥Tokenæ˜¯å¦åœ¨é»‘åå•ä¸­
func (a *AuthMiddleware) isBlacklisted(tokenString string) bool <span class="cov0" title="0">{
        expiry, exists := a.tokenBlacklist[tokenString]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // å¦‚æœé»‘åå•é¡¹å·²è¿‡æœŸï¼Œåˆ é™¤å®ƒ
        <span class="cov0" title="0">if time.Now().After(expiry) </span><span class="cov0" title="0">{
                delete(a.tokenBlacklist, tokenString)
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// cleanupBlacklist æ¸…ç†è¿‡æœŸçš„é»‘åå•é¡¹
func (a *AuthMiddleware) cleanupBlacklist() <span class="cov0" title="0">{
        now := time.Now()
        for token, expiry := range a.tokenBlacklist </span><span class="cov0" title="0">{
                if now.After(expiry) </span><span class="cov0" title="0">{
                        delete(a.tokenBlacklist, token)
                }</span>
        }
}

// ==================== RBACæƒé™ä¸­é—´ä»¶ ====================

// RBACMiddleware åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ä¸­é—´ä»¶
type RBACMiddleware struct {
        permissions map[string][]string // role -&gt; permissions
}

// NewRBACMiddleware åˆ›å»ºRBACä¸­é—´ä»¶
func NewRBACMiddleware() *RBACMiddleware <span class="cov0" title="0">{
        return &amp;RBACMiddleware{
                permissions: map[string][]string{
                        "super_admin": {"*"}, // æ‰€æœ‰æƒé™
                        "admin": {
                                "conversation:*",
                                "document:*",
                                "user:read",
                                "user:update",
                                "analytics:*",
                        },
                        "user": {
                                "conversation:create",
                                "conversation:read",
                                "conversation:update",
                                "document:read",
                                "analytics:read",
                        },
                },
        }
}</span>

// RequirePermission éœ€è¦ç‰¹å®šæƒé™
func (r *RBACMiddleware) RequirePermission(permission string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                role, exists := c.Get("role")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(403, gin.H{"error": "No role found"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if !r.hasPermission(role.(string), permission) </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "user_id":    c.GetString("user_id"),
                                "role":       role,
                                "permission": permission,
                        }).Warn("Permission denied")

                        c.JSON(403, gin.H{"error": "Permission denied"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// hasPermission æ£€æŸ¥è§’è‰²æ˜¯å¦æœ‰æƒé™
func (r *RBACMiddleware) hasPermission(role, permission string) bool <span class="cov0" title="0">{
        perms, exists := r.permissions[role]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, perm := range perms </span><span class="cov0" title="0">{
                if perm == "*" || perm == permission </span><span class="cov0" title="0">{
                        return true
                }</span>

                // æ”¯æŒé€šé…ç¬¦åŒ¹é…
                <span class="cov0" title="0">if strings.HasSuffix(perm, ":*") </span><span class="cov0" title="0">{
                        prefix := strings.TrimSuffix(perm, ":*")
                        if strings.HasPrefix(permission, prefix+":") </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// ==================== ç§Ÿæˆ·éš”ç¦»ä¸­é—´ä»¶ ====================

// TenantMiddleware ç§Ÿæˆ·éš”ç¦»ä¸­é—´ä»¶
type TenantMiddleware struct{}

// NewTenantMiddleware åˆ›å»ºç§Ÿæˆ·ä¸­é—´ä»¶
func NewTenantMiddleware() *TenantMiddleware <span class="cov0" title="0">{
        return &amp;TenantMiddleware{}
}</span>

// Handle ç§Ÿæˆ·éªŒè¯å¤„ç†
func (t *TenantMiddleware) Handle() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // ä»JWTä¸­è·å–ç§Ÿæˆ·ID
                tenantIDFromToken := c.GetString("tenant_id")

                // ä»Headerä¸­è·å–ç§Ÿæˆ·ID
                tenantIDFromHeader := c.GetHeader("X-Tenant-ID")

                // éªŒè¯ç§Ÿæˆ·IDä¸€è‡´æ€§
                if tenantIDFromHeader != "" &amp;&amp; tenantIDFromToken != "" </span><span class="cov0" title="0">{
                        if tenantIDFromHeader != tenantIDFromToken </span><span class="cov0" title="0">{
                                c.JSON(403, gin.H{"error": "Tenant ID mismatch"})
                                c.Abort()
                                return
                        }</span>
                }

                // è®¾ç½®æœ€ç»ˆçš„ç§Ÿæˆ·ID
                <span class="cov0" title="0">finalTenantID := tenantIDFromToken
                if finalTenantID == "" </span><span class="cov0" title="0">{
                        finalTenantID = tenantIDFromHeader
                }</span>

                <span class="cov0" title="0">if finalTenantID == "" </span><span class="cov0" title="0">{
                        c.JSON(400, gin.H{"error": "Tenant ID required"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Set("final_tenant_id", finalTenantID)
                c.Next()</span>
        }
}

// ==================== API Keyè®¤è¯ä¸­é—´ä»¶ ====================

// APIKeyAuth API Keyè®¤è¯ä¸­é—´ä»¶
type APIKeyAuth struct {
        apiKeys map[string]string // apiKey -&gt; tenantID
}

// NewAPIKeyAuth åˆ›å»ºAPI Keyè®¤è¯
func NewAPIKeyAuth() *APIKeyAuth <span class="cov0" title="0">{
        return &amp;APIKeyAuth{
                apiKeys: make(map[string]string),
        }
}</span>

// Handle API KeyéªŒè¯å¤„ç†
func (a *APIKeyAuth) Handle() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                apiKey := c.GetHeader("X-API-Key")
                if apiKey == "" </span><span class="cov0" title="0">{
                        // å°è¯•JWTè®¤è¯
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">tenantID, valid := a.validateAPIKey(apiKey)
                if !valid </span><span class="cov0" title="0">{
                        c.JSON(401, gin.H{"error": "Invalid API key"})
                        c.Abort()
                        return
                }</span>

                // è®¾ç½®ç§Ÿæˆ·ä¿¡æ¯
                <span class="cov0" title="0">c.Set("tenant_id", tenantID)
                c.Set("auth_type", "api_key")
                c.Next()</span>
        }
}

// validateAPIKey éªŒè¯API Key
func (a *APIKeyAuth) validateAPIKey(apiKey string) (string, bool) <span class="cov0" title="0">{
        // TODO: ä»æ•°æ®åº“æˆ–ç¼“å­˜ä¸­éªŒè¯
        tenantID, exists := a.apiKeys[apiKey]
        return tenantID, exists
}</span>

// RegisterAPIKey æ³¨å†ŒAPI Key
func (a *APIKeyAuth) RegisterAPIKey(apiKey, tenantID string) <span class="cov0" title="0">{
        a.apiKeys[apiKey] = tenantID
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package middleware

import (
        "context"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/sirupsen/logrus"

        "voicehelper/backend/pkg/cache"
)

// CORS è·¨åŸŸä¸­é—´ä»¶
func CORS() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.HandlerFunc(func(c *gin.Context) </span><span class="cov0" title="0">{
                origin := c.Request.Header.Get("Origin")

                // å…è®¸çš„æºåˆ—è¡¨ï¼ˆç”Ÿäº§ç¯å¢ƒåº”è¯¥é…ç½®å…·ä½“åŸŸåï¼‰
                allowedOrigins := []string{
                        "http://localhost:3000",
                        "http://localhost:3001",
                        "http://localhost:3002",
                        "https://voicehelper.ai",
                }

                // æ£€æŸ¥æ˜¯å¦ä¸ºå…è®¸çš„æº
                allowed := false
                for _, allowedOrigin := range allowedOrigins </span><span class="cov0" title="0">{
                        if origin == allowedOrigin </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if allowed || origin == "" </span><span class="cov0" title="0">{
                        c.Header("Access-Control-Allow-Origin", origin)
                }</span>

                <span class="cov0" title="0">c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Tenant-ID, X-API-Key, X-Request-ID")
                c.Header("Access-Control-Expose-Headers", "Content-Length, X-New-Token, X-Request-ID")
                c.Header("Access-Control-Allow-Credentials", "true")
                c.Header("Access-Control-Max-Age", "86400")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(http.StatusNoContent)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        })
}

// RateLimit é™æµä¸­é—´ä»¶
func RateLimit(redisClient *cache.RedisClient) gin.HandlerFunc <span class="cov0" title="0">{
        return gin.HandlerFunc(func(c *gin.Context) </span><span class="cov0" title="0">{
                // è·å–å®¢æˆ·ç«¯æ ‡è¯†
                clientID := getClientID(c)

                // é™æµè§„åˆ™ï¼šæ¯åˆ†é’Ÿæœ€å¤š100ä¸ªè¯·æ±‚
                limit := int64(100)
                window := time.Minute

                // Redisé”®
                key := fmt.Sprintf("rate_limit:%s", clientID)

                ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
                defer cancel()

                // è·å–å½“å‰è®¡æ•°
                current, err := redisClient.Incr(ctx, key)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.WithError(err).Error("Failed to increment rate limit counter")
                        c.Next()
                        return
                }</span>

                // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡è¯·æ±‚ï¼Œè®¾ç½®è¿‡æœŸæ—¶é—´
                <span class="cov0" title="0">if current == 1 </span><span class="cov0" title="0">{
                        if err := redisClient.Expire(ctx, key, window); err != nil </span><span class="cov0" title="0">{
                                logrus.WithError(err).Error("Failed to set rate limit expiration")
                        }</span>
                }

                // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
                <span class="cov0" title="0">if current &gt; limit </span><span class="cov0" title="0">{
                        c.Header("X-RateLimit-Limit", strconv.FormatInt(limit, 10))
                        c.Header("X-RateLimit-Remaining", "0")
                        c.Header("X-RateLimit-Reset", strconv.FormatInt(time.Now().Add(window).Unix(), 10))

                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error":       "Rate limit exceeded",
                                "retry_after": window.Seconds(),
                        })
                        c.Abort()
                        return
                }</span>

                // è®¾ç½®å“åº”å¤´
                <span class="cov0" title="0">remaining := limit - current
                if remaining &lt; 0 </span><span class="cov0" title="0">{
                        remaining = 0
                }</span>

                <span class="cov0" title="0">c.Header("X-RateLimit-Limit", strconv.FormatInt(limit, 10))
                c.Header("X-RateLimit-Remaining", strconv.FormatInt(remaining, 10))
                c.Header("X-RateLimit-Reset", strconv.FormatInt(time.Now().Add(window).Unix(), 10))

                c.Next()</span>
        })
}

// getClientID è·å–å®¢æˆ·ç«¯æ ‡è¯†
func getClientID(c *gin.Context) string <span class="cov0" title="0">{
        // ä¼˜å…ˆä½¿ç”¨ç”¨æˆ·ID
        if userID := c.GetString("user_id"); userID != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("user:%s", userID)
        }</span>

        // ä½¿ç”¨ç§Ÿæˆ·ID
        <span class="cov0" title="0">if tenantID := c.GetString("tenant_id"); tenantID != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("tenant:%s", tenantID)
        }</span>

        // ä½¿ç”¨IPåœ°å€
        <span class="cov0" title="0">return fmt.Sprintf("ip:%s", c.ClientIP())</span>
}

// Logging æ—¥å¿—ä¸­é—´ä»¶
func Logging() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "timestamp":  param.TimeStamp.Format(time.RFC3339),
                        "status":     param.StatusCode,
                        "latency":    param.Latency,
                        "client_ip":  param.ClientIP,
                        "method":     param.Method,
                        "path":       param.Path,
                        "user_agent": param.Request.UserAgent(),
                        "request_id": param.Keys["request_id"],
                }).Info("HTTP Request")

                return ""
        }</span>)
}

// Recovery æ¢å¤ä¸­é—´ä»¶
func Recovery() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.CustomRecovery(func(c *gin.Context, recovered interface{}) </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "error":      recovered,
                        "request_id": c.GetString("request_id"),
                        "path":       c.Request.URL.Path,
                        "method":     c.Request.Method,
                }).Error("Panic recovered")

                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":      "Internal server error",
                        "request_id": c.GetString("request_id"),
                })
        }</span>)
}

// Maintenance ç»´æŠ¤æ¨¡å¼ä¸­é—´ä»¶
func Maintenance() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.HandlerFunc(func(c *gin.Context) </span><span class="cov0" title="0">{
                // TODO: ä»é…ç½®æˆ–Redisä¸­è¯»å–ç»´æŠ¤æ¨¡å¼çŠ¶æ€
                maintenanceMode := false

                if maintenanceMode </span><span class="cov0" title="0">{
                        // å…è®¸å¥åº·æ£€æŸ¥å’Œç®¡ç†æ¥å£
                        if c.Request.URL.Path == "/health" ||
                                c.Request.URL.Path == "/metrics" ||
                                c.Request.URL.Path == "/api/v1/admin/maintenance" </span><span class="cov0" title="0">{
                                c.Next()
                                return
                        }</span>

                        <span class="cov0" title="0">c.JSON(http.StatusServiceUnavailable, gin.H{
                                "error":   "Service is under maintenance",
                                "message": "Please try again later",
                        })
                        c.Abort()
                        return</span>
                }

                <span class="cov0" title="0">c.Next()</span>
        })
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package middleware

import (
        "time"

        "github.com/gin-gonic/gin"
        "github.com/sirupsen/logrus"
)

// Logger æ—¥å¿—ä¸­é—´ä»¶
func Logger() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "status":     param.StatusCode,
                        "method":     param.Method,
                        "path":       param.Path,
                        "ip":         param.ClientIP,
                        "user_agent": param.Request.UserAgent(),
                        "latency":    param.Latency,
                        "time":       param.TimeStamp.Format(time.RFC3339),
                }).Info("HTTP Request")
                return ""
        }</span>)
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package middleware

import (
        "strconv"
        "time"

        "voicehelper/backend/pkg/metrics"

        "github.com/gin-gonic/gin"
)

// MetricsMiddleware åˆ›å»ºPrometheusæŒ‡æ ‡ä¸­é—´ä»¶
func MetricsMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()

                // å¤„ç†è¯·æ±‚
                c.Next()

                // è®°å½•æŒ‡æ ‡
                duration := time.Since(start).Seconds()
                statusCode := strconv.Itoa(c.Writer.Status())

                metrics.RecordHTTPRequest(c.Request.Method, c.FullPath(), statusCode)
                metrics.RecordHTTPDuration(c.Request.Method, c.FullPath(), duration)
        }</span>
}

// SSEMetricsWrapper SSEæµæŒ‡æ ‡åŒ…è£…å™¨
type SSEMetricsWrapper struct {
        endpoint  string
        startTime time.Time
}

// NewSSEMetricsWrapper åˆ›å»ºSSEæŒ‡æ ‡åŒ…è£…å™¨
func NewSSEMetricsWrapper(endpoint string) *SSEMetricsWrapper <span class="cov0" title="0">{
        wrapper := &amp;SSEMetricsWrapper{
                endpoint:  endpoint,
                startTime: time.Now(),
        }
        metrics.IncSSEActiveStreams(endpoint)
        return wrapper
}</span>

// RecordEvent è®°å½•SSEäº‹ä»¶
func (w *SSEMetricsWrapper) RecordEvent(eventType string) <span class="cov0" title="0">{
        metrics.RecordSSEEvent(w.endpoint, eventType)
}</span>

// RecordError è®°å½•SSEé”™è¯¯
func (w *SSEMetricsWrapper) RecordError(errorType string) <span class="cov0" title="0">{
        metrics.RecordSSEError(w.endpoint, errorType)
}</span>

// Close å…³é—­SSEæµå¹¶è®°å½•æŒç»­æ—¶é—´
func (w *SSEMetricsWrapper) Close() <span class="cov0" title="0">{
        duration := time.Since(w.startTime).Seconds()
        metrics.DecSSEActiveStreams(w.endpoint)
        metrics.RecordSSEStreamDuration(w.endpoint, duration)
}</span>

// WSMetricsWrapper WebSocketæŒ‡æ ‡åŒ…è£…å™¨
type WSMetricsWrapper struct {
        endpoint string
}

// NewWSMetricsWrapper åˆ›å»ºWebSocketæŒ‡æ ‡åŒ…è£…å™¨
func NewWSMetricsWrapper(endpoint string) *WSMetricsWrapper <span class="cov0" title="0">{
        wrapper := &amp;WSMetricsWrapper{
                endpoint: endpoint,
        }
        metrics.IncWSActiveConnections(endpoint)
        return wrapper
}</span>

// RecordMessageReceived è®°å½•æ¥æ”¶åˆ°çš„æ¶ˆæ¯
func (w *WSMetricsWrapper) RecordMessageReceived(messageType string) <span class="cov0" title="0">{
        metrics.RecordWSMessageReceived(w.endpoint, messageType)
}</span>

// RecordMessageSent è®°å½•å‘é€çš„æ¶ˆæ¯
func (w *WSMetricsWrapper) RecordMessageSent(messageType string) <span class="cov0" title="0">{
        metrics.RecordWSMessageSent(w.endpoint, messageType)
}</span>

// RecordError è®°å½•WebSocketé”™è¯¯
func (w *WSMetricsWrapper) RecordError(errorType string) <span class="cov0" title="0">{
        metrics.RecordWSError(w.endpoint, errorType)
}</span>

// Close å…³é—­WebSocketè¿æ¥
func (w *WSMetricsWrapper) Close() <span class="cov0" title="0">{
        metrics.DecWSActiveConnections(w.endpoint)
}</span>

// VoiceMetricsWrapper è¯­éŸ³å¤„ç†æŒ‡æ ‡åŒ…è£…å™¨
type VoiceMetricsWrapper struct {
        sessionType string
        startTime   time.Time
}

// NewVoiceMetricsWrapper åˆ›å»ºè¯­éŸ³æŒ‡æ ‡åŒ…è£…å™¨
func NewVoiceMetricsWrapper(sessionType string) *VoiceMetricsWrapper <span class="cov0" title="0">{
        wrapper := &amp;VoiceMetricsWrapper{
                sessionType: sessionType,
                startTime:   time.Now(),
        }
        metrics.IncVoiceSessionsActive(sessionType)
        return wrapper
}</span>

// RecordProcessingDuration è®°å½•å¤„ç†æŒç»­æ—¶é—´
func (w *VoiceMetricsWrapper) RecordProcessingDuration(processingType string, duration time.Duration) <span class="cov0" title="0">{
        metrics.RecordVoiceProcessingDuration(processingType, duration.Seconds())
}</span>

// RecordAudioBytes è®°å½•éŸ³é¢‘å­—èŠ‚æ•°
func (w *VoiceMetricsWrapper) RecordAudioBytes(direction string, bytes int64) <span class="cov0" title="0">{
        metrics.RecordVoiceAudioBytes(direction, bytes)
}</span>

// Close å…³é—­è¯­éŸ³ä¼šè¯
func (w *VoiceMetricsWrapper) Close() <span class="cov0" title="0">{
        metrics.DecVoiceSessionsActive(w.sessionType)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "strconv"
        "time"
        "voicehelper/backend/pkg/ratelimit"

        "github.com/gin-gonic/gin"
        "github.com/sirupsen/logrus"
)

// RateLimitMiddleware é€Ÿç‡é™åˆ¶ä¸­é—´ä»¶
func RateLimitMiddleware(rateLimiter *ratelimit.RateLimiter, config ratelimit.RateLimitConfig) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // è·å–å®¢æˆ·ç«¯æ ‡è¯†ï¼ˆIPåœ°å€ï¼‰
                clientIP := c.ClientIP()
                key := fmt.Sprintf("ip:%s", clientIP)

                // æ£€æŸ¥é€Ÿç‡é™åˆ¶
                result, err := rateLimiter.Check(c.Request.Context(), key, config)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.WithError(err).Error("Rate limiter check failed")
                        // å¦‚æœé€Ÿç‡é™åˆ¶å™¨å‡ºé”™ï¼Œå…è®¸è¯·æ±‚ç»§ç»­
                        c.Next()
                        return
                }</span>

                // è®¾ç½®å“åº”å¤´
                <span class="cov0" title="0">c.Header("X-RateLimit-Limit", strconv.FormatInt(result.Limit, 10))
                c.Header("X-RateLimit-Remaining", strconv.FormatInt(result.Remaining, 10))
                c.Header("X-RateLimit-Reset", strconv.FormatInt(result.ResetTime.Unix(), 10))

                // å¦‚æœè¶…è¿‡é™åˆ¶ï¼Œè¿”å›429é”™è¯¯
                if !result.Allowed </span><span class="cov0" title="0">{
                        c.Header("Retry-After", strconv.FormatInt(int64(result.RetryAfter.Seconds()), 10))
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error":       "Rate limit exceeded",
                                "message":     "Too many requests",
                                "retry_after": int64(result.RetryAfter.Seconds()),
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// APIKeyRateLimitMiddleware APIå¯†é’¥é€Ÿç‡é™åˆ¶ä¸­é—´ä»¶
func APIKeyRateLimitMiddleware(rateLimiter *ratelimit.RateLimiter) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // è·å–APIå¯†é’¥
                apiKey := c.GetHeader("X-API-Key")
                if apiKey == "" </span><span class="cov0" title="0">{
                        // å¦‚æœæ²¡æœ‰APIå¯†é’¥ï¼Œè·³è¿‡é€Ÿç‡é™åˆ¶
                        c.Next()
                        return
                }</span>

                // ä»ä¸Šä¸‹æ–‡è·å–APIå¯†é’¥ä¿¡æ¯ï¼ˆå‡è®¾å·²ç»é€šè¿‡è®¤è¯ä¸­é—´ä»¶éªŒè¯ï¼‰
                <span class="cov0" title="0">keyInfo, exists := c.Get("api_key_info")
                if !exists </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // ç±»å‹æ–­è¨€è·å–é€Ÿç‡é™åˆ¶é…ç½®
                <span class="cov0" title="0">type APIKeyInfo struct {
                        ID        string `json:"id"`
                        RateLimit int    `json:"rate_limit"`
                }

                info, ok := keyInfo.(APIKeyInfo)
                if !ok || info.RateLimit &lt;= 0 </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // é…ç½®é€Ÿç‡é™åˆ¶
                <span class="cov0" title="0">config := ratelimit.RateLimitConfig{
                        Limit:  info.RateLimit,
                        Window: time.Minute, // æ¯åˆ†é’Ÿé™åˆ¶
                }

                key := fmt.Sprintf("apikey:%s", info.ID)

                // æ£€æŸ¥é€Ÿç‡é™åˆ¶
                result, err := rateLimiter.CheckFixed(c.Request.Context(), key, config)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.WithError(err).Error("API key rate limiter check failed")
                        // å¦‚æœé€Ÿç‡é™åˆ¶å™¨å‡ºé”™ï¼Œå…è®¸è¯·æ±‚ç»§ç»­
                        c.Next()
                        return
                }</span>

                // è®¾ç½®å“åº”å¤´
                <span class="cov0" title="0">c.Header("X-RateLimit-Limit", strconv.FormatInt(result.Limit, 10))
                c.Header("X-RateLimit-Remaining", strconv.FormatInt(result.Remaining, 10))
                c.Header("X-RateLimit-Reset", strconv.FormatInt(result.ResetTime.Unix(), 10))

                // å¦‚æœè¶…è¿‡é™åˆ¶ï¼Œè¿”å›429é”™è¯¯
                if !result.Allowed </span><span class="cov0" title="0">{
                        c.Header("Retry-After", strconv.FormatInt(int64(result.RetryAfter.Seconds()), 10))
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error":       "API key rate limit exceeded",
                                "message":     "Too many requests for this API key",
                                "retry_after": int64(result.RetryAfter.Seconds()),
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// UserRateLimitMiddleware ç”¨æˆ·é€Ÿç‡é™åˆ¶ä¸­é—´ä»¶
func UserRateLimitMiddleware(rateLimiter *ratelimit.RateLimiter, config ratelimit.RateLimitConfig) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // è·å–ç”¨æˆ·ID
                userID, exists := c.Get("user_id")
                if !exists </span><span class="cov0" title="0">{
                        // å¦‚æœæ²¡æœ‰ç”¨æˆ·IDï¼Œä½¿ç”¨IPåœ°å€
                        userID = c.ClientIP()
                }</span>

                <span class="cov0" title="0">key := fmt.Sprintf("user:%v", userID)

                // æ£€æŸ¥é€Ÿç‡é™åˆ¶
                result, err := rateLimiter.Check(c.Request.Context(), key, config)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.WithError(err).Error("User rate limiter check failed")
                        // å¦‚æœé€Ÿç‡é™åˆ¶å™¨å‡ºé”™ï¼Œå…è®¸è¯·æ±‚ç»§ç»­
                        c.Next()
                        return
                }</span>

                // è®¾ç½®å“åº”å¤´
                <span class="cov0" title="0">c.Header("X-RateLimit-Limit", strconv.FormatInt(result.Limit, 10))
                c.Header("X-RateLimit-Remaining", strconv.FormatInt(result.Remaining, 10))
                c.Header("X-RateLimit-Reset", strconv.FormatInt(result.ResetTime.Unix(), 10))

                // å¦‚æœè¶…è¿‡é™åˆ¶ï¼Œè¿”å›429é”™è¯¯
                if !result.Allowed </span><span class="cov0" title="0">{
                        c.Header("Retry-After", strconv.FormatInt(int64(result.RetryAfter.Seconds()), 10))
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error":       "User rate limit exceeded",
                                "message":     "Too many requests for this user",
                                "retry_after": int64(result.RetryAfter.Seconds()),
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// TenantRateLimitMiddleware ç§Ÿæˆ·é€Ÿç‡é™åˆ¶ä¸­é—´ä»¶
func TenantRateLimitMiddleware(rateLimiter *ratelimit.RateLimiter, config ratelimit.RateLimitConfig) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // è·å–ç§Ÿæˆ·ID
                tenantID, exists := c.Get("tenant_id")
                if !exists </span><span class="cov0" title="0">{
                        // å¦‚æœæ²¡æœ‰ç§Ÿæˆ·IDï¼Œè·³è¿‡é€Ÿç‡é™åˆ¶
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">key := fmt.Sprintf("tenant:%v", tenantID)

                // æ£€æŸ¥é€Ÿç‡é™åˆ¶
                result, err := rateLimiter.Check(c.Request.Context(), key, config)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.WithError(err).Error("Tenant rate limiter check failed")
                        // å¦‚æœé€Ÿç‡é™åˆ¶å™¨å‡ºé”™ï¼Œå…è®¸è¯·æ±‚ç»§ç»­
                        c.Next()
                        return
                }</span>

                // è®¾ç½®å“åº”å¤´
                <span class="cov0" title="0">c.Header("X-RateLimit-Limit", strconv.FormatInt(result.Limit, 10))
                c.Header("X-RateLimit-Remaining", strconv.FormatInt(result.Remaining, 10))
                c.Header("X-RateLimit-Reset", strconv.FormatInt(result.ResetTime.Unix(), 10))

                // å¦‚æœè¶…è¿‡é™åˆ¶ï¼Œè¿”å›429é”™è¯¯
                if !result.Allowed </span><span class="cov0" title="0">{
                        c.Header("Retry-After", strconv.FormatInt(int64(result.RetryAfter.Seconds()), 10))
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error":       "Tenant rate limit exceeded",
                                "message":     "Too many requests for this tenant",
                                "retry_after": int64(result.RetryAfter.Seconds()),
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// EndpointRateLimitMiddleware ç«¯ç‚¹ç‰¹å®šé€Ÿç‡é™åˆ¶ä¸­é—´ä»¶
func EndpointRateLimitMiddleware(rateLimiter *ratelimit.RateLimiter, endpoint string, config ratelimit.RateLimitConfig) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // ç»„åˆé”®ï¼šIP + ç«¯ç‚¹
                clientIP := c.ClientIP()
                key := fmt.Sprintf("endpoint:%s:ip:%s", endpoint, clientIP)

                // æ£€æŸ¥é€Ÿç‡é™åˆ¶
                result, err := rateLimiter.Check(c.Request.Context(), key, config)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.WithError(err).Error("Endpoint rate limiter check failed")
                        // å¦‚æœé€Ÿç‡é™åˆ¶å™¨å‡ºé”™ï¼Œå…è®¸è¯·æ±‚ç»§ç»­
                        c.Next()
                        return
                }</span>

                // è®¾ç½®å“åº”å¤´
                <span class="cov0" title="0">c.Header("X-RateLimit-Limit", strconv.FormatInt(result.Limit, 10))
                c.Header("X-RateLimit-Remaining", strconv.FormatInt(result.Remaining, 10))
                c.Header("X-RateLimit-Reset", strconv.FormatInt(result.ResetTime.Unix(), 10))

                // å¦‚æœè¶…è¿‡é™åˆ¶ï¼Œè¿”å›429é”™è¯¯
                if !result.Allowed </span><span class="cov0" title="0">{
                        c.Header("Retry-After", strconv.FormatInt(int64(result.RetryAfter.Seconds()), 10))
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error":       "Endpoint rate limit exceeded",
                                "message":     fmt.Sprintf("Too many requests to %s", endpoint),
                                "retry_after": int64(result.RetryAfter.Seconds()),
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// AdaptiveRateLimitMiddleware è‡ªé€‚åº”é€Ÿç‡é™åˆ¶ä¸­é—´ä»¶
func AdaptiveRateLimitMiddleware(rateLimiter *ratelimit.RateLimiter, baseConfig ratelimit.RateLimitConfig) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                clientIP := c.ClientIP()
                key := fmt.Sprintf("adaptive:ip:%s", clientIP)

                // è·å–å½“å‰è´Ÿè½½æƒ…å†µï¼ˆè¿™é‡Œç®€åŒ–å®ç°ï¼‰
                // å®é™…åº”ç”¨ä¸­å¯ä»¥æ ¹æ®ç³»ç»Ÿè´Ÿè½½ã€é”™è¯¯ç‡ç­‰åŠ¨æ€è°ƒæ•´é™åˆ¶
                config := baseConfig

                // æ£€æŸ¥æ˜¯å¦æ˜¯å¯ä¿¡IPï¼ˆä¾‹å¦‚å†…ç½‘IPï¼‰
                if isInternalIP(clientIP) </span><span class="cov0" title="0">{
                        // å†…ç½‘IPç»™äºˆæ›´é«˜çš„é™åˆ¶
                        config.Limit = config.Limit * 2
                }</span>

                // æ£€æŸ¥é€Ÿç‡é™åˆ¶
                <span class="cov0" title="0">result, err := rateLimiter.Check(c.Request.Context(), key, config)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.WithError(err).Error("Adaptive rate limiter check failed")
                        c.Next()
                        return
                }</span>

                // è®¾ç½®å“åº”å¤´
                <span class="cov0" title="0">c.Header("X-RateLimit-Limit", strconv.FormatInt(result.Limit, 10))
                c.Header("X-RateLimit-Remaining", strconv.FormatInt(result.Remaining, 10))
                c.Header("X-RateLimit-Reset", strconv.FormatInt(result.ResetTime.Unix(), 10))

                if !result.Allowed </span><span class="cov0" title="0">{
                        c.Header("Retry-After", strconv.FormatInt(int64(result.RetryAfter.Seconds()), 10))
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error":       "Rate limit exceeded",
                                "message":     "Too many requests",
                                "retry_after": int64(result.RetryAfter.Seconds()),
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// isInternalIP æ£€æŸ¥æ˜¯å¦æ˜¯å†…ç½‘IP
func isInternalIP(ip string) bool <span class="cov0" title="0">{
        // ç®€åŒ–å®ç°ï¼Œå®é™…åº”ç”¨ä¸­åº”è¯¥æ›´å®Œå–„
        return ip == "127.0.0.1" || ip == "::1" ||
                (len(ip) &gt;= 7 &amp;&amp; ip[:7] == "192.168") ||
                (len(ip) &gt;= 3 &amp;&amp; ip[:3] == "10.") ||
                (len(ip) &gt;= 7 &amp;&amp; ip[:7] == "172.16")
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package middleware

import (
        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

const RequestIDKey = "X-Request-ID"

// RequestID è¯·æ±‚IDä¸­é—´ä»¶
func RequestID() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                requestID := c.GetHeader(RequestIDKey)
                if requestID == "" </span><span class="cov0" title="0">{
                        requestID = uuid.New().String()
                }</span>

                <span class="cov0" title="0">c.Header(RequestIDKey, requestID)
                c.Set("request_id", requestID)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package middleware

import (
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/sirupsen/logrus"
)

// VoiceMetrics è¯­éŸ³ç›¸å…³æŒ‡æ ‡
type VoiceMetrics struct {
        // ASR æŒ‡æ ‡
        ASRLatency       time.Duration
        ASRAccuracy      float64
        ASRWordErrorRate float64

        // TTS æŒ‡æ ‡
        TTSLatency       time.Duration
        TTSFirstAudio    time.Duration
        TTSInterruptTime time.Duration

        // å¯¹è¯æŒ‡æ ‡
        EndToEndLatency    time.Duration
        BargeInSuccessRate float64
        CancelResponseTime time.Duration

        // è´¨é‡æŒ‡æ ‡
        AudioQuality   float64
        NetworkLatency time.Duration
}

// VoiceMetricsCollector è¯­éŸ³æŒ‡æ ‡æ”¶é›†å™¨
type VoiceMetricsCollector struct {
        metrics map[string]*VoiceMetrics
}

func NewVoiceMetricsCollector() *VoiceMetricsCollector <span class="cov0" title="0">{
        return &amp;VoiceMetricsCollector{
                metrics: make(map[string]*VoiceMetrics),
        }
}</span>

// VoiceMetricsMiddleware è¯­éŸ³æŒ‡æ ‡ä¸­é—´ä»¶
func VoiceMetricsMiddleware(collector *VoiceMetricsCollector) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()

                // å¤„ç†è¯·æ±‚
                c.Next()

                // æ”¶é›†æŒ‡æ ‡
                duration := time.Since(start)
                path := c.Request.URL.Path
                method := c.Request.Method
                status := c.Writer.Status()

                // è®°å½•è¯­éŸ³ç›¸å…³æŒ‡æ ‡
                if isVoiceEndpoint(path) </span><span class="cov0" title="0">{
                        collector.recordMetrics(c, duration, status)
                }</span>

                // è®°å½•æ—¥å¿—
                <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                        "method":   method,
                        "path":     path,
                        "status":   status,
                        "duration": duration,
                        "type":     "voice_request",
                }).Info("Voice request processed")</span>
        }
}

func (c *VoiceMetricsCollector) recordMetrics(ctx *gin.Context, duration time.Duration, status int) <span class="cov0" title="0">{
        sessionID := ctx.GetHeader("X-Session-ID")
        if sessionID == "" </span><span class="cov0" title="0">{
                sessionID = "unknown"
        }</span>

        <span class="cov0" title="0">if _, exists := c.metrics[sessionID]; !exists </span><span class="cov0" title="0">{
                c.metrics[sessionID] = &amp;VoiceMetrics{}
        }</span>

        <span class="cov0" title="0">metrics := c.metrics[sessionID]
        path := ctx.Request.URL.Path

        switch </span>{
        case path == "/api/voice/stream":<span class="cov0" title="0">
                // WebSocket è¿æ¥æŒ‡æ ‡
                metrics.NetworkLatency = duration</span>

        case path == "/api/chat/cancel":<span class="cov0" title="0">
                // å–æ¶ˆè¯·æ±‚å“åº”æ—¶é—´
                metrics.CancelResponseTime = duration

                // è®°å½• Barge-in æˆåŠŸç‡
                if status == 200 </span><span class="cov0" title="0">{
                        // æˆåŠŸå–æ¶ˆ
                        logrus.WithFields(logrus.Fields{
                                "session_id":  sessionID,
                                "cancel_time": duration,
                                "status":      "success",
                        }).Info("Barge-in cancel successful")
                }</span>
        }

        // è®°å½•ç«¯åˆ°ç«¯å»¶è¿Ÿ
        <span class="cov0" title="0">if endToEndStart := ctx.GetHeader("X-Start-Time"); endToEndStart != "" </span><span class="cov0" title="0">{
                if startTime, err := strconv.ParseInt(endToEndStart, 10, 64); err == nil </span><span class="cov0" title="0">{
                        metrics.EndToEndLatency = time.Since(time.Unix(0, startTime*int64(time.Millisecond)))
                }</span>
        }
}

// RecordASRMetrics è®°å½• ASR æŒ‡æ ‡
func (c *VoiceMetricsCollector) RecordASRMetrics(sessionID string, latency time.Duration, accuracy float64) <span class="cov0" title="0">{
        if _, exists := c.metrics[sessionID]; !exists </span><span class="cov0" title="0">{
                c.metrics[sessionID] = &amp;VoiceMetrics{}
        }</span>

        <span class="cov0" title="0">metrics := c.metrics[sessionID]
        metrics.ASRLatency = latency
        metrics.ASRAccuracy = accuracy

        logrus.WithFields(logrus.Fields{
                "session_id":   sessionID,
                "asr_latency":  latency,
                "asr_accuracy": accuracy,
        }).Info("ASR metrics recorded")</span>
}

// RecordTTSMetrics è®°å½• TTS æŒ‡æ ‡
func (c *VoiceMetricsCollector) RecordTTSMetrics(sessionID string, latency, firstAudio time.Duration) <span class="cov0" title="0">{
        if _, exists := c.metrics[sessionID]; !exists </span><span class="cov0" title="0">{
                c.metrics[sessionID] = &amp;VoiceMetrics{}
        }</span>

        <span class="cov0" title="0">metrics := c.metrics[sessionID]
        metrics.TTSLatency = latency
        metrics.TTSFirstAudio = firstAudio

        logrus.WithFields(logrus.Fields{
                "session_id":      sessionID,
                "tts_latency":     latency,
                "tts_first_audio": firstAudio,
        }).Info("TTS metrics recorded")</span>
}

// RecordBargeInMetrics è®°å½•æ‰“æ–­æŒ‡æ ‡
func (c *VoiceMetricsCollector) RecordBargeInMetrics(sessionID string, interruptTime time.Duration, success bool) <span class="cov0" title="0">{
        if _, exists := c.metrics[sessionID]; !exists </span><span class="cov0" title="0">{
                c.metrics[sessionID] = &amp;VoiceMetrics{}
        }</span>

        <span class="cov0" title="0">metrics := c.metrics[sessionID]
        metrics.TTSInterruptTime = interruptTime

        if success </span><span class="cov0" title="0">{
                metrics.BargeInSuccessRate = 1.0
        }</span> else<span class="cov0" title="0"> {
                metrics.BargeInSuccessRate = 0.0
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "session_id":     sessionID,
                "interrupt_time": interruptTime,
                "success":        success,
        }).Info("Barge-in metrics recorded")</span>
}

// GetMetrics è·å–ä¼šè¯æŒ‡æ ‡
func (c *VoiceMetricsCollector) GetMetrics(sessionID string) *VoiceMetrics <span class="cov0" title="0">{
        if metrics, exists := c.metrics[sessionID]; exists </span><span class="cov0" title="0">{
                return metrics
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetAllMetrics è·å–æ‰€æœ‰æŒ‡æ ‡
func (c *VoiceMetricsCollector) GetAllMetrics() map[string]*VoiceMetrics <span class="cov0" title="0">{
        return c.metrics
}</span>

// CleanupMetrics æ¸…ç†è¿‡æœŸæŒ‡æ ‡
func (c *VoiceMetricsCollector) CleanupMetrics(maxAge time.Duration) {<span class="cov0" title="0">
        // å®ç°æŒ‡æ ‡æ¸…ç†é€»è¾‘
        // è¿™é‡Œå¯ä»¥æ ¹æ®æ—¶é—´æˆ³æ¸…ç†è¿‡æœŸçš„æŒ‡æ ‡æ•°æ®
}</span>

// ExportPrometheusMetrics å¯¼å‡º Prometheus æ ¼å¼æŒ‡æ ‡
func (c *VoiceMetricsCollector) ExportPrometheusMetrics() string <span class="cov0" title="0">{
        // å®ç° Prometheus æŒ‡æ ‡å¯¼å‡º
        // è¿”å›ç¬¦åˆ Prometheus æ ¼å¼çš„æŒ‡æ ‡å­—ç¬¦ä¸²
        return ""
}</span>

func isVoiceEndpoint(path string) bool <span class="cov0" title="0">{
        voiceEndpoints := []string{
                "/api/voice/stream",
                "/api/chat/cancel",
        }

        for _, endpoint := range voiceEndpoints </span><span class="cov0" title="0">{
                if path == endpoint </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package monitoring

import (
        "context"
        "encoding/json"
        "fmt"
        "runtime"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// MemoryStats å†…å­˜ç»Ÿè®¡ä¿¡æ¯
type MemoryStats struct {
        // Goè¿è¡Œæ—¶å†…å­˜ç»Ÿè®¡
        Alloc         uint64  `json:"alloc"`           // å½“å‰åˆ†é…çš„å­—èŠ‚æ•°
        TotalAlloc    uint64  `json:"total_alloc"`     // ç´¯è®¡åˆ†é…çš„å­—èŠ‚æ•°
        Sys           uint64  `json:"sys"`             // ä»ç³»ç»Ÿè·å¾—çš„å­—èŠ‚æ•°
        Lookups       uint64  `json:"lookups"`         // æŒ‡é’ˆæŸ¥æ‰¾æ¬¡æ•°
        Mallocs       uint64  `json:"mallocs"`         // åˆ†é…æ¬¡æ•°
        Frees         uint64  `json:"frees"`           // é‡Šæ”¾æ¬¡æ•°
        HeapAlloc     uint64  `json:"heap_alloc"`      // å †åˆ†é…å­—èŠ‚æ•°
        HeapSys       uint64  `json:"heap_sys"`        // å †ç³»ç»Ÿå­—èŠ‚æ•°
        HeapIdle      uint64  `json:"heap_idle"`       // å †ç©ºé—²å­—èŠ‚æ•°
        HeapInuse     uint64  `json:"heap_inuse"`      // å †ä½¿ç”¨å­—èŠ‚æ•°
        HeapReleased  uint64  `json:"heap_released"`   // é‡Šæ”¾ç»™ç³»ç»Ÿçš„å­—èŠ‚æ•°
        HeapObjects   uint64  `json:"heap_objects"`    // å †å¯¹è±¡æ•°é‡
        StackInuse    uint64  `json:"stack_inuse"`     // æ ˆä½¿ç”¨å­—èŠ‚æ•°
        StackSys      uint64  `json:"stack_sys"`       // æ ˆç³»ç»Ÿå­—èŠ‚æ•°
        MSpanInuse    uint64  `json:"mspan_inuse"`     // MSpanä½¿ç”¨å­—èŠ‚æ•°
        MSpanSys      uint64  `json:"mspan_sys"`       // MSpanç³»ç»Ÿå­—èŠ‚æ•°
        MCacheInuse   uint64  `json:"mcache_inuse"`    // MCacheä½¿ç”¨å­—èŠ‚æ•°
        MCacheSys     uint64  `json:"mcache_sys"`      // MCacheç³»ç»Ÿå­—èŠ‚æ•°
        BuckHashSys   uint64  `json:"buckhash_sys"`    // åˆ†æå“ˆå¸Œè¡¨å­—èŠ‚æ•°
        GCSys         uint64  `json:"gc_sys"`          // GCç³»ç»Ÿå­—èŠ‚æ•°
        OtherSys      uint64  `json:"other_sys"`       // å…¶ä»–ç³»ç»Ÿå­—èŠ‚æ•°
        NextGC        uint64  `json:"next_gc"`         // ä¸‹æ¬¡GCç›®æ ‡
        LastGC        uint64  `json:"last_gc"`         // ä¸Šæ¬¡GCæ—¶é—´
        PauseTotalNs  uint64  `json:"pause_total_ns"`  // GCæš‚åœæ€»æ—¶é—´
        PauseNs       uint64  `json:"pause_ns"`        // æœ€è¿‘GCæš‚åœæ—¶é—´
        NumGC         uint32  `json:"num_gc"`          // GCæ¬¡æ•°
        NumForcedGC   uint32  `json:"num_forced_gc"`   // å¼ºåˆ¶GCæ¬¡æ•°
        GCCPUFraction float64 `json:"gc_cpu_fraction"` // GC CPUå ç”¨æ¯”ä¾‹

        // è®¡ç®—å­—æ®µ
        AllocMB     float64 `json:"alloc_mb"`      // å½“å‰åˆ†é…MB
        SysMB       float64 `json:"sys_mb"`        // ç³»ç»Ÿå†…å­˜MB
        HeapAllocMB float64 `json:"heap_alloc_mb"` // å †åˆ†é…MB
        HeapSysMB   float64 `json:"heap_sys_mb"`   // å †ç³»ç»ŸMB
        MemoryUsage float64 `json:"memory_usage"`  // å†…å­˜ä½¿ç”¨ç‡

        // æ—¶é—´æˆ³
        Timestamp time.Time `json:"timestamp"`
}

// MemoryAlert å†…å­˜å‘Šè­¦
type MemoryAlert struct {
        Level      string    `json:"level"`       // å‘Šè­¦çº§åˆ«
        Message    string    `json:"message"`     // å‘Šè­¦æ¶ˆæ¯
        Threshold  float64   `json:"threshold"`   // é˜ˆå€¼
        CurrentVal float64   `json:"current_val"` // å½“å‰å€¼
        Timestamp  time.Time `json:"timestamp"`   // æ—¶é—´æˆ³
}

// MemoryThresholds å†…å­˜é˜ˆå€¼é…ç½®
type MemoryThresholds struct {
        AllocWarning   uint64  `json:"alloc_warning"`    // åˆ†é…å†…å­˜è­¦å‘Šé˜ˆå€¼(MB)
        AllocCritical  uint64  `json:"alloc_critical"`   // åˆ†é…å†…å­˜ä¸¥é‡é˜ˆå€¼(MB)
        HeapWarning    uint64  `json:"heap_warning"`     // å †å†…å­˜è­¦å‘Šé˜ˆå€¼(MB)
        HeapCritical   uint64  `json:"heap_critical"`    // å †å†…å­˜ä¸¥é‡é˜ˆå€¼(MB)
        UsageWarning   float64 `json:"usage_warning"`    // ä½¿ç”¨ç‡è­¦å‘Šé˜ˆå€¼(%)
        UsageCritical  float64 `json:"usage_critical"`   // ä½¿ç”¨ç‡ä¸¥é‡é˜ˆå€¼(%)
        GCFreqWarning  uint32  `json:"gc_freq_warning"`  // GCé¢‘ç‡è­¦å‘Šé˜ˆå€¼(æ¬¡/åˆ†é’Ÿ)
        GCFreqCritical uint32  `json:"gc_freq_critical"` // GCé¢‘ç‡ä¸¥é‡é˜ˆå€¼(æ¬¡/åˆ†é’Ÿ)
}

// DefaultMemoryThresholds é»˜è®¤å†…å­˜é˜ˆå€¼
func DefaultMemoryThresholds() *MemoryThresholds <span class="cov0" title="0">{
        return &amp;MemoryThresholds{
                AllocWarning:   512,  // 512MB
                AllocCritical:  1024, // 1GB
                HeapWarning:    256,  // 256MB
                HeapCritical:   512,  // 512MB
                UsageWarning:   80.0, // 80%
                UsageCritical:  90.0, // 90%
                GCFreqWarning:  10,   // 10æ¬¡/åˆ†é’Ÿ
                GCFreqCritical: 20,   // 20æ¬¡/åˆ†é’Ÿ
        }
}</span>

// MemoryMonitor å†…å­˜ç›‘æ§å™¨
type MemoryMonitor struct {
        mu          sync.RWMutex
        thresholds  *MemoryThresholds
        logger      *logrus.Logger
        alertChan   chan *MemoryAlert
        stopChan    chan struct{}
        interval    time.Duration
        lastStats   *MemoryStats
        gcCount     uint32
        gcCountTime time.Time

        // å†å²æ•°æ®
        history    []*MemoryStats
        maxHistory int
}

// NewMemoryMonitor åˆ›å»ºå†…å­˜ç›‘æ§å™¨
func NewMemoryMonitor(thresholds *MemoryThresholds, interval time.Duration) *MemoryMonitor <span class="cov0" title="0">{
        if thresholds == nil </span><span class="cov0" title="0">{
                thresholds = DefaultMemoryThresholds()
        }</span>
        <span class="cov0" title="0">if interval == 0 </span><span class="cov0" title="0">{
                interval = 30 * time.Second
        }</span>

        <span class="cov0" title="0">return &amp;MemoryMonitor{
                thresholds:  thresholds,
                logger:      logrus.New(),
                alertChan:   make(chan *MemoryAlert, 100),
                stopChan:    make(chan struct{}),
                interval:    interval,
                gcCountTime: time.Now(),
                history:     make([]*MemoryStats, 0),
                maxHistory:  100, // ä¿ç•™æœ€è¿‘100ä¸ªæ•°æ®ç‚¹
        }</span>
}

// Start å¯åŠ¨å†…å­˜ç›‘æ§
func (m *MemoryMonitor) Start(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(m.interval)
        defer ticker.Stop()

        m.logger.Info("Memory monitor started")

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        m.logger.Info("Memory monitor stopped by context")
                        return</span>
                case &lt;-m.stopChan:<span class="cov0" title="0">
                        m.logger.Info("Memory monitor stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        stats := m.collectStats()
                        m.checkThresholds(stats)
                        m.addToHistory(stats)</span>
                }
        }
}

// Stop åœæ­¢å†…å­˜ç›‘æ§
func (m *MemoryMonitor) Stop() <span class="cov0" title="0">{
        close(m.stopChan)
}</span>

// GetAlertChannel è·å–å‘Šè­¦é€šé“
func (m *MemoryMonitor) GetAlertChannel() &lt;-chan *MemoryAlert <span class="cov0" title="0">{
        return m.alertChan
}</span>

// collectStats æ”¶é›†å†…å­˜ç»Ÿè®¡ä¿¡æ¯
func (m *MemoryMonitor) collectStats() *MemoryStats <span class="cov0" title="0">{
        var ms runtime.MemStats
        runtime.ReadMemStats(&amp;ms)

        stats := &amp;MemoryStats{
                Alloc:         ms.Alloc,
                TotalAlloc:    ms.TotalAlloc,
                Sys:           ms.Sys,
                Lookups:       ms.Lookups,
                Mallocs:       ms.Mallocs,
                Frees:         ms.Frees,
                HeapAlloc:     ms.HeapAlloc,
                HeapSys:       ms.HeapSys,
                HeapIdle:      ms.HeapIdle,
                HeapInuse:     ms.HeapInuse,
                HeapReleased:  ms.HeapReleased,
                HeapObjects:   ms.HeapObjects,
                StackInuse:    ms.StackInuse,
                StackSys:      ms.StackSys,
                MSpanInuse:    ms.MSpanInuse,
                MSpanSys:      ms.MSpanSys,
                MCacheInuse:   ms.MCacheInuse,
                MCacheSys:     ms.MCacheSys,
                BuckHashSys:   ms.BuckHashSys,
                GCSys:         ms.GCSys,
                OtherSys:      ms.OtherSys,
                NextGC:        ms.NextGC,
                LastGC:        ms.LastGC,
                PauseTotalNs:  ms.PauseTotalNs,
                NumGC:         ms.NumGC,
                NumForcedGC:   ms.NumForcedGC,
                GCCPUFraction: ms.GCCPUFraction,
                Timestamp:     time.Now(),
        }

        // è®¡ç®—MBå€¼
        stats.AllocMB = float64(stats.Alloc) / 1024 / 1024
        stats.SysMB = float64(stats.Sys) / 1024 / 1024
        stats.HeapAllocMB = float64(stats.HeapAlloc) / 1024 / 1024
        stats.HeapSysMB = float64(stats.HeapSys) / 1024 / 1024

        // è®¡ç®—å†…å­˜ä½¿ç”¨ç‡
        if stats.Sys &gt; 0 </span><span class="cov0" title="0">{
                stats.MemoryUsage = float64(stats.Alloc) / float64(stats.Sys) * 100
        }</span>

        // è®¡ç®—æœ€è¿‘GCæš‚åœæ—¶é—´
        <span class="cov0" title="0">if len(ms.PauseNs) &gt; 0 </span><span class="cov0" title="0">{
                stats.PauseNs = ms.PauseNs[(ms.NumGC+255)%256]
        }</span>

        <span class="cov0" title="0">m.mu.Lock()
        m.lastStats = stats
        m.mu.Unlock()

        return stats</span>
}

// checkThresholds æ£€æŸ¥é˜ˆå€¼
func (m *MemoryMonitor) checkThresholds(stats *MemoryStats) <span class="cov0" title="0">{
        // æ£€æŸ¥åˆ†é…å†…å­˜
        allocMB := stats.AllocMB
        if allocMB &gt; float64(m.thresholds.AllocCritical) </span><span class="cov0" title="0">{
                m.sendAlert("critical", fmt.Sprintf("Memory allocation critical: %.2fMB", allocMB),
                        float64(m.thresholds.AllocCritical), allocMB)
        }</span> else<span class="cov0" title="0"> if allocMB &gt; float64(m.thresholds.AllocWarning) </span><span class="cov0" title="0">{
                m.sendAlert("warning", fmt.Sprintf("Memory allocation warning: %.2fMB", allocMB),
                        float64(m.thresholds.AllocWarning), allocMB)
        }</span>

        // æ£€æŸ¥å †å†…å­˜
        <span class="cov0" title="0">heapMB := stats.HeapAllocMB
        if heapMB &gt; float64(m.thresholds.HeapCritical) </span><span class="cov0" title="0">{
                m.sendAlert("critical", fmt.Sprintf("Heap memory critical: %.2fMB", heapMB),
                        float64(m.thresholds.HeapCritical), heapMB)
        }</span> else<span class="cov0" title="0"> if heapMB &gt; float64(m.thresholds.HeapWarning) </span><span class="cov0" title="0">{
                m.sendAlert("warning", fmt.Sprintf("Heap memory warning: %.2fMB", heapMB),
                        float64(m.thresholds.HeapWarning), heapMB)
        }</span>

        // æ£€æŸ¥å†…å­˜ä½¿ç”¨ç‡
        <span class="cov0" title="0">usage := stats.MemoryUsage
        if usage &gt; m.thresholds.UsageCritical </span><span class="cov0" title="0">{
                m.sendAlert("critical", fmt.Sprintf("Memory usage critical: %.2f%%", usage),
                        m.thresholds.UsageCritical, usage)
        }</span> else<span class="cov0" title="0"> if usage &gt; m.thresholds.UsageWarning </span><span class="cov0" title="0">{
                m.sendAlert("warning", fmt.Sprintf("Memory usage warning: %.2f%%", usage),
                        m.thresholds.UsageWarning, usage)
        }</span>

        // æ£€æŸ¥GCé¢‘ç‡
        <span class="cov0" title="0">m.checkGCFrequency(stats)</span>
}

// checkGCFrequency æ£€æŸ¥GCé¢‘ç‡
func (m *MemoryMonitor) checkGCFrequency(stats *MemoryStats) <span class="cov0" title="0">{
        now := time.Now()
        if m.gcCount == 0 </span><span class="cov0" title="0">{
                m.gcCount = stats.NumGC
                m.gcCountTime = now
                return
        }</span>

        <span class="cov0" title="0">duration := now.Sub(m.gcCountTime)
        if duration &gt;= time.Minute </span><span class="cov0" title="0">{
                gcDiff := stats.NumGC - m.gcCount
                gcPerMinute := float64(gcDiff) / duration.Minutes()

                if gcPerMinute &gt; float64(m.thresholds.GCFreqCritical) </span><span class="cov0" title="0">{
                        m.sendAlert("critical", fmt.Sprintf("GC frequency critical: %.2f/min", gcPerMinute),
                                float64(m.thresholds.GCFreqCritical), gcPerMinute)
                }</span> else<span class="cov0" title="0"> if gcPerMinute &gt; float64(m.thresholds.GCFreqWarning) </span><span class="cov0" title="0">{
                        m.sendAlert("warning", fmt.Sprintf("GC frequency warning: %.2f/min", gcPerMinute),
                                float64(m.thresholds.GCFreqWarning), gcPerMinute)
                }</span>

                <span class="cov0" title="0">m.gcCount = stats.NumGC
                m.gcCountTime = now</span>
        }
}

// sendAlert å‘é€å‘Šè­¦
func (m *MemoryMonitor) sendAlert(level, message string, threshold, currentVal float64) <span class="cov0" title="0">{
        alert := &amp;MemoryAlert{
                Level:      level,
                Message:    message,
                Threshold:  threshold,
                CurrentVal: currentVal,
                Timestamp:  time.Now(),
        }

        select </span>{
        case m.alertChan &lt;- alert:<span class="cov0" title="0">
                m.logger.WithFields(logrus.Fields{
                        "level":       level,
                        "threshold":   threshold,
                        "current_val": currentVal,
                }).Warn(message)</span>
        default:<span class="cov0" title="0">
                m.logger.Warn("Alert channel full, dropping alert")</span>
        }
}

// addToHistory æ·»åŠ åˆ°å†å²è®°å½•
func (m *MemoryMonitor) addToHistory(stats *MemoryStats) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.history = append(m.history, stats)
        if len(m.history) &gt; m.maxHistory </span><span class="cov0" title="0">{
                m.history = m.history[1:]
        }</span>
}

// GetCurrentStats è·å–å½“å‰ç»Ÿè®¡ä¿¡æ¯
func (m *MemoryMonitor) GetCurrentStats() *MemoryStats <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.lastStats == nil </span><span class="cov0" title="0">{
                return m.collectStats()
        }</span>

        <span class="cov0" title="0">return m.lastStats</span>
}

// GetHistory è·å–å†å²æ•°æ®
func (m *MemoryMonitor) GetHistory() []*MemoryStats <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        history := make([]*MemoryStats, len(m.history))
        copy(history, m.history)
        return history
}</span>

// GetSummary è·å–å†…å­˜æ‘˜è¦
func (m *MemoryMonitor) GetSummary() map[string]interface{} <span class="cov0" title="0">{
        stats := m.GetCurrentStats()

        return map[string]interface{}{
                "current_alloc_mb": stats.AllocMB,
                "heap_alloc_mb":    stats.HeapAllocMB,
                "sys_mb":           stats.SysMB,
                "memory_usage_pct": stats.MemoryUsage,
                "gc_count":         stats.NumGC,
                "gc_cpu_fraction":  stats.GCCPUFraction,
                "heap_objects":     stats.HeapObjects,
                "goroutines":       runtime.NumGoroutine(),
                "timestamp":        stats.Timestamp,
        }
}</span>

// ForceGC å¼ºåˆ¶åƒåœ¾å›æ”¶
func (m *MemoryMonitor) ForceGC() <span class="cov0" title="0">{
        m.logger.Info("Forcing garbage collection")
        runtime.GC()
        runtime.GC() // è°ƒç”¨ä¸¤æ¬¡ç¡®ä¿å½»åº•æ¸…ç†
}</span>

// GetMemoryProfile è·å–å†…å­˜åˆ†ææ•°æ®
func (m *MemoryMonitor) GetMemoryProfile() ([]byte, error) <span class="cov0" title="0">{
        stats := m.GetCurrentStats()
        return json.MarshalIndent(stats, "", "  ")
}</span>

// MemoryHealthCheck å†…å­˜å¥åº·æ£€æŸ¥
func (m *MemoryMonitor) MemoryHealthCheck() (bool, string) <span class="cov0" title="0">{
        stats := m.GetCurrentStats()

        // æ£€æŸ¥å…³é”®æŒ‡æ ‡
        if stats.AllocMB &gt; float64(m.thresholds.AllocCritical) </span><span class="cov0" title="0">{
                return false, fmt.Sprintf("Memory allocation too high: %.2fMB", stats.AllocMB)
        }</span>

        <span class="cov0" title="0">if stats.HeapAllocMB &gt; float64(m.thresholds.HeapCritical) </span><span class="cov0" title="0">{
                return false, fmt.Sprintf("Heap memory too high: %.2fMB", stats.HeapAllocMB)
        }</span>

        <span class="cov0" title="0">if stats.MemoryUsage &gt; m.thresholds.UsageCritical </span><span class="cov0" title="0">{
                return false, fmt.Sprintf("Memory usage too high: %.2f%%", stats.MemoryUsage)
        }</span>

        <span class="cov0" title="0">return true, "Memory usage is healthy"</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package ratelimit

import (
        "context"
        "fmt"
        "strconv"
        "time"

        "github.com/redis/go-redis/v9"
        "github.com/sirupsen/logrus"
)

// RateLimiter Redisé€Ÿç‡é™åˆ¶å™¨
type RateLimiter struct {
        client *redis.Client
        prefix string
}

// RateLimitConfig é€Ÿç‡é™åˆ¶é…ç½®
type RateLimitConfig struct {
        Limit  int           // é™åˆ¶æ¬¡æ•°
        Window time.Duration // æ—¶é—´çª—å£
}

// RateLimitResult é€Ÿç‡é™åˆ¶ç»“æœ
type RateLimitResult struct {
        Allowed    bool          // æ˜¯å¦å…è®¸
        Count      int64         // å½“å‰è®¡æ•°
        Limit      int64         // é™åˆ¶æ•°é‡
        Remaining  int64         // å‰©ä½™æ¬¡æ•°
        ResetTime  time.Time     // é‡ç½®æ—¶é—´
        RetryAfter time.Duration // é‡è¯•é—´éš”
}

// NewRateLimiter åˆ›å»ºRedisé€Ÿç‡é™åˆ¶å™¨
func NewRateLimiter(client *redis.Client, prefix string) *RateLimiter <span class="cov0" title="0">{
        return &amp;RateLimiter{
                client: client,
                prefix: prefix,
        }
}</span>

// Check æ£€æŸ¥é€Ÿç‡é™åˆ¶ï¼ˆæ»‘åŠ¨çª—å£ç®—æ³•ï¼‰
func (rl *RateLimiter) Check(ctx context.Context, key string, config RateLimitConfig) (*RateLimitResult, error) <span class="cov0" title="0">{
        fullKey := rl.buildKey(key)
        now := time.Now()
        windowStart := now.Add(-config.Window)

        // ä½¿ç”¨Luaè„šæœ¬ç¡®ä¿åŸå­æ€§
        luaScript := `
                local key = KEYS[1]
                local window_start = tonumber(ARGV[1])
                local now = tonumber(ARGV[2])
                local limit = tonumber(ARGV[3])
                local window_seconds = tonumber(ARGV[4])

                -- æ¸…ç†è¿‡æœŸè®°å½•
                redis.call('ZREMRANGEBYSCORE', key, '-inf', window_start)
                
                -- è·å–å½“å‰è®¡æ•°
                local current = redis.call('ZCARD', key)
                
                -- æ£€æŸ¥æ˜¯å¦è¶…é™
                if current &gt;= limit then
                        local oldest = redis.call('ZRANGE', key, 0, 0, 'WITHSCORES')
                        local reset_time = window_start + window_seconds
                        if #oldest &gt; 0 then
                                reset_time = oldest[2] + window_seconds
                        end
                        return {0, current, limit, 0, reset_time}
                end
                
                -- æ·»åŠ å½“å‰è¯·æ±‚
                redis.call('ZADD', key, now, now)
                redis.call('EXPIRE', key, window_seconds + 1)
                
                local new_count = current + 1
                local remaining = limit - new_count
                local reset_time = now + window_seconds
                
                return {1, new_count, limit, remaining, reset_time}
        `

        result, err := rl.client.Eval(ctx, luaScript, []string{fullKey},
                windowStart.Unix(),
                now.Unix(),
                config.Limit,
                int(config.Window.Seconds()),
        ).Result()

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute rate limit check: %w", err)
        }</span>

        // è§£æç»“æœ
        <span class="cov0" title="0">values, ok := result.([]interface{})
        if !ok || len(values) != 5 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected result format")
        }</span>

        <span class="cov0" title="0">allowed := values[0].(int64) == 1
        count := values[1].(int64)
        limit := values[2].(int64)
        remaining := values[3].(int64)
        resetTime := time.Unix(values[4].(int64), 0)

        var retryAfter time.Duration
        if !allowed </span><span class="cov0" title="0">{
                retryAfter = time.Until(resetTime)
                if retryAfter &lt; 0 </span><span class="cov0" title="0">{
                        retryAfter = 0
                }</span>
        }

        <span class="cov0" title="0">return &amp;RateLimitResult{
                Allowed:    allowed,
                Count:      count,
                Limit:      limit,
                Remaining:  remaining,
                ResetTime:  resetTime,
                RetryAfter: retryAfter,
        }, nil</span>
}

// CheckFixed æ£€æŸ¥é€Ÿç‡é™åˆ¶ï¼ˆå›ºå®šçª—å£ç®—æ³•ï¼‰
func (rl *RateLimiter) CheckFixed(ctx context.Context, key string, config RateLimitConfig) (*RateLimitResult, error) <span class="cov0" title="0">{
        now := time.Now()
        windowStart := now.Truncate(config.Window)
        fullKey := rl.buildKey(fmt.Sprintf("%s:%d", key, windowStart.Unix()))

        // ä½¿ç”¨Luaè„šæœ¬ç¡®ä¿åŸå­æ€§
        luaScript := `
                local key = KEYS[1]
                local limit = tonumber(ARGV[1])
                local window_seconds = tonumber(ARGV[2])
                local now = tonumber(ARGV[3])
                
                local current = redis.call('GET', key)
                if current == false then
                        current = 0
                else
                        current = tonumber(current)
                end
                
                if current &gt;= limit then
                        local ttl = redis.call('TTL', key)
                        local reset_time = now + ttl
                        return {0, current, limit, 0, reset_time}
                end
                
                local new_count = redis.call('INCR', key)
                if new_count == 1 then
                        redis.call('EXPIRE', key, window_seconds)
                end
                
                local remaining = limit - new_count
                local reset_time = now + window_seconds
                
                return {1, new_count, limit, remaining, reset_time}
        `

        result, err := rl.client.Eval(ctx, luaScript, []string{fullKey},
                config.Limit,
                int(config.Window.Seconds()),
                now.Unix(),
        ).Result()

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute fixed rate limit check: %w", err)
        }</span>

        // è§£æç»“æœ
        <span class="cov0" title="0">values, ok := result.([]interface{})
        if !ok || len(values) != 5 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected result format")
        }</span>

        <span class="cov0" title="0">allowed := values[0].(int64) == 1
        count := values[1].(int64)
        limit := values[2].(int64)
        remaining := values[3].(int64)
        resetTime := time.Unix(values[4].(int64), 0)

        var retryAfter time.Duration
        if !allowed </span><span class="cov0" title="0">{
                retryAfter = time.Until(resetTime)
                if retryAfter &lt; 0 </span><span class="cov0" title="0">{
                        retryAfter = 0
                }</span>
        }

        <span class="cov0" title="0">return &amp;RateLimitResult{
                Allowed:    allowed,
                Count:      count,
                Limit:      limit,
                Remaining:  remaining,
                ResetTime:  resetTime,
                RetryAfter: retryAfter,
        }, nil</span>
}

// CheckToken æ£€æŸ¥ä»¤ç‰Œæ¡¶é™åˆ¶
func (rl *RateLimiter) CheckToken(ctx context.Context, key string, config RateLimitConfig) (*RateLimitResult, error) <span class="cov0" title="0">{
        fullKey := rl.buildKey(key)
        now := time.Now()

        // ä»¤ç‰Œæ¡¶ç®—æ³•Luaè„šæœ¬
        luaScript := `
                local key = KEYS[1]
                local capacity = tonumber(ARGV[1])
                local refill_rate = tonumber(ARGV[2])
                local now = tonumber(ARGV[3])
                local requested = tonumber(ARGV[4]) or 1
                
                local bucket = redis.call('HMGET', key, 'tokens', 'last_refill')
                local tokens = tonumber(bucket[1]) or capacity
                local last_refill = tonumber(bucket[2]) or now
                
                -- è®¡ç®—éœ€è¦æ·»åŠ çš„ä»¤ç‰Œæ•°
                local elapsed = now - last_refill
                local tokens_to_add = math.floor(elapsed * refill_rate)
                tokens = math.min(capacity, tokens + tokens_to_add)
                
                -- æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„ä»¤ç‰Œ
                if tokens &gt;= requested then
                        tokens = tokens - requested
                        redis.call('HMSET', key, 'tokens', tokens, 'last_refill', now)
                        redis.call('EXPIRE', key, 3600) -- 1å°æ—¶è¿‡æœŸ
                        return {1, capacity - tokens, capacity, tokens, now + (capacity - tokens) / refill_rate}
                else
                        redis.call('HMSET', key, 'tokens', tokens, 'last_refill', now)
                        redis.call('EXPIRE', key, 3600)
                        local wait_time = (requested - tokens) / refill_rate
                        return {0, capacity - tokens, capacity, tokens, now + wait_time}
                end
        `

        // è®¡ç®—æ¯ç§’è¡¥å……çš„ä»¤ç‰Œæ•°
        refillRate := float64(config.Limit) / config.Window.Seconds()

        result, err := rl.client.Eval(ctx, luaScript, []string{fullKey},
                config.Limit, // capacity
                refillRate,   // refill_rate
                now.Unix(),   // now
                1,            // requested tokens
        ).Result()

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute token bucket check: %w", err)
        }</span>

        // è§£æç»“æœ
        <span class="cov0" title="0">values, ok := result.([]interface{})
        if !ok || len(values) != 5 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected result format")
        }</span>

        <span class="cov0" title="0">allowed := values[0].(int64) == 1
        count := values[1].(int64)
        limit := int64(config.Limit)
        remaining := values[3].(int64)
        resetTime := time.Unix(int64(values[4].(float64)), 0)

        var retryAfter time.Duration
        if !allowed </span><span class="cov0" title="0">{
                retryAfter = time.Until(resetTime)
                if retryAfter &lt; 0 </span><span class="cov0" title="0">{
                        retryAfter = 0
                }</span>
        }

        <span class="cov0" title="0">return &amp;RateLimitResult{
                Allowed:    allowed,
                Count:      count,
                Limit:      limit,
                Remaining:  remaining,
                ResetTime:  resetTime,
                RetryAfter: retryAfter,
        }, nil</span>
}

// Reset é‡ç½®é€Ÿç‡é™åˆ¶
func (rl *RateLimiter) Reset(ctx context.Context, key string) error <span class="cov0" title="0">{
        fullKey := rl.buildKey(key)
        return rl.client.Del(ctx, fullKey).Err()
}</span>

// GetStatus è·å–å½“å‰çŠ¶æ€
func (rl *RateLimiter) GetStatus(ctx context.Context, key string) (int64, error) <span class="cov0" title="0">{
        fullKey := rl.buildKey(key)

        // å°è¯•è·å–è®¡æ•°å™¨å€¼
        val, err := rl.client.Get(ctx, fullKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        return 0, nil
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }

        <span class="cov0" title="0">count, err := strconv.ParseInt(val, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                // å¦‚æœä¸æ˜¯ç®€å•è®¡æ•°å™¨ï¼Œå°è¯•è·å–æœ‰åºé›†åˆå¤§å°
                count, err = rl.client.ZCard(ctx, fullKey).Result()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        <span class="cov0" title="0">return count, nil</span>
}

// buildKey æ„å»ºå®Œæ•´çš„é”®å
func (rl *RateLimiter) buildKey(key string) string <span class="cov0" title="0">{
        if rl.prefix == "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("rate_limit:%s", key)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s:rate_limit:%s", rl.prefix, key)</span>
}

// MultiCheck æ‰¹é‡æ£€æŸ¥å¤šä¸ªé”®çš„é€Ÿç‡é™åˆ¶
func (rl *RateLimiter) MultiCheck(ctx context.Context, keys []string, config RateLimitConfig) (map[string]*RateLimitResult, error) <span class="cov0" title="0">{
        results := make(map[string]*RateLimitResult)

        for _, key := range keys </span><span class="cov0" title="0">{
                result, err := rl.Check(ctx, key, config)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.WithError(err).Errorf("Failed to check rate limit for key: %s", key)
                        // åœ¨å‡ºé”™æ—¶å…è®¸è¯·æ±‚é€šè¿‡ï¼Œé¿å…å½±å“æ­£å¸¸ä¸šåŠ¡
                        results[key] = &amp;RateLimitResult{
                                Allowed:   true,
                                Count:     0,
                                Limit:     int64(config.Limit),
                                Remaining: int64(config.Limit),
                                ResetTime: time.Now().Add(config.Window),
                        }
                        continue</span>
                }
                <span class="cov0" title="0">results[key] = result</span>
        }

        <span class="cov0" title="0">return results, nil</span>
}

// Cleanup æ¸…ç†è¿‡æœŸçš„é€Ÿç‡é™åˆ¶æ•°æ®
func (rl *RateLimiter) Cleanup(ctx context.Context, pattern string) error <span class="cov0" title="0">{
        fullPattern := rl.buildKey(pattern)

        keys, err := rl.client.Keys(ctx, fullPattern).Result()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get keys for cleanup: %w", err)
        }</span>

        <span class="cov0" title="0">if len(keys) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // æ‰¹é‡åˆ é™¤è¿‡æœŸé”®
        <span class="cov0" title="0">pipe := rl.client.Pipeline()
        for _, key := range keys </span><span class="cov0" title="0">{
                pipe.Del(ctx, key)
        }</span>

        <span class="cov0" title="0">_, err = pipe.Exec(ctx)
        return err</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package security

import (
        "encoding/json"
        "fmt"
        "os"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// AuditEvent represents a security audit event
type AuditEvent struct {
        ID        string                 `json:"id"`
        Type      string                 `json:"type"`
        UserID    string                 `json:"user_id,omitempty"`
        Resource  string                 `json:"resource,omitempty"`
        Action    string                 `json:"action,omitempty"`
        Result    string                 `json:"result"`
        IPAddress string                 `json:"ip_address,omitempty"`
        UserAgent string                 `json:"user_agent,omitempty"`
        SessionID string                 `json:"session_id,omitempty"`
        DeviceID  string                 `json:"device_id,omitempty"`
        Location  *Location              `json:"location,omitempty"`
        Metadata  map[string]interface{} `json:"metadata,omitempty"`
        Timestamp time.Time              `json:"timestamp"`
        Severity  AuditSeverity          `json:"severity"`
        Category  AuditCategory          `json:"category"`
}

// AuditSeverity represents the severity level of an audit event
type AuditSeverity string

const (
        SeverityInfo     AuditSeverity = "info"
        SeverityWarning  AuditSeverity = "warning"
        SeverityError    AuditSeverity = "error"
        SeverityCritical AuditSeverity = "critical"
)

// AuditCategory represents the category of an audit event
type AuditCategory string

const (
        CategoryAuthentication AuditCategory = "authentication"
        CategoryAuthorization  AuditCategory = "authorization"
        CategoryDataAccess     AuditCategory = "data_access"
        CategorySystemAccess   AuditCategory = "system_access"
        CategoryConfiguration  AuditCategory = "configuration"
        CategoryCompliance     AuditCategory = "compliance"
        CategorySecurity       AuditCategory = "security"
)

// AuditLogger handles security audit logging
type AuditLogger struct {
        logger     *logrus.Logger
        file       *os.File
        mu         sync.Mutex
        config     *AuditConfig
        buffer     []*AuditEvent
        bufferSize int
}

// AuditConfig contains configuration for audit logging
type AuditConfig struct {
        LogFile         string        `json:"log_file"`
        MaxFileSize     int64         `json:"max_file_size"` // bytes
        MaxFiles        int           `json:"max_files"`
        BufferSize      int           `json:"buffer_size"`
        FlushInterval   time.Duration `json:"flush_interval"`
        EnableSyslog    bool          `json:"enable_syslog"`
        SyslogAddress   string        `json:"syslog_address"`
        EnableRemoteLog bool          `json:"enable_remote_log"`
        RemoteLogURL    string        `json:"remote_log_url"`
        EncryptLogs     bool          `json:"encrypt_logs"`
        RetentionDays   int           `json:"retention_days"`
}

// NewAuditLogger creates a new audit logger
func NewAuditLogger() *AuditLogger <span class="cov0" title="0">{
        config := &amp;AuditConfig{
                LogFile:       "/var/log/chatbot/audit.log",
                MaxFileSize:   100 * 1024 * 1024, // 100MB
                MaxFiles:      10,
                BufferSize:    100,
                FlushInterval: 5 * time.Second,
                RetentionDays: 90,
        }

        logger := logrus.New()
        logger.SetFormatter(&amp;logrus.JSONFormatter{
                TimestampFormat: time.RFC3339Nano,
        })

        auditLogger := &amp;AuditLogger{
                logger:     logger,
                config:     config,
                buffer:     make([]*AuditEvent, 0, config.BufferSize),
                bufferSize: config.BufferSize,
        }

        // Initialize log file
        if err := auditLogger.initLogFile(); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to initialize audit log file: %v", err)
        }</span>

        // Start background flush routine
        <span class="cov0" title="0">go auditLogger.flushRoutine()

        return auditLogger</span>
}

// initLogFile initializes the audit log file
func (al *AuditLogger) initLogFile() error <span class="cov0" title="0">{
        // Create directory if it doesn't exist
        if err := os.MkdirAll("/var/log/chatbot", 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create log directory: %v", err)
        }</span>

        <span class="cov0" title="0">file, err := os.OpenFile(al.config.LogFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open audit log file: %v", err)
        }</span>

        <span class="cov0" title="0">al.file = file
        al.logger.SetOutput(file)

        return nil</span>
}

// LogAccessRequest logs an access request
func (al *AuditLogger) LogAccessRequest(request *AccessRequest) <span class="cov0" title="0">{
        event := &amp;AuditEvent{
                ID:        generateEventID(),
                Type:      "ACCESS_REQUEST",
                UserID:    request.UserID,
                Resource:  request.Resource,
                Action:    request.Action,
                Result:    "PENDING",
                IPAddress: request.Context.IPAddress,
                UserAgent: request.Context.UserAgent,
                SessionID: request.Context.SessionID,
                DeviceID:  request.Context.DeviceID,
                Location:  request.Context.Location,
                Metadata: map[string]interface{}{
                        "request_id": request.Context.RequestID,
                        "headers":    request.Context.Headers,
                        "claims":     request.Claims,
                },
                Timestamp: request.Timestamp,
                Severity:  SeverityInfo,
                Category:  CategorySystemAccess,
        }

        al.logEvent(event)
}</span>

// LogAccessDecision logs an access control decision
func (al *AuditLogger) LogAccessDecision(request *AccessRequest, decision *AccessDecision) <span class="cov0" title="0">{
        result := "DENIED"
        severity := SeverityWarning
        if decision.Allowed </span><span class="cov0" title="0">{
                result = "ALLOWED"
                severity = SeverityInfo
        }</span>

        <span class="cov0" title="0">event := &amp;AuditEvent{
                ID:        generateEventID(),
                Type:      "ACCESS_DECISION",
                UserID:    request.UserID,
                Resource:  request.Resource,
                Action:    request.Action,
                Result:    result,
                IPAddress: request.Context.IPAddress,
                UserAgent: request.Context.UserAgent,
                SessionID: request.Context.SessionID,
                DeviceID:  request.Context.DeviceID,
                Location:  request.Context.Location,
                Metadata: map[string]interface{}{
                        "request_id":    request.Context.RequestID,
                        "policy_id":     decision.PolicyID,
                        "rule_id":       decision.RuleID,
                        "reason":        decision.Reason,
                        "confidence":    decision.Confidence,
                        "action":        decision.Action,
                        "session_token": decision.SessionToken != "",
                },
                Timestamp: decision.Timestamp,
                Severity:  severity,
                Category:  CategoryAuthorization,
        }

        al.logEvent(event)</span>
}

// LogAuthenticationEvent logs authentication events
func (al *AuditLogger) LogAuthenticationEvent(userID, eventType, result string, metadata map[string]interface{}) <span class="cov0" title="0">{
        severity := SeverityInfo
        if result == "FAILED" </span><span class="cov0" title="0">{
                severity = SeverityWarning
        }</span>

        <span class="cov0" title="0">event := &amp;AuditEvent{
                ID:        generateEventID(),
                Type:      eventType,
                UserID:    userID,
                Result:    result,
                Metadata:  metadata,
                Timestamp: time.Now(),
                Severity:  severity,
                Category:  CategoryAuthentication,
        }

        if ipAddress, ok := metadata["ip_address"].(string); ok </span><span class="cov0" title="0">{
                event.IPAddress = ipAddress
        }</span>
        <span class="cov0" title="0">if userAgent, ok := metadata["user_agent"].(string); ok </span><span class="cov0" title="0">{
                event.UserAgent = userAgent
        }</span>
        <span class="cov0" title="0">if sessionID, ok := metadata["session_id"].(string); ok </span><span class="cov0" title="0">{
                event.SessionID = sessionID
        }</span>

        <span class="cov0" title="0">al.logEvent(event)</span>
}

// LogDataAccessEvent logs data access events
func (al *AuditLogger) LogDataAccessEvent(userID, resource, action, result string, metadata map[string]interface{}) <span class="cov0" title="0">{
        severity := SeverityInfo
        if result == "DENIED" </span><span class="cov0" title="0">{
                severity = SeverityWarning
        }</span>

        <span class="cov0" title="0">event := &amp;AuditEvent{
                ID:        generateEventID(),
                Type:      "DATA_ACCESS",
                UserID:    userID,
                Resource:  resource,
                Action:    action,
                Result:    result,
                Metadata:  metadata,
                Timestamp: time.Now(),
                Severity:  severity,
                Category:  CategoryDataAccess,
        }

        al.logEvent(event)</span>
}

// LogSecurityEvent logs general security events
func (al *AuditLogger) LogSecurityEvent(eventType string, metadata map[string]interface{}) <span class="cov0" title="0">{
        event := &amp;AuditEvent{
                ID:        generateEventID(),
                Type:      eventType,
                Result:    "INFO",
                Metadata:  metadata,
                Timestamp: time.Now(),
                Severity:  SeverityInfo,
                Category:  CategorySecurity,
        }

        if userID, ok := metadata["user_id"].(string); ok </span><span class="cov0" title="0">{
                event.UserID = userID
        }</span>
        <span class="cov0" title="0">if resource, ok := metadata["resource"].(string); ok </span><span class="cov0" title="0">{
                event.Resource = resource
        }</span>
        <span class="cov0" title="0">if action, ok := metadata["action"].(string); ok </span><span class="cov0" title="0">{
                event.Action = action
        }</span>

        <span class="cov0" title="0">al.logEvent(event)</span>
}

// LogComplianceEvent logs compliance-related events
func (al *AuditLogger) LogComplianceEvent(eventType, result string, metadata map[string]interface{}) <span class="cov0" title="0">{
        severity := SeverityInfo
        if result == "VIOLATION" </span><span class="cov0" title="0">{
                severity = SeverityError
        }</span>

        <span class="cov0" title="0">event := &amp;AuditEvent{
                ID:        generateEventID(),
                Type:      eventType,
                Result:    result,
                Metadata:  metadata,
                Timestamp: time.Now(),
                Severity:  severity,
                Category:  CategoryCompliance,
        }

        al.logEvent(event)</span>
}

// LogConfigurationChange logs configuration changes
func (al *AuditLogger) LogConfigurationChange(userID, component, action string, oldValue, newValue interface{}) <span class="cov0" title="0">{
        event := &amp;AuditEvent{
                ID:       generateEventID(),
                Type:     "CONFIGURATION_CHANGE",
                UserID:   userID,
                Resource: component,
                Action:   action,
                Result:   "SUCCESS",
                Metadata: map[string]interface{}{
                        "old_value": oldValue,
                        "new_value": newValue,
                },
                Timestamp: time.Now(),
                Severity:  SeverityInfo,
                Category:  CategoryConfiguration,
        }

        al.logEvent(event)
}</span>

// logEvent adds an event to the buffer
func (al *AuditLogger) logEvent(event *AuditEvent) <span class="cov0" title="0">{
        al.mu.Lock()
        defer al.mu.Unlock()

        al.buffer = append(al.buffer, event)

        // Flush if buffer is full
        if len(al.buffer) &gt;= al.bufferSize </span><span class="cov0" title="0">{
                al.flushBuffer()
        }</span>
}

// flushBuffer writes buffered events to the log
func (al *AuditLogger) flushBuffer() <span class="cov0" title="0">{
        if len(al.buffer) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for _, event := range al.buffer </span><span class="cov0" title="0">{
                eventJSON, err := json.Marshal(event)
                if err != nil </span><span class="cov0" title="0">{
                        al.logger.Errorf("Failed to marshal audit event: %v", err)
                        continue</span>
                }

                <span class="cov0" title="0">al.logger.Info(string(eventJSON))

                // Send to remote log if configured
                if al.config.EnableRemoteLog </span><span class="cov0" title="0">{
                        go al.sendToRemoteLog(event)
                }</span>
        }

        // Clear buffer
        <span class="cov0" title="0">al.buffer = al.buffer[:0]</span>
}

// flushRoutine periodically flushes the buffer
func (al *AuditLogger) flushRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(al.config.FlushInterval)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                al.mu.Lock()
                al.flushBuffer()
                al.mu.Unlock()
        }</span>
}

// sendToRemoteLog sends audit events to a remote logging service
func (al *AuditLogger) sendToRemoteLog(event *AuditEvent) {<span class="cov0" title="0">
        // Implementation would depend on the remote logging service
        // This is a placeholder for integration with services like:
        // - Elasticsearch
        // - Splunk
        // - AWS CloudWatch
        // - Azure Monitor
        // - Google Cloud Logging
}</span>

// GetAuditEvents retrieves audit events based on filters
func (al *AuditLogger) GetAuditEvents(filters map[string]interface{}) ([]*AuditEvent, error) <span class="cov0" title="0">{
        // This would typically query a database or search index
        // For now, return empty slice
        return []*AuditEvent{}, nil
}</span>

// GenerateComplianceReport generates a compliance report
func (al *AuditLogger) GenerateComplianceReport(startTime, endTime time.Time, standards []string) (*ComplianceReport, error) <span class="cov0" title="0">{
        report := &amp;ComplianceReport{
                ID:          generateEventID(),
                StartTime:   startTime,
                EndTime:     endTime,
                Standards:   standards,
                GeneratedAt: time.Now(),
                TotalEvents: 0,
                Violations:  0,
                Findings:    make([]*ComplianceFinding, 0),
        }

        // This would analyze audit events for compliance violations
        // Implementation depends on specific compliance requirements

        return report, nil
}</span>

// ComplianceReport represents a compliance audit report
type ComplianceReport struct {
        ID          string               `json:"id"`
        StartTime   time.Time            `json:"start_time"`
        EndTime     time.Time            `json:"end_time"`
        Standards   []string             `json:"standards"`
        GeneratedAt time.Time            `json:"generated_at"`
        TotalEvents int                  `json:"total_events"`
        Violations  int                  `json:"violations"`
        Findings    []*ComplianceFinding `json:"findings"`
}

// ComplianceFinding represents a compliance finding
type ComplianceFinding struct {
        ID          string                 `json:"id"`
        Standard    string                 `json:"standard"`
        Requirement string                 `json:"requirement"`
        Severity    string                 `json:"severity"`
        Description string                 `json:"description"`
        Evidence    map[string]interface{} `json:"evidence"`
        Status      string                 `json:"status"`
        CreatedAt   time.Time              `json:"created_at"`
}

// Close closes the audit logger and flushes remaining events
func (al *AuditLogger) Close() error <span class="cov0" title="0">{
        al.mu.Lock()
        defer al.mu.Unlock()

        // Flush remaining events
        al.flushBuffer()

        // Close log file
        if al.file != nil </span><span class="cov0" title="0">{
                return al.file.Close()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// generateEventID generates a unique event ID
func generateEventID() string <span class="cov0" title="0">{
        return fmt.Sprintf("audit_%d_%d", time.Now().UnixNano(), time.Now().Nanosecond())
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package security

import (
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// ComplianceManager handles compliance monitoring and reporting
type ComplianceManager struct {
        logger      *logrus.Logger
        standards   map[string]*ComplianceStandard
        policies    map[string]*CompliancePolicy
        violations  []*ComplianceViolation
        mu          sync.RWMutex
        config      *ComplianceConfig
        auditLogger *AuditLogger
}

// ComplianceConfig contains compliance configuration
type ComplianceConfig struct {
        EnabledStandards    []string      `json:"enabled_standards"`
        ViolationThreshold  int           `json:"violation_threshold"`
        ReportingInterval   time.Duration `json:"reporting_interval"`
        AutoRemediation     bool          `json:"auto_remediation"`
        NotificationEnabled bool          `json:"notification_enabled"`
        NotificationURL     string        `json:"notification_url"`
}

// ComplianceStandard represents a compliance standard (e.g., GDPR, SOC2, HIPAA)
type ComplianceStandard struct {
        ID             string                     `json:"id"`
        Name           string                     `json:"name"`
        Version        string                     `json:"version"`
        Description    string                     `json:"description"`
        Requirements   []*ComplianceRequirement   `json:"requirements"`
        Controls       []*ComplianceControl       `json:"controls"`
        Certifications []*ComplianceCertification `json:"certifications"`
        LastAssessment *time.Time                 `json:"last_assessment,omitempty"`
        NextAssessment time.Time                  `json:"next_assessment"`
        Status         ComplianceStatus           `json:"status"`
        Metadata       map[string]interface{}     `json:"metadata"`
}

// ComplianceRequirement represents a specific compliance requirement
type ComplianceRequirement struct {
        ID             string                 `json:"id"`
        StandardID     string                 `json:"standard_id"`
        Title          string                 `json:"title"`
        Description    string                 `json:"description"`
        Category       string                 `json:"category"`
        Priority       RequirementPriority    `json:"priority"`
        Controls       []string               `json:"controls"` // Control IDs
        Evidence       []string               `json:"evidence"` // Evidence types required
        TestProcedures []string               `json:"test_procedures"`
        Status         RequirementStatus      `json:"status"`
        LastTested     *time.Time             `json:"last_tested,omitempty"`
        NextTest       time.Time              `json:"next_test"`
        Findings       []*ComplianceFinding   `json:"findings"`
        Metadata       map[string]interface{} `json:"metadata"`
}

// ComplianceControl represents a security control
type ComplianceControl struct {
        ID             string                 `json:"id"`
        Name           string                 `json:"name"`
        Description    string                 `json:"description"`
        Type           ControlType            `json:"type"`
        Category       ControlCategory        `json:"category"`
        Implementation ControlImplementation  `json:"implementation"`
        Effectiveness  ControlEffectiveness   `json:"effectiveness"`
        TestFrequency  time.Duration          `json:"test_frequency"`
        Owner          string                 `json:"owner"`
        Status         ControlStatus          `json:"status"`
        LastTested     *time.Time             `json:"last_tested,omitempty"`
        NextTest       time.Time              `json:"next_test"`
        TestResults    []*ControlTestResult   `json:"test_results"`
        Metadata       map[string]interface{} `json:"metadata"`
}

// ComplianceCertification represents a compliance certification
type ComplianceCertification struct {
        ID             string                 `json:"id"`
        StandardID     string                 `json:"standard_id"`
        Name           string                 `json:"name"`
        Issuer         string                 `json:"issuer"`
        IssuedDate     time.Time              `json:"issued_date"`
        ExpiryDate     time.Time              `json:"expiry_date"`
        Status         CertificationStatus    `json:"status"`
        CertificateURL string                 `json:"certificate_url"`
        Scope          []string               `json:"scope"`
        Metadata       map[string]interface{} `json:"metadata"`
}

// CompliancePolicy represents a compliance policy
type CompliancePolicy struct {
        ID            string                 `json:"id"`
        Name          string                 `json:"name"`
        Description   string                 `json:"description"`
        StandardID    string                 `json:"standard_id"`
        Requirements  []string               `json:"requirements"` // Requirement IDs
        Rules         []*PolicyRule          `json:"rules"`
        Enforcement   PolicyEnforcement      `json:"enforcement"`
        Status        PolicyStatus           `json:"status"`
        CreatedAt     time.Time              `json:"created_at"`
        UpdatedAt     time.Time              `json:"updated_at"`
        EffectiveDate time.Time              `json:"effective_date"`
        ReviewDate    time.Time              `json:"review_date"`
        Owner         string                 `json:"owner"`
        Approver      string                 `json:"approver"`
        Metadata      map[string]interface{} `json:"metadata"`
}

// PolicyRule represents a rule within a compliance policy
type PolicyRule struct {
        ID          string                 `json:"id"`
        Name        string                 `json:"name"`
        Description string                 `json:"description"`
        Condition   string                 `json:"condition"`
        Action      PolicyAction           `json:"action"`
        Severity    ViolationSeverity      `json:"severity"`
        Metadata    map[string]interface{} `json:"metadata"`
}

// ComplianceViolation represents a compliance violation
type ComplianceViolation struct {
        ID              string                 `json:"id"`
        StandardID      string                 `json:"standard_id"`
        RequirementID   string                 `json:"requirement_id"`
        PolicyID        string                 `json:"policy_id"`
        RuleID          string                 `json:"rule_id"`
        Title           string                 `json:"title"`
        Description     string                 `json:"description"`
        Severity        ViolationSeverity      `json:"severity"`
        Category        ViolationCategory      `json:"category"`
        Status          ViolationStatus        `json:"status"`
        DetectedAt      time.Time              `json:"detected_at"`
        ResolvedAt      *time.Time             `json:"resolved_at,omitempty"`
        AssignedTo      string                 `json:"assigned_to"`
        Evidence        map[string]interface{} `json:"evidence"`
        RemediationPlan string                 `json:"remediation_plan"`
        DueDate         time.Time              `json:"due_date"`
        Metadata        map[string]interface{} `json:"metadata"`
}

// ControlTestResult represents the result of a control test
type ControlTestResult struct {
        ID        string                 `json:"id"`
        ControlID string                 `json:"control_id"`
        TestDate  time.Time              `json:"test_date"`
        Tester    string                 `json:"tester"`
        Result    TestResult             `json:"result"`
        Score     float64                `json:"score"` // 0.0 to 1.0
        Findings  []*ComplianceFinding   `json:"findings"`
        Evidence  []string               `json:"evidence"`
        Comments  string                 `json:"comments"`
        Metadata  map[string]interface{} `json:"metadata"`
}

// Enums

type ComplianceStatus string

const (
        ComplianceStatusCompliant    ComplianceStatus = "compliant"
        ComplianceStatusNonCompliant ComplianceStatus = "non_compliant"
        ComplianceStatusInProgress   ComplianceStatus = "in_progress"
        ComplianceStatusNotAssessed  ComplianceStatus = "not_assessed"
)

type RequirementPriority string

const (
        RequirementPriorityHigh   RequirementPriority = "high"
        RequirementPriorityMedium RequirementPriority = "medium"
        RequirementPriorityLow    RequirementPriority = "low"
)

type RequirementStatus string

const (
        RequirementStatusImplemented    RequirementStatus = "implemented"
        RequirementStatusPartial        RequirementStatus = "partial"
        RequirementStatusNotImplemented RequirementStatus = "not_implemented"
        RequirementStatusNotApplicable  RequirementStatus = "not_applicable"
)

type ControlType string

const (
        ControlTypePreventive   ControlType = "preventive"
        ControlTypeDetective    ControlType = "detective"
        ControlTypeCorrective   ControlType = "corrective"
        ControlTypeCompensating ControlType = "compensating"
)

type ControlCategory string

const (
        ControlCategoryTechnical      ControlCategory = "technical"
        ControlCategoryAdministrative ControlCategory = "administrative"
        ControlCategoryPhysical       ControlCategory = "physical"
)

type ControlImplementation string

const (
        ControlImplementationManual    ControlImplementation = "manual"
        ControlImplementationAutomatic ControlImplementation = "automatic"
        ControlImplementationHybrid    ControlImplementation = "hybrid"
)

type ControlEffectiveness string

const (
        ControlEffectivenessHigh   ControlEffectiveness = "high"
        ControlEffectivenessMedium ControlEffectiveness = "medium"
        ControlEffectivenessLow    ControlEffectiveness = "low"
)

type ControlStatus string

const (
        ControlStatusActive     ControlStatus = "active"
        ControlStatusInactive   ControlStatus = "inactive"
        ControlStatusTesting    ControlStatus = "testing"
        ControlStatusDeprecated ControlStatus = "deprecated"
)

type CertificationStatus string

const (
        CertificationStatusValid     CertificationStatus = "valid"
        CertificationStatusExpired   CertificationStatus = "expired"
        CertificationStatusSuspended CertificationStatus = "suspended"
        CertificationStatusRevoked   CertificationStatus = "revoked"
)

type PolicyEnforcement string

const (
        PolicyEnforcementMandatory PolicyEnforcement = "mandatory"
        PolicyEnforcementAdvisory  PolicyEnforcement = "advisory"
        PolicyEnforcementOptional  PolicyEnforcement = "optional"
)

type PolicyStatus string

const (
        PolicyStatusActive     PolicyStatus = "active"
        PolicyStatusDraft      PolicyStatus = "draft"
        PolicyStatusArchived   PolicyStatus = "archived"
        PolicyStatusSuperseded PolicyStatus = "superseded"
)

type PolicyAction string

const (
        PolicyActionAllow     PolicyAction = "allow"
        PolicyActionDeny      PolicyAction = "deny"
        PolicyActionAlert     PolicyAction = "alert"
        PolicyActionLog       PolicyAction = "log"
        PolicyActionRemediate PolicyAction = "remediate"
)

type ViolationSeverity string

const (
        ViolationSeverityCritical ViolationSeverity = "critical"
        ViolationSeverityHigh     ViolationSeverity = "high"
        ViolationSeverityMedium   ViolationSeverity = "medium"
        ViolationSeverityLow      ViolationSeverity = "low"
        ViolationSeverityInfo     ViolationSeverity = "info"
)

type ViolationCategory string

const (
        ViolationCategoryDataProtection ViolationCategory = "data_protection"
        ViolationCategoryAccessControl  ViolationCategory = "access_control"
        ViolationCategoryEncryption     ViolationCategory = "encryption"
        ViolationCategoryAudit          ViolationCategory = "audit"
        ViolationCategoryIncident       ViolationCategory = "incident"
        ViolationCategoryConfiguration  ViolationCategory = "configuration"
)

type ViolationStatus string

const (
        ViolationStatusOpen          ViolationStatus = "open"
        ViolationStatusInProgress    ViolationStatus = "in_progress"
        ViolationStatusResolved      ViolationStatus = "resolved"
        ViolationStatusClosed        ViolationStatus = "closed"
        ViolationStatusFalsePositive ViolationStatus = "false_positive"
)

type TestResult string

const (
        TestResultPass      TestResult = "pass"
        TestResultFail      TestResult = "fail"
        TestResultPartial   TestResult = "partial"
        TestResultNotTested TestResult = "not_tested"
)

// NewComplianceManager creates a new compliance manager
func NewComplianceManager() *ComplianceManager <span class="cov0" title="0">{
        config := &amp;ComplianceConfig{
                EnabledStandards:    []string{"GDPR", "SOC2", "ISO27001"},
                ViolationThreshold:  10,
                ReportingInterval:   24 * time.Hour,
                AutoRemediation:     false,
                NotificationEnabled: true,
        }

        manager := &amp;ComplianceManager{
                logger:      logrus.New(),
                standards:   make(map[string]*ComplianceStandard),
                policies:    make(map[string]*CompliancePolicy),
                violations:  make([]*ComplianceViolation, 0),
                config:      config,
                auditLogger: NewAuditLogger(),
        }

        // Initialize default compliance standards
        manager.initializeStandards()

        // Start background monitoring
        go manager.monitoringRoutine()

        return manager
}</span>

// initializeStandards initializes default compliance standards
func (cm *ComplianceManager) initializeStandards() <span class="cov0" title="0">{
        // GDPR
        gdpr := &amp;ComplianceStandard{
                ID:             "GDPR",
                Name:           "General Data Protection Regulation",
                Version:        "2018",
                Description:    "EU regulation on data protection and privacy",
                Status:         ComplianceStatusInProgress,
                NextAssessment: time.Now().AddDate(0, 6, 0), // 6 months
                Requirements: []*ComplianceRequirement{
                        {
                                ID:          "GDPR-7",
                                StandardID:  "GDPR",
                                Title:       "Consent",
                                Description: "Consent must be freely given, specific, informed and unambiguous",
                                Category:    "Data Processing",
                                Priority:    RequirementPriorityHigh,
                                Status:      RequirementStatusImplemented,
                                NextTest:    time.Now().AddDate(0, 3, 0),
                        },
                        {
                                ID:          "GDPR-25",
                                StandardID:  "GDPR",
                                Title:       "Data Protection by Design and by Default",
                                Description: "Implement appropriate technical and organisational measures",
                                Category:    "Data Protection",
                                Priority:    RequirementPriorityHigh,
                                Status:      RequirementStatusPartial,
                                NextTest:    time.Now().AddDate(0, 1, 0),
                        },
                        {
                                ID:          "GDPR-32",
                                StandardID:  "GDPR",
                                Title:       "Security of Processing",
                                Description: "Implement appropriate technical and organisational measures",
                                Category:    "Security",
                                Priority:    RequirementPriorityHigh,
                                Status:      RequirementStatusImplemented,
                                NextTest:    time.Now().AddDate(0, 3, 0),
                        },
                },
                Controls: []*ComplianceControl{
                        {
                                ID:             "GDPR-C001",
                                Name:           "Data Encryption",
                                Description:    "Encrypt personal data at rest and in transit",
                                Type:           ControlTypePreventive,
                                Category:       ControlCategoryTechnical,
                                Implementation: ControlImplementationAutomatic,
                                Effectiveness:  ControlEffectivenessHigh,
                                TestFrequency:  30 * 24 * time.Hour, // Monthly
                                Status:         ControlStatusActive,
                                NextTest:       time.Now().AddDate(0, 1, 0),
                        },
                        {
                                ID:             "GDPR-C002",
                                Name:           "Access Control",
                                Description:    "Implement role-based access control for personal data",
                                Type:           ControlTypePreventive,
                                Category:       ControlCategoryTechnical,
                                Implementation: ControlImplementationAutomatic,
                                Effectiveness:  ControlEffectivenessHigh,
                                TestFrequency:  30 * 24 * time.Hour,
                                Status:         ControlStatusActive,
                                NextTest:       time.Now().AddDate(0, 1, 0),
                        },
                },
        }

        // SOC 2
        soc2 := &amp;ComplianceStandard{
                ID:             "SOC2",
                Name:           "Service Organization Control 2",
                Version:        "2017",
                Description:    "Auditing standard for service organizations",
                Status:         ComplianceStatusInProgress,
                NextAssessment: time.Now().AddDate(1, 0, 0), // Annual
                Requirements: []*ComplianceRequirement{
                        {
                                ID:          "SOC2-CC6.1",
                                StandardID:  "SOC2",
                                Title:       "Logical and Physical Access Controls",
                                Description: "Implement controls to restrict logical and physical access",
                                Category:    "Access Control",
                                Priority:    RequirementPriorityHigh,
                                Status:      RequirementStatusImplemented,
                                NextTest:    time.Now().AddDate(0, 3, 0),
                        },
                        {
                                ID:          "SOC2-CC6.7",
                                StandardID:  "SOC2",
                                Title:       "Data Transmission and Disposal",
                                Description: "Protect data during transmission and disposal",
                                Category:    "Data Protection",
                                Priority:    RequirementPriorityHigh,
                                Status:      RequirementStatusImplemented,
                                NextTest:    time.Now().AddDate(0, 3, 0),
                        },
                },
                Controls: []*ComplianceControl{
                        {
                                ID:             "SOC2-C001",
                                Name:           "Multi-Factor Authentication",
                                Description:    "Require MFA for system access",
                                Type:           ControlTypePreventive,
                                Category:       ControlCategoryTechnical,
                                Implementation: ControlImplementationAutomatic,
                                Effectiveness:  ControlEffectivenessHigh,
                                TestFrequency:  90 * 24 * time.Hour, // Quarterly
                                Status:         ControlStatusActive,
                                NextTest:       time.Now().AddDate(0, 3, 0),
                        },
                },
        }

        cm.standards["GDPR"] = gdpr
        cm.standards["SOC2"] = soc2

        cm.logger.Info("Initialized compliance standards")
}</span>

// CheckCompliance evaluates compliance for a specific access request
func (cm *ComplianceManager) CheckCompliance(request *AccessRequest) ([]*ComplianceViolation, error) <span class="cov0" title="0">{
        var violations []*ComplianceViolation

        cm.mu.RLock()
        defer cm.mu.RUnlock()

        // Check each enabled standard
        for _, standardID := range cm.config.EnabledStandards </span><span class="cov0" title="0">{
                standard, exists := cm.standards[standardID]
                if !exists </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check policies for this standard
                <span class="cov0" title="0">for _, policy := range cm.policies </span><span class="cov0" title="0">{
                        if policy.StandardID == standardID &amp;&amp; policy.Status == PolicyStatusActive </span><span class="cov0" title="0">{
                                policyViolations := cm.evaluatePolicy(request, policy)
                                violations = append(violations, policyViolations...)
                        }</span>
                }

                // Check specific requirements
                <span class="cov0" title="0">standardViolations := cm.evaluateStandardRequirements(request, standard)
                violations = append(violations, standardViolations...)</span>
        }

        // Log violations
        <span class="cov0" title="0">for _, violation := range violations </span><span class="cov0" title="0">{
                cm.auditLogger.LogComplianceEvent("COMPLIANCE_VIOLATION", "VIOLATION", map[string]interface{}{
                        "violation_id":   violation.ID,
                        "standard_id":    violation.StandardID,
                        "requirement_id": violation.RequirementID,
                        "severity":       violation.Severity,
                        "description":    violation.Description,
                        "user_id":        request.UserID,
                        "resource":       request.Resource,
                })
        }</span>

        <span class="cov0" title="0">return violations, nil</span>
}

// evaluatePolicy evaluates a compliance policy against an access request
func (cm *ComplianceManager) evaluatePolicy(request *AccessRequest, policy *CompliancePolicy) []*ComplianceViolation <span class="cov0" title="0">{
        var violations []*ComplianceViolation

        for _, rule := range policy.Rules </span><span class="cov0" title="0">{
                if cm.evaluateRule(request, rule) </span><span class="cov0" title="0">{
                        violation := &amp;ComplianceViolation{
                                ID:          generateViolationID(),
                                StandardID:  policy.StandardID,
                                PolicyID:    policy.ID,
                                RuleID:      rule.ID,
                                Title:       fmt.Sprintf("Policy violation: %s", rule.Name),
                                Description: rule.Description,
                                Severity:    rule.Severity,
                                Category:    cm.categorizeViolation(rule),
                                Status:      ViolationStatusOpen,
                                DetectedAt:  time.Now(),
                                DueDate:     time.Now().AddDate(0, 0, cm.getSeverityDueDays(rule.Severity)),
                                Evidence: map[string]interface{}{
                                        "user_id":        request.UserID,
                                        "resource":       request.Resource,
                                        "action":         request.Action,
                                        "ip_address":     request.Context.IPAddress,
                                        "rule_condition": rule.Condition,
                                },
                        }

                        violations = append(violations, violation)
                }</span>
        }

        <span class="cov0" title="0">return violations</span>
}

// evaluateStandardRequirements evaluates standard requirements
func (cm *ComplianceManager) evaluateStandardRequirements(request *AccessRequest, standard *ComplianceStandard) []*ComplianceViolation <span class="cov0" title="0">{
        var violations []*ComplianceViolation

        // Example: Check GDPR data processing requirements
        if standard.ID == "GDPR" </span><span class="cov0" title="0">{
                violations = append(violations, cm.checkGDPRCompliance(request)...)
        }</span>

        // Example: Check SOC2 access control requirements
        <span class="cov0" title="0">if standard.ID == "SOC2" </span><span class="cov0" title="0">{
                violations = append(violations, cm.checkSOC2Compliance(request)...)
        }</span>

        <span class="cov0" title="0">return violations</span>
}

// checkGDPRCompliance checks GDPR-specific compliance
func (cm *ComplianceManager) checkGDPRCompliance(request *AccessRequest) []*ComplianceViolation <span class="cov0" title="0">{
        var violations []*ComplianceViolation

        // Check if accessing personal data without proper consent
        if cm.isPersonalDataResource(request.Resource) </span><span class="cov0" title="0">{
                if !cm.hasValidConsent(request) </span><span class="cov0" title="0">{
                        violation := &amp;ComplianceViolation{
                                ID:            generateViolationID(),
                                StandardID:    "GDPR",
                                RequirementID: "GDPR-7",
                                Title:         "Access to personal data without valid consent",
                                Description:   "Personal data accessed without proper user consent",
                                Severity:      ViolationSeverityHigh,
                                Category:      ViolationCategoryDataProtection,
                                Status:        ViolationStatusOpen,
                                DetectedAt:    time.Now(),
                                DueDate:       time.Now().AddDate(0, 0, 7), // 7 days for high severity
                                Evidence: map[string]interface{}{
                                        "user_id":  request.UserID,
                                        "resource": request.Resource,
                                        "reason":   "No valid consent found",
                                },
                        }
                        violations = append(violations, violation)
                }</span>
        }

        // Check data retention compliance
        <span class="cov0" title="0">if cm.isDataRetentionViolation(request) </span><span class="cov0" title="0">{
                violation := &amp;ComplianceViolation{
                        ID:            generateViolationID(),
                        StandardID:    "GDPR",
                        RequirementID: "GDPR-5",
                        Title:         "Data retention period exceeded",
                        Description:   "Data accessed beyond permitted retention period",
                        Severity:      ViolationSeverityMedium,
                        Category:      ViolationCategoryDataProtection,
                        Status:        ViolationStatusOpen,
                        DetectedAt:    time.Now(),
                        DueDate:       time.Now().AddDate(0, 0, 14), // 14 days for medium severity
                        Evidence: map[string]interface{}{
                                "user_id":  request.UserID,
                                "resource": request.Resource,
                                "reason":   "Data retention period exceeded",
                        },
                }
                violations = append(violations, violation)
        }</span>

        <span class="cov0" title="0">return violations</span>
}

// checkSOC2Compliance checks SOC2-specific compliance
func (cm *ComplianceManager) checkSOC2Compliance(request *AccessRequest) []*ComplianceViolation <span class="cov0" title="0">{
        var violations []*ComplianceViolation

        // Check access control requirements
        if !cm.hasProperAccessControl(request) </span><span class="cov0" title="0">{
                violation := &amp;ComplianceViolation{
                        ID:            generateViolationID(),
                        StandardID:    "SOC2",
                        RequirementID: "SOC2-CC6.1",
                        Title:         "Insufficient access controls",
                        Description:   "Access granted without proper authorization controls",
                        Severity:      ViolationSeverityHigh,
                        Category:      ViolationCategoryAccessControl,
                        Status:        ViolationStatusOpen,
                        DetectedAt:    time.Now(),
                        DueDate:       time.Now().AddDate(0, 0, 7),
                        Evidence: map[string]interface{}{
                                "user_id":  request.UserID,
                                "resource": request.Resource,
                                "reason":   "Insufficient access controls",
                        },
                }
                violations = append(violations, violation)
        }</span>

        <span class="cov0" title="0">return violations</span>
}

// Helper methods for compliance checks

func (cm *ComplianceManager) evaluateRule(request *AccessRequest, rule *PolicyRule) bool <span class="cov0" title="0">{
        // Simplified rule evaluation - in production, use a proper rule engine
        condition := strings.ToLower(rule.Condition)

        if strings.Contains(condition, "high_risk_country") </span><span class="cov0" title="0">{
                if request.Context.Location != nil </span><span class="cov0" title="0">{
                        highRiskCountries := []string{"CN", "RU", "KP", "IR"}
                        for _, country := range highRiskCountries </span><span class="cov0" title="0">{
                                if request.Context.Location.Country == country </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if strings.Contains(condition, "off_hours") </span><span class="cov0" title="0">{
                hour := time.Now().Hour()
                if hour &lt; 6 || hour &gt; 22 </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">if strings.Contains(condition, "no_mfa") </span><span class="cov0" title="0">{
                // Check if MFA was used (simplified check)
                if mfa, exists := request.Claims["mfa"]; !exists || mfa != true </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (cm *ComplianceManager) isPersonalDataResource(resource string) bool <span class="cov0" title="0">{
        personalDataResources := []string{
                "/api/v1/users",
                "/api/v1/profiles",
                "/api/v1/conversations",
                "/api/v1/messages",
        }

        for _, pdr := range personalDataResources </span><span class="cov0" title="0">{
                if strings.HasPrefix(resource, pdr) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (cm *ComplianceManager) hasValidConsent(request *AccessRequest) bool <span class="cov0" title="0">{
        // Check if user has given valid consent
        // This would integrate with a consent management system
        if consent, exists := request.Claims["consent"]; exists </span><span class="cov0" title="0">{
                if consentMap, ok := consent.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if valid, exists := consentMap["valid"]; exists &amp;&amp; valid == true </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func (cm *ComplianceManager) isDataRetentionViolation(request *AccessRequest) bool <span class="cov0" title="0">{
        // Check if data is being accessed beyond retention period
        // This would integrate with a data lifecycle management system
        return false // Simplified implementation
}</span>

func (cm *ComplianceManager) hasProperAccessControl(request *AccessRequest) bool <span class="cov0" title="0">{
        // Check if proper access controls are in place
        if request.Context.SessionID == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if len(request.Claims) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for required roles
        <span class="cov0" title="0">if roles, exists := request.Claims["roles"]; exists </span><span class="cov0" title="0">{
                if roleList, ok := roles.([]interface{}); ok &amp;&amp; len(roleList) &gt; 0 </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (cm *ComplianceManager) categorizeViolation(rule *PolicyRule) ViolationCategory <span class="cov0" title="0">{
        ruleName := strings.ToLower(rule.Name)

        if strings.Contains(ruleName, "data") || strings.Contains(ruleName, "privacy") </span><span class="cov0" title="0">{
                return ViolationCategoryDataProtection
        }</span>
        <span class="cov0" title="0">if strings.Contains(ruleName, "access") || strings.Contains(ruleName, "auth") </span><span class="cov0" title="0">{
                return ViolationCategoryAccessControl
        }</span>
        <span class="cov0" title="0">if strings.Contains(ruleName, "encrypt") </span><span class="cov0" title="0">{
                return ViolationCategoryEncryption
        }</span>
        <span class="cov0" title="0">if strings.Contains(ruleName, "audit") || strings.Contains(ruleName, "log") </span><span class="cov0" title="0">{
                return ViolationCategoryAudit
        }</span>

        <span class="cov0" title="0">return ViolationCategoryConfiguration</span>
}

func (cm *ComplianceManager) getSeverityDueDays(severity ViolationSeverity) int <span class="cov0" title="0">{
        switch severity </span>{
        case ViolationSeverityCritical:<span class="cov0" title="0">
                return 1</span>
        case ViolationSeverityHigh:<span class="cov0" title="0">
                return 7</span>
        case ViolationSeverityMedium:<span class="cov0" title="0">
                return 14</span>
        case ViolationSeverityLow:<span class="cov0" title="0">
                return 30</span>
        default:<span class="cov0" title="0">
                return 30</span>
        }
}

// Background monitoring

func (cm *ComplianceManager) monitoringRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(cm.config.ReportingInterval)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                cm.performPeriodicAssessment()
                cm.generateComplianceReport()
                cm.checkCertificationExpiry()
        }</span>
}

func (cm *ComplianceManager) performPeriodicAssessment() <span class="cov0" title="0">{
        cm.mu.Lock()
        defer cm.mu.Unlock()

        for _, standard := range cm.standards </span><span class="cov0" title="0">{
                if time.Now().After(standard.NextAssessment) </span><span class="cov0" title="0">{
                        cm.logger.Infof("Performing compliance assessment for %s", standard.ID)

                        // Update next assessment date
                        standard.NextAssessment = time.Now().Add(365 * 24 * time.Hour) // Annual
                        now := time.Now()
                        standard.LastAssessment = &amp;now

                        // Assess requirements
                        for _, requirement := range standard.Requirements </span><span class="cov0" title="0">{
                                if time.Now().After(requirement.NextTest) </span><span class="cov0" title="0">{
                                        cm.testRequirement(requirement)
                                }</span>
                        }

                        // Test controls
                        <span class="cov0" title="0">for _, control := range standard.Controls </span><span class="cov0" title="0">{
                                if time.Now().After(control.NextTest) </span><span class="cov0" title="0">{
                                        cm.testControl(control)
                                }</span>
                        }
                }
        }
}

func (cm *ComplianceManager) testRequirement(requirement *ComplianceRequirement) <span class="cov0" title="0">{
        // Simulate requirement testing
        cm.logger.Infof("Testing requirement: %s", requirement.ID)

        now := time.Now()
        requirement.LastTested = &amp;now
        requirement.NextTest = time.Now().Add(90 * 24 * time.Hour) // Quarterly

        // In production, this would perform actual compliance tests
}</span>

func (cm *ComplianceManager) testControl(control *ComplianceControl) <span class="cov0" title="0">{
        // Simulate control testing
        cm.logger.Infof("Testing control: %s", control.ID)

        now := time.Now()
        control.LastTested = &amp;now
        control.NextTest = time.Now().Add(control.TestFrequency)

        // Create test result
        testResult := &amp;ControlTestResult{
                ID:        generateTestResultID(),
                ControlID: control.ID,
                TestDate:  time.Now(),
                Tester:    "automated",
                Result:    TestResultPass, // Simplified
                Score:     0.95,
                Comments:  "Automated compliance test passed",
        }

        control.TestResults = append(control.TestResults, testResult)

        // Keep only recent test results
        if len(control.TestResults) &gt; 10 </span><span class="cov0" title="0">{
                control.TestResults = control.TestResults[1:]
        }</span>
}

func (cm *ComplianceManager) generateComplianceReport() <span class="cov0" title="0">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()

        report := &amp;ComplianceReport{
                ID:          generateEventID(),
                StartTime:   time.Now().AddDate(0, 0, -30), // Last 30 days
                EndTime:     time.Now(),
                Standards:   cm.config.EnabledStandards,
                GeneratedAt: time.Now(),
                TotalEvents: len(cm.violations),
                Violations:  len(cm.violations),
        }

        cm.logger.Infof("Generated compliance report: %s", report.ID)

        // In production, this would save the report and send notifications
}</span>

func (cm *ComplianceManager) checkCertificationExpiry() <span class="cov0" title="0">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()

        for _, standard := range cm.standards </span><span class="cov0" title="0">{
                for _, cert := range standard.Certifications </span><span class="cov0" title="0">{
                        if cert.Status == CertificationStatusValid </span><span class="cov0" title="0">{
                                daysUntilExpiry := int(time.Until(cert.ExpiryDate).Hours() / 24)

                                if daysUntilExpiry &lt;= 30 </span><span class="cov0" title="0">{
                                        cm.logger.Warnf("Certification %s expires in %d days", cert.Name, daysUntilExpiry)

                                        // Create violation for expiring certification
                                        violation := &amp;ComplianceViolation{
                                                ID:          generateViolationID(),
                                                StandardID:  cert.StandardID,
                                                Title:       fmt.Sprintf("Certification expiring: %s", cert.Name),
                                                Description: fmt.Sprintf("Certification %s expires on %s", cert.Name, cert.ExpiryDate.Format("2006-01-02")),
                                                Severity:    ViolationSeverityMedium,
                                                Category:    ViolationCategoryConfiguration,
                                                Status:      ViolationStatusOpen,
                                                DetectedAt:  time.Now(),
                                                DueDate:     cert.ExpiryDate,
                                                Evidence: map[string]interface{}{
                                                        "certification_id": cert.ID,
                                                        "expiry_date":      cert.ExpiryDate,
                                                        "days_remaining":   daysUntilExpiry,
                                                },
                                        }

                                        cm.violations = append(cm.violations, violation)
                                }</span>
                        }
                }
        }
}

// Public methods

// GetComplianceStatus returns the overall compliance status
func (cm *ComplianceManager) GetComplianceStatus() map[string]ComplianceStatus <span class="cov0" title="0">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()

        status := make(map[string]ComplianceStatus)
        for id, standard := range cm.standards </span><span class="cov0" title="0">{
                status[id] = standard.Status
        }</span>

        <span class="cov0" title="0">return status</span>
}

// GetViolations returns current compliance violations
func (cm *ComplianceManager) GetViolations() []*ComplianceViolation <span class="cov0" title="0">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()

        // Return a copy to prevent external modification
        violations := make([]*ComplianceViolation, len(cm.violations))
        copy(violations, cm.violations)

        return violations
}</span>

// ResolveViolation marks a violation as resolved
func (cm *ComplianceManager) ResolveViolation(violationID, resolution string) error <span class="cov0" title="0">{
        cm.mu.Lock()
        defer cm.mu.Unlock()

        for _, violation := range cm.violations </span><span class="cov0" title="0">{
                if violation.ID == violationID </span><span class="cov0" title="0">{
                        violation.Status = ViolationStatusResolved
                        now := time.Now()
                        violation.ResolvedAt = &amp;now
                        violation.RemediationPlan = resolution

                        cm.auditLogger.LogComplianceEvent("VIOLATION_RESOLVED", "RESOLVED", map[string]interface{}{
                                "violation_id": violationID,
                                "resolution":   resolution,
                        })

                        cm.logger.Infof("Resolved compliance violation: %s", violationID)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("violation not found: %s", violationID)</span>
}

// Utility functions

func generateViolationID() string <span class="cov0" title="0">{
        return fmt.Sprintf("violation_%d", time.Now().UnixNano())
}</span>

func generateTestResultID() string <span class="cov0" title="0">{
        return fmt.Sprintf("test_%d", time.Now().UnixNano())
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package security

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha256"
        "crypto/x509"
        "encoding/base64"
        "encoding/pem"
        "fmt"
        "io"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// EncryptionManager handles data encryption and key management
type EncryptionManager struct {
        logger    *logrus.Logger
        keyStore  map[string]*EncryptionKey
        mu        sync.RWMutex
        config    *EncryptionConfig
        masterKey []byte
}

// EncryptionConfig contains encryption configuration
type EncryptionConfig struct {
        Algorithm           string        `json:"algorithm"`
        KeySize             int           `json:"key_size"`
        KeyRotationInterval time.Duration `json:"key_rotation_interval"`
        EnableKeyRotation   bool          `json:"enable_key_rotation"`
        MasterKeyPath       string        `json:"master_key_path"`
        HSMEnabled          bool          `json:"hsm_enabled"`
        HSMConfig           *HSMConfig    `json:"hsm_config,omitempty"`
}

// HSMConfig contains Hardware Security Module configuration
type HSMConfig struct {
        Provider    string            `json:"provider"`
        Endpoint    string            `json:"endpoint"`
        Credentials map[string]string `json:"credentials"`
        KeyLabel    string            `json:"key_label"`
}

// EncryptionKey represents an encryption key with metadata
type EncryptionKey struct {
        ID        string                 `json:"id"`
        Algorithm string                 `json:"algorithm"`
        KeyData   []byte                 `json:"-"` // Never serialize key data
        Purpose   KeyPurpose             `json:"purpose"`
        Status    KeyStatus              `json:"status"`
        CreatedAt time.Time              `json:"created_at"`
        ExpiresAt time.Time              `json:"expires_at"`
        RotatedAt *time.Time             `json:"rotated_at,omitempty"`
        Usage     *KeyUsage              `json:"usage"`
        Metadata  map[string]interface{} `json:"metadata"`
}

// KeyPurpose represents the purpose of an encryption key
type KeyPurpose string

const (
        KeyPurposeDataEncryption    KeyPurpose = "data_encryption"
        KeyPurposeTokenSigning      KeyPurpose = "token_signing"
        KeyPurposePasswordHashing   KeyPurpose = "password_hashing"
        KeyPurposeSessionEncryption KeyPurpose = "session_encryption"
        KeyPurposeFileEncryption    KeyPurpose = "file_encryption"
)

// KeyStatus represents the status of an encryption key
type KeyStatus string

const (
        KeyStatusActive     KeyStatus = "active"
        KeyStatusRotating   KeyStatus = "rotating"
        KeyStatusDeprecated KeyStatus = "deprecated"
        KeyStatusRevoked    KeyStatus = "revoked"
)

// KeyUsage tracks key usage statistics
type KeyUsage struct {
        EncryptionCount int       `json:"encryption_count"`
        DecryptionCount int       `json:"decryption_count"`
        LastUsed        time.Time `json:"last_used"`
        BytesEncrypted  int64     `json:"bytes_encrypted"`
        BytesDecrypted  int64     `json:"bytes_decrypted"`
}

// EncryptedData represents encrypted data with metadata
type EncryptedData struct {
        KeyID      string                 `json:"key_id"`
        Algorithm  string                 `json:"algorithm"`
        Ciphertext string                 `json:"ciphertext"` // Base64 encoded
        IV         string                 `json:"iv"`         // Base64 encoded initialization vector
        Tag        string                 `json:"tag"`        // Base64 encoded authentication tag (for AEAD)
        Timestamp  time.Time              `json:"timestamp"`
        Metadata   map[string]interface{} `json:"metadata,omitempty"`
}

// NewEncryptionManager creates a new encryption manager
func NewEncryptionManager() *EncryptionManager <span class="cov0" title="0">{
        config := &amp;EncryptionConfig{
                Algorithm:           "AES-256-GCM",
                KeySize:             32,                  // 256 bits
                KeyRotationInterval: 30 * 24 * time.Hour, // 30 days
                EnableKeyRotation:   true,
                MasterKeyPath:       "/etc/chatbot/master.key",
                HSMEnabled:          false,
        }

        manager := &amp;EncryptionManager{
                logger:   logrus.New(),
                keyStore: make(map[string]*EncryptionKey),
                config:   config,
        }

        // Initialize master key
        if err := manager.initializeMasterKey(); err != nil </span><span class="cov0" title="0">{
                manager.logger.Errorf("Failed to initialize master key: %v", err)
        }</span>

        // Start key rotation routine
        <span class="cov0" title="0">if config.EnableKeyRotation </span><span class="cov0" title="0">{
                go manager.keyRotationRoutine()
        }</span>

        <span class="cov0" title="0">return manager</span>
}

// initializeMasterKey initializes or loads the master encryption key
func (em *EncryptionManager) initializeMasterKey() error <span class="cov0" title="0">{
        // In production, this would load from a secure key management system
        // For now, generate a random master key
        masterKey := make([]byte, 32)
        if _, err := rand.Read(masterKey); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate master key: %v", err)
        }</span>

        <span class="cov0" title="0">em.masterKey = masterKey
        em.logger.Info("Master encryption key initialized")

        return nil</span>
}

// GenerateKey generates a new encryption key
func (em *EncryptionManager) GenerateKey(purpose KeyPurpose, expirationDays int) (*EncryptionKey, error) <span class="cov0" title="0">{
        keyData := make([]byte, em.config.KeySize)
        if _, err := rand.Read(keyData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate key data: %v", err)
        }</span>

        <span class="cov0" title="0">key := &amp;EncryptionKey{
                ID:        generateKeyID(),
                Algorithm: em.config.Algorithm,
                KeyData:   keyData,
                Purpose:   purpose,
                Status:    KeyStatusActive,
                CreatedAt: time.Now(),
                ExpiresAt: time.Now().AddDate(0, 0, expirationDays),
                Usage: &amp;KeyUsage{
                        EncryptionCount: 0,
                        DecryptionCount: 0,
                        BytesEncrypted:  0,
                        BytesDecrypted:  0,
                },
                Metadata: make(map[string]interface{}),
        }

        em.mu.Lock()
        em.keyStore[key.ID] = key
        em.mu.Unlock()

        em.logger.Infof("Generated new encryption key: %s (purpose: %s)", key.ID, purpose)

        return key, nil</span>
}

// GetKey retrieves an encryption key by ID
func (em *EncryptionManager) GetKey(keyID string) (*EncryptionKey, error) <span class="cov0" title="0">{
        em.mu.RLock()
        defer em.mu.RUnlock()

        key, exists := em.keyStore[keyID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key not found: %s", keyID)
        }</span>

        <span class="cov0" title="0">if key.Status == KeyStatusRevoked </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key is revoked: %s", keyID)
        }</span>

        <span class="cov0" title="0">if time.Now().After(key.ExpiresAt) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key is expired: %s", keyID)
        }</span>

        <span class="cov0" title="0">return key, nil</span>
}

// Encrypt encrypts data using the specified key
func (em *EncryptionManager) Encrypt(keyID string, plaintext []byte) (*EncryptedData, error) <span class="cov0" title="0">{
        key, err := em.GetKey(keyID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">switch key.Algorithm </span>{
        case "AES-256-GCM":<span class="cov0" title="0">
                return em.encryptAESGCM(key, plaintext)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported algorithm: %s", key.Algorithm)</span>
        }
}

// Decrypt decrypts data using the specified key
func (em *EncryptionManager) Decrypt(encryptedData *EncryptedData) ([]byte, error) <span class="cov0" title="0">{
        key, err := em.GetKey(encryptedData.KeyID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">switch encryptedData.Algorithm </span>{
        case "AES-256-GCM":<span class="cov0" title="0">
                return em.decryptAESGCM(key, encryptedData)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported algorithm: %s", encryptedData.Algorithm)</span>
        }
}

// encryptAESGCM encrypts data using AES-256-GCM
func (em *EncryptionManager) encryptAESGCM(key *EncryptionKey, plaintext []byte) (*EncryptedData, error) <span class="cov0" title="0">{
        block, err := aes.NewCipher(key.KeyData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cipher: %v", err)
        }</span>

        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM: %v", err)
        }</span>

        // Generate random IV
        <span class="cov0" title="0">iv := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, iv); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate IV: %v", err)
        }</span>

        // Encrypt and authenticate
        <span class="cov0" title="0">ciphertext := gcm.Seal(nil, iv, plaintext, nil)

        // Update key usage
        em.mu.Lock()
        key.Usage.EncryptionCount++
        key.Usage.BytesEncrypted += int64(len(plaintext))
        key.Usage.LastUsed = time.Now()
        em.mu.Unlock()

        return &amp;EncryptedData{
                KeyID:      key.ID,
                Algorithm:  key.Algorithm,
                Ciphertext: base64.StdEncoding.EncodeToString(ciphertext),
                IV:         base64.StdEncoding.EncodeToString(iv),
                Timestamp:  time.Now(),
        }, nil</span>
}

// decryptAESGCM decrypts data using AES-256-GCM
func (em *EncryptionManager) decryptAESGCM(key *EncryptionKey, encryptedData *EncryptedData) ([]byte, error) <span class="cov0" title="0">{
        block, err := aes.NewCipher(key.KeyData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create cipher: %v", err)
        }</span>

        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create GCM: %v", err)
        }</span>

        // Decode base64 data
        <span class="cov0" title="0">ciphertext, err := base64.StdEncoding.DecodeString(encryptedData.Ciphertext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode ciphertext: %v", err)
        }</span>

        <span class="cov0" title="0">iv, err := base64.StdEncoding.DecodeString(encryptedData.IV)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode IV: %v", err)
        }</span>

        // Decrypt and verify
        <span class="cov0" title="0">plaintext, err := gcm.Open(nil, iv, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt: %v", err)
        }</span>

        // Update key usage
        <span class="cov0" title="0">em.mu.Lock()
        key.Usage.DecryptionCount++
        key.Usage.BytesDecrypted += int64(len(plaintext))
        key.Usage.LastUsed = time.Now()
        em.mu.Unlock()

        return plaintext, nil</span>
}

// EncryptString encrypts a string and returns base64 encoded result
func (em *EncryptionManager) EncryptString(keyID, plaintext string) (string, error) <span class="cov0" title="0">{
        encryptedData, err := em.Encrypt(keyID, []byte(plaintext))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Serialize encrypted data to JSON and encode as base64
        <span class="cov0" title="0">jsonData := fmt.Sprintf(`{"key_id":"%s","algorithm":"%s","ciphertext":"%s","iv":"%s","timestamp":"%s"}`,
                encryptedData.KeyID,
                encryptedData.Algorithm,
                encryptedData.Ciphertext,
                encryptedData.IV,
                encryptedData.Timestamp.Format(time.RFC3339))

        return base64.StdEncoding.EncodeToString([]byte(jsonData)), nil</span>
}

// DecryptString decrypts a base64 encoded encrypted string
func (em *EncryptionManager) DecryptString(encryptedString string) (string, error) <span class="cov0" title="0">{
        // Decode base64
        _, err := base64.StdEncoding.DecodeString(encryptedString)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode encrypted string: %v", err)
        }</span>

        // Parse JSON (simplified parsing for this example)
        // In production, use proper JSON parsing
        <span class="cov0" title="0">var encryptedData EncryptedData
        // This is a simplified implementation - in production, use json.Unmarshal

        plaintext, err := em.Decrypt(&amp;encryptedData)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return string(plaintext), nil</span>
}

// RotateKey rotates an encryption key
func (em *EncryptionManager) RotateKey(keyID string) (*EncryptionKey, error) <span class="cov0" title="0">{
        em.mu.Lock()
        defer em.mu.Unlock()

        oldKey, exists := em.keyStore[keyID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key not found: %s", keyID)
        }</span>

        // Mark old key as deprecated
        <span class="cov0" title="0">oldKey.Status = KeyStatusDeprecated
        now := time.Now()
        oldKey.RotatedAt = &amp;now

        // Generate new key with same purpose
        newKeyData := make([]byte, em.config.KeySize)
        if _, err := rand.Read(newKeyData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate new key data: %v", err)
        }</span>

        <span class="cov0" title="0">newKey := &amp;EncryptionKey{
                ID:        generateKeyID(),
                Algorithm: oldKey.Algorithm,
                KeyData:   newKeyData,
                Purpose:   oldKey.Purpose,
                Status:    KeyStatusActive,
                CreatedAt: time.Now(),
                ExpiresAt: time.Now().Add(em.config.KeyRotationInterval),
                Usage: &amp;KeyUsage{
                        EncryptionCount: 0,
                        DecryptionCount: 0,
                        BytesEncrypted:  0,
                        BytesDecrypted:  0,
                },
                Metadata: make(map[string]interface{}),
        }

        em.keyStore[newKey.ID] = newKey

        em.logger.Infof("Rotated encryption key: %s -&gt; %s", keyID, newKey.ID)

        return newKey, nil</span>
}

// RevokeKey revokes an encryption key
func (em *EncryptionManager) RevokeKey(keyID string, reason string) error <span class="cov0" title="0">{
        em.mu.Lock()
        defer em.mu.Unlock()

        key, exists := em.keyStore[keyID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("key not found: %s", keyID)
        }</span>

        <span class="cov0" title="0">key.Status = KeyStatusRevoked
        key.Metadata["revocation_reason"] = reason
        key.Metadata["revoked_at"] = time.Now()

        em.logger.Warnf("Revoked encryption key: %s (reason: %s)", keyID, reason)

        return nil</span>
}

// ListKeys returns all encryption keys with their metadata
func (em *EncryptionManager) ListKeys() []*EncryptionKey <span class="cov0" title="0">{
        em.mu.RLock()
        defer em.mu.RUnlock()

        keys := make([]*EncryptionKey, 0, len(em.keyStore))
        for _, key := range em.keyStore </span><span class="cov0" title="0">{
                // Create a copy without the key data for security
                keyCopy := &amp;EncryptionKey{
                        ID:        key.ID,
                        Algorithm: key.Algorithm,
                        Purpose:   key.Purpose,
                        Status:    key.Status,
                        CreatedAt: key.CreatedAt,
                        ExpiresAt: key.ExpiresAt,
                        RotatedAt: key.RotatedAt,
                        Usage:     key.Usage,
                        Metadata:  key.Metadata,
                }
                keys = append(keys, keyCopy)
        }</span>

        <span class="cov0" title="0">return keys</span>
}

// GetKeysByPurpose returns all keys for a specific purpose
func (em *EncryptionManager) GetKeysByPurpose(purpose KeyPurpose) []*EncryptionKey <span class="cov0" title="0">{
        em.mu.RLock()
        defer em.mu.RUnlock()

        var keys []*EncryptionKey
        for _, key := range em.keyStore </span><span class="cov0" title="0">{
                if key.Purpose == purpose &amp;&amp; key.Status == KeyStatusActive </span><span class="cov0" title="0">{
                        keyCopy := &amp;EncryptionKey{
                                ID:        key.ID,
                                Algorithm: key.Algorithm,
                                Purpose:   key.Purpose,
                                Status:    key.Status,
                                CreatedAt: key.CreatedAt,
                                ExpiresAt: key.ExpiresAt,
                                RotatedAt: key.RotatedAt,
                                Usage:     key.Usage,
                                Metadata:  key.Metadata,
                        }
                        keys = append(keys, keyCopy)
                }</span>
        }

        <span class="cov0" title="0">return keys</span>
}

// keyRotationRoutine runs in the background to rotate keys
func (em *EncryptionManager) keyRotationRoutine() <span class="cov0" title="0">{
        ticker := time.NewTicker(24 * time.Hour) // Check daily
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                em.mu.RLock()
                keysToRotate := make([]string, 0)

                for keyID, key := range em.keyStore </span><span class="cov0" title="0">{
                        if key.Status == KeyStatusActive &amp;&amp;
                                time.Now().After(key.CreatedAt.Add(em.config.KeyRotationInterval)) </span><span class="cov0" title="0">{
                                keysToRotate = append(keysToRotate, keyID)
                        }</span>
                }
                <span class="cov0" title="0">em.mu.RUnlock()

                for _, keyID := range keysToRotate </span><span class="cov0" title="0">{
                        if _, err := em.RotateKey(keyID); err != nil </span><span class="cov0" title="0">{
                                em.logger.Errorf("Failed to rotate key %s: %v", keyID, err)
                        }</span>
                }
        }
}

// RSA key pair generation and operations

// GenerateRSAKeyPair generates an RSA key pair
func (em *EncryptionManager) GenerateRSAKeyPair(keySize int) (*rsa.PrivateKey, *rsa.PublicKey, error) <span class="cov0" title="0">{
        privateKey, err := rsa.GenerateKey(rand.Reader, keySize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to generate RSA key pair: %v", err)
        }</span>

        <span class="cov0" title="0">return privateKey, &amp;privateKey.PublicKey, nil</span>
}

// EncryptRSA encrypts data using RSA public key
func (em *EncryptionManager) EncryptRSA(publicKey *rsa.PublicKey, plaintext []byte) ([]byte, error) <span class="cov0" title="0">{
        ciphertext, err := rsa.EncryptOAEP(sha256.New(), rand.Reader, publicKey, plaintext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt with RSA: %v", err)
        }</span>

        <span class="cov0" title="0">return ciphertext, nil</span>
}

// DecryptRSA decrypts data using RSA private key
func (em *EncryptionManager) DecryptRSA(privateKey *rsa.PrivateKey, ciphertext []byte) ([]byte, error) <span class="cov0" title="0">{
        plaintext, err := rsa.DecryptOAEP(sha256.New(), rand.Reader, privateKey, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decrypt with RSA: %v", err)
        }</span>

        <span class="cov0" title="0">return plaintext, nil</span>
}

// ExportPublicKeyPEM exports RSA public key as PEM
func (em *EncryptionManager) ExportPublicKeyPEM(publicKey *rsa.PublicKey) (string, error) <span class="cov0" title="0">{
        pubKeyBytes, err := x509.MarshalPKIXPublicKey(publicKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal public key: %v", err)
        }</span>

        <span class="cov0" title="0">pubKeyPEM := pem.EncodeToMemory(&amp;pem.Block{
                Type:  "PUBLIC KEY",
                Bytes: pubKeyBytes,
        })

        return string(pubKeyPEM), nil</span>
}

// ImportPublicKeyPEM imports RSA public key from PEM
func (em *EncryptionManager) ImportPublicKeyPEM(pemData string) (*rsa.PublicKey, error) <span class="cov0" title="0">{
        block, _ := pem.Decode([]byte(pemData))
        if block == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode PEM block")
        }</span>

        <span class="cov0" title="0">pubKey, err := x509.ParsePKIXPublicKey(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse public key: %v", err)
        }</span>

        <span class="cov0" title="0">rsaPubKey, ok := pubKey.(*rsa.PublicKey)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("not an RSA public key")
        }</span>

        <span class="cov0" title="0">return rsaPubKey, nil</span>
}

// Utility functions

func generateKeyID() string <span class="cov0" title="0">{
        timestamp := time.Now().UnixNano()
        return fmt.Sprintf("key_%d", timestamp)
}</span>

// GetKeyUsageStats returns usage statistics for all keys
func (em *EncryptionManager) GetKeyUsageStats() map[string]*KeyUsage <span class="cov0" title="0">{
        em.mu.RLock()
        defer em.mu.RUnlock()

        stats := make(map[string]*KeyUsage)
        for keyID, key := range em.keyStore </span><span class="cov0" title="0">{
                stats[keyID] = &amp;KeyUsage{
                        EncryptionCount: key.Usage.EncryptionCount,
                        DecryptionCount: key.Usage.DecryptionCount,
                        LastUsed:        key.Usage.LastUsed,
                        BytesEncrypted:  key.Usage.BytesEncrypted,
                        BytesDecrypted:  key.Usage.BytesDecrypted,
                }
        }</span>

        <span class="cov0" title="0">return stats</span>
}

// CleanupExpiredKeys removes expired and revoked keys
func (em *EncryptionManager) CleanupExpiredKeys() int <span class="cov0" title="0">{
        em.mu.Lock()
        defer em.mu.Unlock()

        cleaned := 0
        for keyID, key := range em.keyStore </span><span class="cov0" title="0">{
                if (key.Status == KeyStatusRevoked &amp;&amp;
                        key.Metadata["revoked_at"] != nil &amp;&amp;
                        time.Since(key.Metadata["revoked_at"].(time.Time)) &gt; 90*24*time.Hour) ||
                        (key.Status == KeyStatusDeprecated &amp;&amp;
                                key.RotatedAt != nil &amp;&amp;
                                time.Since(*key.RotatedAt) &gt; 90*24*time.Hour) </span><span class="cov0" title="0">{
                        delete(em.keyStore, keyID)
                        cleaned++
                        em.logger.Infof("Cleaned up expired key: %s", keyID)
                }</span>
        }

        <span class="cov0" title="0">return cleaned</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package security

import (
        "context"
        "math"
        "net"
        "strings"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

// RiskScore represents a calculated risk score
type RiskScore struct {
        Score        float64                `json:"score"` // 0.0 to 1.0
        Level        RiskLevel              `json:"level"`
        Factors      []*RiskFactor          `json:"factors"`
        Confidence   float64                `json:"confidence"` // 0.0 to 1.0
        Metadata     map[string]interface{} `json:"metadata"`
        CalculatedAt time.Time              `json:"calculated_at"`
}

// RiskLevel represents the risk level
type RiskLevel string

const (
        RiskLevelLow      RiskLevel = "low"
        RiskLevelMedium   RiskLevel = "medium"
        RiskLevelHigh     RiskLevel = "high"
        RiskLevelCritical RiskLevel = "critical"
)

// RiskFactor represents an individual risk factor
type RiskFactor struct {
        Type        RiskFactorType         `json:"type"`
        Name        string                 `json:"name"`
        Score       float64                `json:"score"`  // 0.0 to 1.0
        Weight      float64                `json:"weight"` // 0.0 to 1.0
        Description string                 `json:"description"`
        Evidence    map[string]interface{} `json:"evidence"`
}

// RiskFactorType represents the type of risk factor
type RiskFactorType string

const (
        RiskFactorBehavioral     RiskFactorType = "behavioral"
        RiskFactorGeographical   RiskFactorType = "geographical"
        RiskFactorTemporal       RiskFactorType = "temporal"
        RiskFactorDevice         RiskFactorType = "device"
        RiskFactorNetwork        RiskFactorType = "network"
        RiskFactorAuthentication RiskFactorType = "authentication"
        RiskFactorData           RiskFactorType = "data"
)

// UserBehaviorProfile represents a user's behavioral profile
type UserBehaviorProfile struct {
        UserID              string                 `json:"user_id"`
        TypicalLocations    []Location             `json:"typical_locations"`
        TypicalDevices      []string               `json:"typical_devices"`
        TypicalAccessTimes  []TimeWindow           `json:"typical_access_times"`
        TypicalResources    []string               `json:"typical_resources"`
        FailedAttempts      int                    `json:"failed_attempts"`
        LastSuccessfulLogin time.Time              `json:"last_successful_login"`
        AverageSessionTime  time.Duration          `json:"average_session_time"`
        AccessPatterns      map[string]interface{} `json:"access_patterns"`
        CreatedAt           time.Time              `json:"created_at"`
        UpdatedAt           time.Time              `json:"updated_at"`
}

// TimeWindow represents a time window for access patterns
type TimeWindow struct {
        StartHour int `json:"start_hour"`  // 0-23
        EndHour   int `json:"end_hour"`    // 0-23
        DayOfWeek int `json:"day_of_week"` // 0-6 (Sunday-Saturday)
}

// ThreatIntelligence represents threat intelligence data
type ThreatIntelligence struct {
        MaliciousIPs      map[string]ThreatInfo `json:"malicious_ips"`
        SuspiciousDevices map[string]ThreatInfo `json:"suspicious_devices"`
        KnownAttackers    map[string]ThreatInfo `json:"known_attackers"`
        UpdatedAt         time.Time             `json:"updated_at"`
}

// ThreatInfo represents information about a threat
type ThreatInfo struct {
        Severity    string                 `json:"severity"`
        Source      string                 `json:"source"`
        Description string                 `json:"description"`
        FirstSeen   time.Time              `json:"first_seen"`
        LastSeen    time.Time              `json:"last_seen"`
        Metadata    map[string]interface{} `json:"metadata"`
}

// RiskEngine calculates risk scores for access requests
type RiskEngine struct {
        logger             *logrus.Logger
        behaviorProfiles   map[string]*UserBehaviorProfile
        threatIntelligence *ThreatIntelligence
        mu                 sync.RWMutex
        config             *RiskEngineConfig
}

// RiskEngineConfig contains configuration for the risk engine
type RiskEngineConfig struct {
        EnableBehavioralAnalysis    bool          `json:"enable_behavioral_analysis"`
        EnableThreatIntelligence    bool          `json:"enable_threat_intelligence"`
        EnableGeolocation           bool          `json:"enable_geolocation"`
        BehaviorLearningPeriod      time.Duration `json:"behavior_learning_period"`
        ThreatIntelUpdateInterval   time.Duration `json:"threat_intel_update_interval"`
        MaxFailedAttempts           int           `json:"max_failed_attempts"`
        SuspiciousActivityThreshold float64       `json:"suspicious_activity_threshold"`
}

// NewRiskEngine creates a new risk assessment engine
func NewRiskEngine() *RiskEngine <span class="cov0" title="0">{
        config := &amp;RiskEngineConfig{
                EnableBehavioralAnalysis:    true,
                EnableThreatIntelligence:    true,
                EnableGeolocation:           true,
                BehaviorLearningPeriod:      30 * 24 * time.Hour, // 30 days
                ThreatIntelUpdateInterval:   time.Hour,
                MaxFailedAttempts:           5,
                SuspiciousActivityThreshold: 0.7,
        }

        engine := &amp;RiskEngine{
                logger:           logrus.New(),
                behaviorProfiles: make(map[string]*UserBehaviorProfile),
                threatIntelligence: &amp;ThreatIntelligence{
                        MaliciousIPs:      make(map[string]ThreatInfo),
                        SuspiciousDevices: make(map[string]ThreatInfo),
                        KnownAttackers:    make(map[string]ThreatInfo),
                        UpdatedAt:         time.Now(),
                },
                config: config,
        }

        // Start background tasks
        go engine.updateThreatIntelligence()
        go engine.cleanupOldProfiles()

        return engine
}</span>

// CalculateRiskScore calculates the risk score for an access request
func (re *RiskEngine) CalculateRiskScore(ctx context.Context, request *AccessRequest) (float64, error) <span class="cov0" title="0">{
        startTime := time.Now()

        var factors []*RiskFactor

        // Behavioral analysis
        if re.config.EnableBehavioralAnalysis </span><span class="cov0" title="0">{
                behavioralFactors := re.analyzeBehavioralRisk(request)
                factors = append(factors, behavioralFactors...)
        }</span>

        // Geographical analysis
        <span class="cov0" title="0">if re.config.EnableGeolocation &amp;&amp; request.Context.Location != nil </span><span class="cov0" title="0">{
                geoFactors := re.analyzeGeographicalRisk(request)
                factors = append(factors, geoFactors...)
        }</span>

        // Temporal analysis
        <span class="cov0" title="0">temporalFactors := re.analyzeTemporalRisk(request)
        factors = append(factors, temporalFactors...)

        // Device analysis
        deviceFactors := re.analyzeDeviceRisk(request)
        factors = append(factors, deviceFactors...)

        // Network analysis
        networkFactors := re.analyzeNetworkRisk(request)
        factors = append(factors, networkFactors...)

        // Authentication analysis
        authFactors := re.analyzeAuthenticationRisk(request)
        factors = append(factors, authFactors...)

        // Threat intelligence analysis
        if re.config.EnableThreatIntelligence </span><span class="cov0" title="0">{
                threatFactors := re.analyzeThreatIntelligence(request)
                factors = append(factors, threatFactors...)
        }</span>

        // Calculate weighted risk score
        <span class="cov0" title="0">totalScore := 0.0
        totalWeight := 0.0
        confidence := 1.0

        for _, factor := range factors </span><span class="cov0" title="0">{
                totalScore += factor.Score * factor.Weight
                totalWeight += factor.Weight
                confidence = math.Min(confidence, 0.9) // Reduce confidence slightly for each factor
        }</span>

        <span class="cov0" title="0">finalScore := 0.0
        if totalWeight &gt; 0 </span><span class="cov0" title="0">{
                finalScore = totalScore / totalWeight
        }</span>

        // Determine risk level
        <span class="cov0" title="0">level := re.determineRiskLevel(finalScore)

        _ = &amp;RiskScore{
                Score:      finalScore,
                Level:      level,
                Factors:    factors,
                Confidence: confidence,
                Metadata: map[string]interface{}{
                        "calculation_time": time.Since(startTime).Milliseconds(),
                        "factors_count":    len(factors),
                },
                CalculatedAt: time.Now(),
        }

        re.logger.Debugf("Calculated risk score %.3f (%s) for user %s in %v",
                finalScore, level, request.UserID, time.Since(startTime))

        return finalScore, nil</span>
}

// analyzeBehavioralRisk analyzes behavioral risk factors
func (re *RiskEngine) analyzeBehavioralRisk(request *AccessRequest) []*RiskFactor <span class="cov0" title="0">{
        var factors []*RiskFactor

        re.mu.RLock()
        profile, exists := re.behaviorProfiles[request.UserID]
        re.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                // New user - medium risk
                factors = append(factors, &amp;RiskFactor{
                        Type:        RiskFactorBehavioral,
                        Name:        "new_user",
                        Score:       0.5,
                        Weight:      0.3,
                        Description: "New user with no behavioral history",
                        Evidence: map[string]interface{}{
                                "user_id": request.UserID,
                        },
                })
                return factors
        }</span>

        // Check location deviation
        <span class="cov0" title="0">if request.Context.Location != nil </span><span class="cov0" title="0">{
                locationRisk := re.calculateLocationDeviation(profile, request.Context.Location)
                if locationRisk &gt; 0.1 </span><span class="cov0" title="0">{
                        factors = append(factors, &amp;RiskFactor{
                                Type:        RiskFactorBehavioral,
                                Name:        "location_deviation",
                                Score:       locationRisk,
                                Weight:      0.4,
                                Description: "Access from unusual location",
                                Evidence: map[string]interface{}{
                                        "current_location":  request.Context.Location,
                                        "typical_locations": profile.TypicalLocations,
                                },
                        })
                }</span>
        }

        // Check device deviation
        <span class="cov0" title="0">if request.Context.DeviceID != "" </span><span class="cov0" title="0">{
                deviceRisk := re.calculateDeviceDeviation(profile, request.Context.DeviceID)
                if deviceRisk &gt; 0.1 </span><span class="cov0" title="0">{
                        factors = append(factors, &amp;RiskFactor{
                                Type:        RiskFactorBehavioral,
                                Name:        "device_deviation",
                                Score:       deviceRisk,
                                Weight:      0.3,
                                Description: "Access from unusual device",
                                Evidence: map[string]interface{}{
                                        "current_device":  request.Context.DeviceID,
                                        "typical_devices": profile.TypicalDevices,
                                },
                        })
                }</span>
        }

        // Check time deviation
        <span class="cov0" title="0">timeRisk := re.calculateTimeDeviation(profile, request.Timestamp)
        if timeRisk &gt; 0.1 </span><span class="cov0" title="0">{
                factors = append(factors, &amp;RiskFactor{
                        Type:        RiskFactorBehavioral,
                        Name:        "time_deviation",
                        Score:       timeRisk,
                        Weight:      0.2,
                        Description: "Access at unusual time",
                        Evidence: map[string]interface{}{
                                "current_time":  request.Timestamp,
                                "typical_times": profile.TypicalAccessTimes,
                        },
                })
        }</span>

        // Check resource deviation
        <span class="cov0" title="0">resourceRisk := re.calculateResourceDeviation(profile, request.Resource)
        if resourceRisk &gt; 0.1 </span><span class="cov0" title="0">{
                factors = append(factors, &amp;RiskFactor{
                        Type:        RiskFactorBehavioral,
                        Name:        "resource_deviation",
                        Score:       resourceRisk,
                        Weight:      0.2,
                        Description: "Access to unusual resource",
                        Evidence: map[string]interface{}{
                                "current_resource":  request.Resource,
                                "typical_resources": profile.TypicalResources,
                        },
                })
        }</span>

        // Check failed attempts
        <span class="cov0" title="0">if profile.FailedAttempts &gt; re.config.MaxFailedAttempts </span><span class="cov0" title="0">{
                failureRisk := math.Min(1.0, float64(profile.FailedAttempts)/float64(re.config.MaxFailedAttempts*2))
                factors = append(factors, &amp;RiskFactor{
                        Type:        RiskFactorBehavioral,
                        Name:        "excessive_failures",
                        Score:       failureRisk,
                        Weight:      0.5,
                        Description: "Excessive failed login attempts",
                        Evidence: map[string]interface{}{
                                "failed_attempts": profile.FailedAttempts,
                                "max_allowed":     re.config.MaxFailedAttempts,
                        },
                })
        }</span>

        <span class="cov0" title="0">return factors</span>
}

// analyzeGeographicalRisk analyzes geographical risk factors
func (re *RiskEngine) analyzeGeographicalRisk(request *AccessRequest) []*RiskFactor <span class="cov0" title="0">{
        var factors []*RiskFactor

        location := request.Context.Location
        if location == nil </span><span class="cov0" title="0">{
                return factors
        }</span>

        // Check high-risk countries
        <span class="cov0" title="0">highRiskCountries := []string{"CN", "RU", "KP", "IR"} // Example list
        for _, country := range highRiskCountries </span><span class="cov0" title="0">{
                if location.Country == country </span><span class="cov0" title="0">{
                        factors = append(factors, &amp;RiskFactor{
                                Type:        RiskFactorGeographical,
                                Name:        "high_risk_country",
                                Score:       0.8,
                                Weight:      0.4,
                                Description: "Access from high-risk country",
                                Evidence: map[string]interface{}{
                                        "country": location.Country,
                                },
                        })
                        break</span>
                }
        }

        // Check for VPN/Proxy indicators
        <span class="cov0" title="0">if re.isVPNOrProxy(request.Context.IPAddress) </span><span class="cov0" title="0">{
                factors = append(factors, &amp;RiskFactor{
                        Type:        RiskFactorGeographical,
                        Name:        "vpn_proxy_detected",
                        Score:       0.6,
                        Weight:      0.3,
                        Description: "Access through VPN or proxy",
                        Evidence: map[string]interface{}{
                                "ip_address": request.Context.IPAddress,
                        },
                })
        }</span>

        <span class="cov0" title="0">return factors</span>
}

// analyzeTemporalRisk analyzes temporal risk factors
func (re *RiskEngine) analyzeTemporalRisk(request *AccessRequest) []*RiskFactor <span class="cov0" title="0">{
        var factors []*RiskFactor

        now := request.Timestamp
        hour := now.Hour()
        weekday := int(now.Weekday())

        // Check for off-hours access
        if hour &lt; 6 || hour &gt; 22 </span><span class="cov0" title="0">{ // Outside 6 AM - 10 PM
                factors = append(factors, &amp;RiskFactor{
                        Type:        RiskFactorTemporal,
                        Name:        "off_hours_access",
                        Score:       0.4,
                        Weight:      0.2,
                        Description: "Access during off-hours",
                        Evidence: map[string]interface{}{
                                "hour":    hour,
                                "weekday": weekday,
                        },
                })
        }</span>

        // Check for weekend access
        <span class="cov0" title="0">if weekday == 0 || weekday == 6 </span><span class="cov0" title="0">{ // Sunday or Saturday
                factors = append(factors, &amp;RiskFactor{
                        Type:        RiskFactorTemporal,
                        Name:        "weekend_access",
                        Score:       0.3,
                        Weight:      0.1,
                        Description: "Access during weekend",
                        Evidence: map[string]interface{}{
                                "weekday": weekday,
                        },
                })
        }</span>

        <span class="cov0" title="0">return factors</span>
}

// analyzeDeviceRisk analyzes device-related risk factors
func (re *RiskEngine) analyzeDeviceRisk(request *AccessRequest) []*RiskFactor <span class="cov0" title="0">{
        var factors []*RiskFactor

        // Check for missing device ID
        if request.Context.DeviceID == "" </span><span class="cov0" title="0">{
                factors = append(factors, &amp;RiskFactor{
                        Type:        RiskFactorDevice,
                        Name:        "missing_device_id",
                        Score:       0.5,
                        Weight:      0.3,
                        Description: "No device identifier provided",
                        Evidence: map[string]interface{}{
                                "user_agent": request.Context.UserAgent,
                        },
                })
        }</span>

        // Analyze user agent for suspicious patterns
        <span class="cov0" title="0">userAgent := request.Context.UserAgent
        if re.isSuspiciousUserAgent(userAgent) </span><span class="cov0" title="0">{
                factors = append(factors, &amp;RiskFactor{
                        Type:        RiskFactorDevice,
                        Name:        "suspicious_user_agent",
                        Score:       0.7,
                        Weight:      0.4,
                        Description: "Suspicious user agent detected",
                        Evidence: map[string]interface{}{
                                "user_agent": userAgent,
                        },
                })
        }</span>

        <span class="cov0" title="0">return factors</span>
}

// analyzeNetworkRisk analyzes network-related risk factors
func (re *RiskEngine) analyzeNetworkRisk(request *AccessRequest) []*RiskFactor <span class="cov0" title="0">{
        var factors []*RiskFactor

        ipAddress := request.Context.IPAddress

        // Check for private IP addresses
        if re.isPrivateIP(ipAddress) </span><span class="cov0" title="0">{
                factors = append(factors, &amp;RiskFactor{
                        Type:        RiskFactorNetwork,
                        Name:        "private_ip_access",
                        Score:       0.2,
                        Weight:      0.1,
                        Description: "Access from private IP address",
                        Evidence: map[string]interface{}{
                                "ip_address": ipAddress,
                        },
                })
        }</span>

        // Check for Tor exit nodes (simplified check)
        <span class="cov0" title="0">if re.isTorExitNode(ipAddress) </span><span class="cov0" title="0">{
                factors = append(factors, &amp;RiskFactor{
                        Type:        RiskFactorNetwork,
                        Name:        "tor_exit_node",
                        Score:       0.9,
                        Weight:      0.6,
                        Description: "Access from Tor exit node",
                        Evidence: map[string]interface{}{
                                "ip_address": ipAddress,
                        },
                })
        }</span>

        <span class="cov0" title="0">return factors</span>
}

// analyzeAuthenticationRisk analyzes authentication-related risk factors
func (re *RiskEngine) analyzeAuthenticationRisk(request *AccessRequest) []*RiskFactor <span class="cov0" title="0">{
        var factors []*RiskFactor

        // Check for missing session
        if request.Context.SessionID == "" </span><span class="cov0" title="0">{
                factors = append(factors, &amp;RiskFactor{
                        Type:        RiskFactorAuthentication,
                        Name:        "missing_session",
                        Score:       0.6,
                        Weight:      0.4,
                        Description: "No session identifier provided",
                        Evidence: map[string]interface{}{
                                "user_id": request.UserID,
                        },
                })
        }</span>

        // Check for weak authentication claims
        <span class="cov0" title="0">if len(request.Claims) == 0 </span><span class="cov0" title="0">{
                factors = append(factors, &amp;RiskFactor{
                        Type:        RiskFactorAuthentication,
                        Name:        "no_auth_claims",
                        Score:       0.8,
                        Weight:      0.5,
                        Description: "No authentication claims provided",
                        Evidence: map[string]interface{}{
                                "user_id": request.UserID,
                        },
                })
        }</span>

        <span class="cov0" title="0">return factors</span>
}

// analyzeThreatIntelligence analyzes threat intelligence data
func (re *RiskEngine) analyzeThreatIntelligence(request *AccessRequest) []*RiskFactor <span class="cov0" title="0">{
        var factors []*RiskFactor

        re.mu.RLock()
        defer re.mu.RUnlock()

        // Check malicious IPs
        if threat, exists := re.threatIntelligence.MaliciousIPs[request.Context.IPAddress]; exists </span><span class="cov0" title="0">{
                severity := 0.5
                if threat.Severity == "high" </span><span class="cov0" title="0">{
                        severity = 0.8
                }</span> else<span class="cov0" title="0"> if threat.Severity == "critical" </span><span class="cov0" title="0">{
                        severity = 1.0
                }</span>

                <span class="cov0" title="0">factors = append(factors, &amp;RiskFactor{
                        Type:        RiskFactorNetwork,
                        Name:        "malicious_ip",
                        Score:       severity,
                        Weight:      0.8,
                        Description: "IP address found in threat intelligence",
                        Evidence: map[string]interface{}{
                                "ip_address":  request.Context.IPAddress,
                                "threat_info": threat,
                        },
                })</span>
        }

        // Check suspicious devices
        <span class="cov0" title="0">if threat, exists := re.threatIntelligence.SuspiciousDevices[request.Context.DeviceID]; exists </span><span class="cov0" title="0">{
                factors = append(factors, &amp;RiskFactor{
                        Type:        RiskFactorDevice,
                        Name:        "suspicious_device",
                        Score:       0.7,
                        Weight:      0.6,
                        Description: "Device found in threat intelligence",
                        Evidence: map[string]interface{}{
                                "device_id":   request.Context.DeviceID,
                                "threat_info": threat,
                        },
                })
        }</span>

        // Check known attackers
        <span class="cov0" title="0">if threat, exists := re.threatIntelligence.KnownAttackers[request.UserID]; exists </span><span class="cov0" title="0">{
                factors = append(factors, &amp;RiskFactor{
                        Type:        RiskFactorBehavioral,
                        Name:        "known_attacker",
                        Score:       0.95,
                        Weight:      0.9,
                        Description: "User identified as known attacker",
                        Evidence: map[string]interface{}{
                                "user_id":     request.UserID,
                                "threat_info": threat,
                        },
                })
        }</span>

        <span class="cov0" title="0">return factors</span>
}

// Helper methods

func (re *RiskEngine) determineRiskLevel(score float64) RiskLevel <span class="cov0" title="0">{
        if score &gt;= 0.8 </span><span class="cov0" title="0">{
                return RiskLevelCritical
        }</span> else<span class="cov0" title="0"> if score &gt;= 0.6 </span><span class="cov0" title="0">{
                return RiskLevelHigh
        }</span> else<span class="cov0" title="0"> if score &gt;= 0.3 </span><span class="cov0" title="0">{
                return RiskLevelMedium
        }</span>
        <span class="cov0" title="0">return RiskLevelLow</span>
}

func (re *RiskEngine) calculateLocationDeviation(profile *UserBehaviorProfile, location *Location) float64 <span class="cov0" title="0">{
        if len(profile.TypicalLocations) == 0 </span><span class="cov0" title="0">{
                return 0.5 // Medium risk for no history
        }</span>

        <span class="cov0" title="0">minDistance := math.Inf(1)
        for _, typical := range profile.TypicalLocations </span><span class="cov0" title="0">{
                distance := re.calculateDistance(location, &amp;typical)
                if distance &lt; minDistance </span><span class="cov0" title="0">{
                        minDistance = distance
                }</span>
        }

        // Convert distance to risk score (0-1)
        // Distances over 1000km are considered high risk
        <span class="cov0" title="0">if minDistance &gt; 1000 </span><span class="cov0" title="0">{
                return 0.8
        }</span> else<span class="cov0" title="0"> if minDistance &gt; 500 </span><span class="cov0" title="0">{
                return 0.6
        }</span> else<span class="cov0" title="0"> if minDistance &gt; 100 </span><span class="cov0" title="0">{
                return 0.3
        }</span>
        <span class="cov0" title="0">return 0.1</span>
}

func (re *RiskEngine) calculateDistance(loc1, loc2 *Location) float64 <span class="cov0" title="0">{
        // Simplified distance calculation using Haversine formula
        const earthRadius = 6371 // km

        lat1Rad := loc1.Latitude * math.Pi / 180
        lat2Rad := loc2.Latitude * math.Pi / 180
        deltaLat := (loc2.Latitude - loc1.Latitude) * math.Pi / 180
        deltaLon := (loc2.Longitude - loc1.Longitude) * math.Pi / 180

        a := math.Sin(deltaLat/2)*math.Sin(deltaLat/2) +
                math.Cos(lat1Rad)*math.Cos(lat2Rad)*
                        math.Sin(deltaLon/2)*math.Sin(deltaLon/2)
        c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))

        return earthRadius * c
}</span>

func (re *RiskEngine) calculateDeviceDeviation(profile *UserBehaviorProfile, deviceID string) float64 <span class="cov0" title="0">{
        if len(profile.TypicalDevices) == 0 </span><span class="cov0" title="0">{
                return 0.5 // Medium risk for no history
        }</span>

        <span class="cov0" title="0">for _, typical := range profile.TypicalDevices </span><span class="cov0" title="0">{
                if typical == deviceID </span><span class="cov0" title="0">{
                        return 0.1 // Low risk for known device
                }</span>
        }

        <span class="cov0" title="0">return 0.7</span> // High risk for unknown device
}

func (re *RiskEngine) calculateTimeDeviation(profile *UserBehaviorProfile, timestamp time.Time) float64 <span class="cov0" title="0">{
        if len(profile.TypicalAccessTimes) == 0 </span><span class="cov0" title="0">{
                return 0.3 // Medium-low risk for no history
        }</span>

        <span class="cov0" title="0">hour := timestamp.Hour()
        weekday := int(timestamp.Weekday())

        for _, window := range profile.TypicalAccessTimes </span><span class="cov0" title="0">{
                if window.DayOfWeek == weekday &amp;&amp;
                        hour &gt;= window.StartHour &amp;&amp; hour &lt;= window.EndHour </span><span class="cov0" title="0">{
                        return 0.1 // Low risk for typical time
                }</span>
        }

        <span class="cov0" title="0">return 0.5</span> // Medium risk for atypical time
}

func (re *RiskEngine) calculateResourceDeviation(profile *UserBehaviorProfile, resource string) float64 <span class="cov0" title="0">{
        if len(profile.TypicalResources) == 0 </span><span class="cov0" title="0">{
                return 0.3 // Medium-low risk for no history
        }</span>

        <span class="cov0" title="0">for _, typical := range profile.TypicalResources </span><span class="cov0" title="0">{
                if typical == resource </span><span class="cov0" title="0">{
                        return 0.1 // Low risk for typical resource
                }</span>
        }

        <span class="cov0" title="0">return 0.4</span> // Medium risk for atypical resource
}

func (re *RiskEngine) isVPNOrProxy(ipAddress string) bool <span class="cov0" title="0">{
        // This would integrate with VPN/proxy detection services
        // For now, simple heuristic based on common VPN ranges
        vpnRanges := []string{
                "10.0.0.0/8",
                "172.16.0.0/12",
                "192.168.0.0/16",
        }

        ip := net.ParseIP(ipAddress)
        if ip == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, cidr := range vpnRanges </span><span class="cov0" title="0">{
                _, network, err := net.ParseCIDR(cidr)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if network.Contains(ip) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (re *RiskEngine) isPrivateIP(ipAddress string) bool <span class="cov0" title="0">{
        ip := net.ParseIP(ipAddress)
        if ip == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return ip.IsPrivate()</span>
}

func (re *RiskEngine) isTorExitNode(ipAddress string) bool <span class="cov0" title="0">{
        // This would check against a list of known Tor exit nodes
        // For now, return false
        return false
}</span>

func (re *RiskEngine) isSuspiciousUserAgent(userAgent string) bool <span class="cov0" title="0">{
        suspiciousPatterns := []string{
                "bot",
                "crawler",
                "spider",
                "scraper",
                "curl",
                "wget",
                "python",
                "java",
        }

        userAgentLower := strings.ToLower(userAgent)
        for _, pattern := range suspiciousPatterns </span><span class="cov0" title="0">{
                if strings.Contains(userAgentLower, pattern) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// Background tasks

func (re *RiskEngine) updateThreatIntelligence() <span class="cov0" title="0">{
        ticker := time.NewTicker(re.config.ThreatIntelUpdateInterval)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                // This would fetch threat intelligence from external sources
                // For now, just update the timestamp
                re.mu.Lock()
                re.threatIntelligence.UpdatedAt = time.Now()
                re.mu.Unlock()

                re.logger.Debug("Updated threat intelligence data")
        }</span>
}

func (re *RiskEngine) cleanupOldProfiles() <span class="cov0" title="0">{
        ticker := time.NewTicker(24 * time.Hour) // Daily cleanup
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                cutoff := time.Now().Add(-re.config.BehaviorLearningPeriod * 2)

                re.mu.Lock()
                for userID, profile := range re.behaviorProfiles </span><span class="cov0" title="0">{
                        if profile.UpdatedAt.Before(cutoff) </span><span class="cov0" title="0">{
                                delete(re.behaviorProfiles, userID)
                                re.logger.Debugf("Cleaned up old behavior profile for user %s", userID)
                        }</span>
                }
                <span class="cov0" title="0">re.mu.Unlock()</span>
        }
}

// UpdateUserBehavior updates a user's behavioral profile
func (re *RiskEngine) UpdateUserBehavior(userID string, request *AccessRequest, success bool) <span class="cov0" title="0">{
        re.mu.Lock()
        defer re.mu.Unlock()

        profile, exists := re.behaviorProfiles[userID]
        if !exists </span><span class="cov0" title="0">{
                profile = &amp;UserBehaviorProfile{
                        UserID:             userID,
                        TypicalLocations:   make([]Location, 0),
                        TypicalDevices:     make([]string, 0),
                        TypicalAccessTimes: make([]TimeWindow, 0),
                        TypicalResources:   make([]string, 0),
                        AccessPatterns:     make(map[string]interface{}),
                        CreatedAt:          time.Now(),
                }
                re.behaviorProfiles[userID] = profile
        }</span>

        <span class="cov0" title="0">if success </span><span class="cov0" title="0">{
                profile.LastSuccessfulLogin = request.Timestamp

                // Update typical locations
                if request.Context.Location != nil </span><span class="cov0" title="0">{
                        re.updateTypicalLocations(profile, request.Context.Location)
                }</span>

                // Update typical devices
                <span class="cov0" title="0">if request.Context.DeviceID != "" </span><span class="cov0" title="0">{
                        re.updateTypicalDevices(profile, request.Context.DeviceID)
                }</span>

                // Update typical access times
                <span class="cov0" title="0">re.updateTypicalAccessTimes(profile, request.Timestamp)

                // Update typical resources
                re.updateTypicalResources(profile, request.Resource)

                // Reset failed attempts on successful login
                profile.FailedAttempts = 0</span>
        } else<span class="cov0" title="0"> {
                profile.FailedAttempts++
        }</span>

        <span class="cov0" title="0">profile.UpdatedAt = time.Now()</span>
}

func (re *RiskEngine) updateTypicalLocations(profile *UserBehaviorProfile, location *Location) <span class="cov0" title="0">{
        // Add location if not already present
        for _, typical := range profile.TypicalLocations </span><span class="cov0" title="0">{
                if re.calculateDistance(location, &amp;typical) &lt; 50 </span><span class="cov0" title="0">{ // Within 50km
                        return // Already have similar location
                }</span>
        }

        <span class="cov0" title="0">profile.TypicalLocations = append(profile.TypicalLocations, *location)

        // Keep only the most recent 10 locations
        if len(profile.TypicalLocations) &gt; 10 </span><span class="cov0" title="0">{
                profile.TypicalLocations = profile.TypicalLocations[1:]
        }</span>
}

func (re *RiskEngine) updateTypicalDevices(profile *UserBehaviorProfile, deviceID string) <span class="cov0" title="0">{
        // Add device if not already present
        for _, typical := range profile.TypicalDevices </span><span class="cov0" title="0">{
                if typical == deviceID </span><span class="cov0" title="0">{
                        return // Already have this device
                }</span>
        }

        <span class="cov0" title="0">profile.TypicalDevices = append(profile.TypicalDevices, deviceID)

        // Keep only the most recent 5 devices
        if len(profile.TypicalDevices) &gt; 5 </span><span class="cov0" title="0">{
                profile.TypicalDevices = profile.TypicalDevices[1:]
        }</span>
}

func (re *RiskEngine) updateTypicalAccessTimes(profile *UserBehaviorProfile, timestamp time.Time) <span class="cov0" title="0">{
        hour := timestamp.Hour()
        weekday := int(timestamp.Weekday())

        // Create time window (Â±1 hour)
        startHour := hour - 1
        endHour := hour + 1
        if startHour &lt; 0 </span><span class="cov0" title="0">{
                startHour = 0
        }</span>
        <span class="cov0" title="0">if endHour &gt; 23 </span><span class="cov0" title="0">{
                endHour = 23
        }</span>

        <span class="cov0" title="0">window := TimeWindow{
                StartHour: startHour,
                EndHour:   endHour,
                DayOfWeek: weekday,
        }

        // Check if similar window already exists
        for _, typical := range profile.TypicalAccessTimes </span><span class="cov0" title="0">{
                if typical.DayOfWeek == weekday &amp;&amp;
                        abs(typical.StartHour-startHour) &lt;= 2 &amp;&amp;
                        abs(typical.EndHour-endHour) &lt;= 2 </span><span class="cov0" title="0">{
                        return // Already have similar time window
                }</span>
        }

        <span class="cov0" title="0">profile.TypicalAccessTimes = append(profile.TypicalAccessTimes, window)

        // Keep only the most recent 20 time windows
        if len(profile.TypicalAccessTimes) &gt; 20 </span><span class="cov0" title="0">{
                profile.TypicalAccessTimes = profile.TypicalAccessTimes[1:]
        }</span>
}

func (re *RiskEngine) updateTypicalResources(profile *UserBehaviorProfile, resource string) <span class="cov0" title="0">{
        // Add resource if not already present
        for _, typical := range profile.TypicalResources </span><span class="cov0" title="0">{
                if typical == resource </span><span class="cov0" title="0">{
                        return // Already have this resource
                }</span>
        }

        <span class="cov0" title="0">profile.TypicalResources = append(profile.TypicalResources, resource)

        // Keep only the most recent 50 resources
        if len(profile.TypicalResources) &gt; 50 </span><span class="cov0" title="0">{
                profile.TypicalResources = profile.TypicalResources[1:]
        }</span>
}

func abs(x int) int <span class="cov0" title="0">{
        if x &lt; 0 </span><span class="cov0" title="0">{
                return -x
        }</span>
        <span class="cov0" title="0">return x</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package security

import (
        "context"
        "database/sql"
        "fmt"
        "regexp"
        "strings"
        "time"

        "github.com/sirupsen/logrus"
)

// SQLSecurityConfig SQLå®‰å…¨é…ç½®
type SQLSecurityConfig struct {
        // æœ€å¤§æŸ¥è¯¢æ‰§è¡Œæ—¶é—´
        MaxQueryTimeout time.Duration
        // æœ€å¤§è¿”å›è¡Œæ•°
        MaxRows int
        // æ˜¯å¦å¯ç”¨æŸ¥è¯¢æ—¥å¿—
        EnableQueryLog bool
        // æ˜¯å¦å¯ç”¨SQLæ³¨å…¥æ£€æµ‹
        EnableInjectionDetection bool
        // å…è®¸çš„è¡¨åç™½åå•
        AllowedTables []string
        // ç¦æ­¢çš„SQLå…³é”®è¯
        ForbiddenKeywords []string
}

// DefaultSQLSecurityConfig é»˜è®¤å®‰å…¨é…ç½®
func DefaultSQLSecurityConfig() *SQLSecurityConfig <span class="cov0" title="0">{
        return &amp;SQLSecurityConfig{
                MaxQueryTimeout:          30 * time.Second,
                MaxRows:                  10000,
                EnableQueryLog:           true,
                EnableInjectionDetection: true,
                AllowedTables: []string{
                        "users", "conversations", "messages", "datasets",
                        "documents", "api_keys", "audit_logs",
                },
                ForbiddenKeywords: []string{
                        "DROP", "TRUNCATE", "ALTER", "CREATE", "GRANT", "REVOKE",
                        "EXEC", "EXECUTE", "xp_", "sp_", "UNION ALL", "INFORMATION_SCHEMA",
                },
        }
}</span>

// SecureDB å®‰å…¨æ•°æ®åº“åŒ…è£…å™¨
type SecureDB struct {
        db     *sql.DB
        config *SQLSecurityConfig
        logger *logrus.Logger
}

// NewSecureDB åˆ›å»ºå®‰å…¨æ•°æ®åº“åŒ…è£…å™¨
func NewSecureDB(db *sql.DB, config *SQLSecurityConfig) *SecureDB <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultSQLSecurityConfig()
        }</span>

        <span class="cov0" title="0">return &amp;SecureDB{
                db:     db,
                config: config,
                logger: logrus.New(),
        }</span>
}

// SQLInjectionDetector SQLæ³¨å…¥æ£€æµ‹å™¨
type SQLInjectionDetector struct {
        patterns []*regexp.Regexp
}

// NewSQLInjectionDetector åˆ›å»ºSQLæ³¨å…¥æ£€æµ‹å™¨
func NewSQLInjectionDetector() *SQLInjectionDetector <span class="cov0" title="0">{
        patterns := []*regexp.Regexp{
                // ç»å…¸SQLæ³¨å…¥æ¨¡å¼
                regexp.MustCompile(`(?i)(union\s+select|union\s+all\s+select)`),
                regexp.MustCompile(`(?i)(or\s+1\s*=\s*1|or\s+'1'\s*=\s*'1')`),
                regexp.MustCompile(`(?i)(and\s+1\s*=\s*1|and\s+'1'\s*=\s*'1')`),
                regexp.MustCompile(`(?i)(drop\s+table|drop\s+database)`),
                regexp.MustCompile(`(?i)(insert\s+into|update\s+.*\s+set)`),
                regexp.MustCompile(`(?i)(delete\s+from)`),
                regexp.MustCompile(`(?i)(exec\s*\(|execute\s*\()`),
                regexp.MustCompile(`(?i)(script\s*&gt;|javascript:|vbscript:)`),
                regexp.MustCompile(`(?i)(information_schema|sys\.|master\.)`),
                regexp.MustCompile(`(?i)(xp_cmdshell|sp_executesql)`),
                // æ—¶é—´ç›²æ³¨
                regexp.MustCompile(`(?i)(waitfor\s+delay|pg_sleep|sleep\s*\()`),
                // å¸ƒå°”ç›²æ³¨
                regexp.MustCompile(`(?i)(substring\s*\(|ascii\s*\(|length\s*\()`),
                // é”™è¯¯æ³¨å…¥
                regexp.MustCompile(`(?i)(convert\s*\(|cast\s*\(.*as)`),
                // å †å æŸ¥è¯¢
                regexp.MustCompile(`(?i)(;\s*drop|;\s*delete|;\s*update|;\s*insert)`),
        }

        return &amp;SQLInjectionDetector{patterns: patterns}
}</span>

// DetectInjection æ£€æµ‹SQLæ³¨å…¥
func (d *SQLInjectionDetector) DetectInjection(input string) (bool, string) <span class="cov0" title="0">{
        for _, pattern := range d.patterns </span><span class="cov0" title="0">{
                if pattern.MatchString(input) </span><span class="cov0" title="0">{
                        return true, pattern.String()
                }</span>
        }
        <span class="cov0" title="0">return false, ""</span>
}

// ValidateQuery éªŒè¯æŸ¥è¯¢å®‰å…¨æ€§
func (sdb *SecureDB) ValidateQuery(query string, args ...interface{}) error <span class="cov0" title="0">{
        if sdb.config.EnableInjectionDetection </span><span class="cov0" title="0">{
                detector := NewSQLInjectionDetector()

                // æ£€æŸ¥æŸ¥è¯¢æœ¬èº«
                if isInjection, pattern := detector.DetectInjection(query); isInjection </span><span class="cov0" title="0">{
                        sdb.logger.Warnf("SQL injection detected in query: %s, pattern: %s", query, pattern)
                        return fmt.Errorf("potentially malicious SQL query detected")
                }</span>

                // æ£€æŸ¥å‚æ•°
                <span class="cov0" title="0">for i, arg := range args </span><span class="cov0" title="0">{
                        if str, ok := arg.(string); ok </span><span class="cov0" title="0">{
                                if isInjection, pattern := detector.DetectInjection(str); isInjection </span><span class="cov0" title="0">{
                                        sdb.logger.Warnf("SQL injection detected in parameter %d: %s, pattern: %s", i, str, pattern)
                                        return fmt.Errorf("potentially malicious SQL parameter detected")
                                }</span>
                        }
                }
        }

        // æ£€æŸ¥è¡¨åç™½åå•
        <span class="cov0" title="0">if len(sdb.config.AllowedTables) &gt; 0 </span><span class="cov0" title="0">{
                if err := sdb.validateTableAccess(query); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // æ£€æŸ¥ç¦æ­¢çš„å…³é”®è¯
        <span class="cov0" title="0">if len(sdb.config.ForbiddenKeywords) &gt; 0 </span><span class="cov0" title="0">{
                if err := sdb.validateKeywords(query); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateTableAccess éªŒè¯è¡¨è®¿é—®æƒé™
func (sdb *SecureDB) validateTableAccess(query string) error <span class="cov0" title="0">{
        upperQuery := strings.ToUpper(query)

        // æå–è¡¨åçš„ç®€å•æ­£åˆ™ï¼ˆå¯ä»¥æ”¹è¿›ï¼‰
        tablePattern := regexp.MustCompile(`(?i)(FROM|JOIN|INTO|UPDATE)\s+([a-zA-Z_][a-zA-Z0-9_]*)`)
        matches := tablePattern.FindAllStringSubmatch(upperQuery, -1)

        for _, match := range matches </span><span class="cov0" title="0">{
                if len(match) &gt; 2 </span><span class="cov0" title="0">{
                        tableName := strings.ToLower(match[2])
                        allowed := false
                        for _, allowedTable := range sdb.config.AllowedTables </span><span class="cov0" title="0">{
                                if tableName == strings.ToLower(allowedTable) </span><span class="cov0" title="0">{
                                        allowed = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                                return fmt.Errorf("access to table '%s' is not allowed", tableName)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// validateKeywords éªŒè¯ç¦æ­¢çš„å…³é”®è¯
func (sdb *SecureDB) validateKeywords(query string) error <span class="cov0" title="0">{
        upperQuery := strings.ToUpper(query)

        for _, keyword := range sdb.config.ForbiddenKeywords </span><span class="cov0" title="0">{
                if strings.Contains(upperQuery, strings.ToUpper(keyword)) </span><span class="cov0" title="0">{
                        return fmt.Errorf("forbidden keyword '%s' detected in query", keyword)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// QueryContext å®‰å…¨çš„æŸ¥è¯¢æ‰§è¡Œ
func (sdb *SecureDB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        // éªŒè¯æŸ¥è¯¢
        if err := sdb.ValidateQuery(query, args...); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // è®¾ç½®è¶…æ—¶
        <span class="cov0" title="0">if sdb.config.MaxQueryTimeout &gt; 0 </span><span class="cov0" title="0">{
                var cancel context.CancelFunc
                ctx, cancel = context.WithTimeout(ctx, sdb.config.MaxQueryTimeout)
                defer cancel()
        }</span>

        // è®°å½•æŸ¥è¯¢æ—¥å¿—
        <span class="cov0" title="0">if sdb.config.EnableQueryLog </span><span class="cov0" title="0">{
                start := time.Now()
                defer func() </span><span class="cov0" title="0">{
                        duration := time.Since(start)
                        sdb.logger.Infof("SQL Query executed in %v: %s", duration, query)
                }</span>()
        }

        <span class="cov0" title="0">return sdb.db.QueryContext(ctx, query, args...)</span>
}

// QueryRowContext å®‰å…¨çš„å•è¡ŒæŸ¥è¯¢
func (sdb *SecureDB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        // éªŒè¯æŸ¥è¯¢
        if err := sdb.ValidateQuery(query, args...); err != nil </span><span class="cov0" title="0">{
                // è¿”å›ä¸€ä¸ªåŒ…å«é”™è¯¯çš„Row
                return &amp;sql.Row{}
        }</span>

        // è®¾ç½®è¶…æ—¶
        <span class="cov0" title="0">if sdb.config.MaxQueryTimeout &gt; 0 </span><span class="cov0" title="0">{
                var cancel context.CancelFunc
                ctx, cancel = context.WithTimeout(ctx, sdb.config.MaxQueryTimeout)
                defer cancel()
        }</span>

        // è®°å½•æŸ¥è¯¢æ—¥å¿—
        <span class="cov0" title="0">if sdb.config.EnableQueryLog </span><span class="cov0" title="0">{
                start := time.Now()
                defer func() </span><span class="cov0" title="0">{
                        duration := time.Since(start)
                        sdb.logger.Infof("SQL QueryRow executed in %v: %s", duration, query)
                }</span>()
        }

        <span class="cov0" title="0">return sdb.db.QueryRowContext(ctx, query, args...)</span>
}

// ExecContext å®‰å…¨çš„æ‰§è¡Œæ“ä½œ
func (sdb *SecureDB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        // éªŒè¯æŸ¥è¯¢
        if err := sdb.ValidateQuery(query, args...); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // è®¾ç½®è¶…æ—¶
        <span class="cov0" title="0">if sdb.config.MaxQueryTimeout &gt; 0 </span><span class="cov0" title="0">{
                var cancel context.CancelFunc
                ctx, cancel = context.WithTimeout(ctx, sdb.config.MaxQueryTimeout)
                defer cancel()
        }</span>

        // è®°å½•æŸ¥è¯¢æ—¥å¿—
        <span class="cov0" title="0">if sdb.config.EnableQueryLog </span><span class="cov0" title="0">{
                start := time.Now()
                defer func() </span><span class="cov0" title="0">{
                        duration := time.Since(start)
                        sdb.logger.Infof("SQL Exec executed in %v: %s", duration, query)
                }</span>()
        }

        <span class="cov0" title="0">return sdb.db.ExecContext(ctx, query, args...)</span>
}

// PrepareContext å®‰å…¨çš„é¢„å¤„ç†è¯­å¥
func (sdb *SecureDB) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        // éªŒè¯æŸ¥è¯¢
        if err := sdb.ValidateQuery(query); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return sdb.db.PrepareContext(ctx, query)</span>
}

// SanitizeInput è¾“å…¥æ¸…ç†å‡½æ•°
func SanitizeInput(input string) string <span class="cov0" title="0">{
        // ç§»é™¤æ½œåœ¨å±é™©å­—ç¬¦
        dangerous := []string{
                "'", "\"", ";", "--", "/*", "*/", "xp_", "sp_",
                "&lt;script", "&lt;/script&gt;", "javascript:", "vbscript:",
        }

        result := input
        for _, danger := range dangerous </span><span class="cov0" title="0">{
                result = strings.ReplaceAll(result, danger, "")
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(result)</span>
}

// ValidateTableName éªŒè¯è¡¨å
func ValidateTableName(tableName string) error <span class="cov0" title="0">{
        // è¡¨ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿
        matched, _ := regexp.MatchString(`^[a-zA-Z_][a-zA-Z0-9_]*$`, tableName)
        if !matched </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid table name: %s", tableName)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateColumnName éªŒè¯åˆ—å
func ValidateColumnName(columnName string) error <span class="cov0" title="0">{
        // åˆ—ååªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿
        matched, _ := regexp.MatchString(`^[a-zA-Z_][a-zA-Z0-9_]*$`, columnName)
        if !matched </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid column name: %s", columnName)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// BuildSafeOrderBy æ„å»ºå®‰å…¨çš„ORDER BYå­å¥
func BuildSafeOrderBy(column, direction string) (string, error) <span class="cov0" title="0">{
        // éªŒè¯åˆ—å
        if err := ValidateColumnName(column); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // éªŒè¯æ’åºæ–¹å‘
        <span class="cov0" title="0">direction = strings.ToUpper(strings.TrimSpace(direction))
        if direction != "ASC" &amp;&amp; direction != "DESC" </span><span class="cov0" title="0">{
                direction = "ASC"
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("ORDER BY %s %s", column, direction), nil</span>
}

// BuildSafeLimit æ„å»ºå®‰å…¨çš„LIMITå­å¥
func BuildSafeLimit(limit, offset int) string <span class="cov0" title="0">{
        // ç¡®ä¿limitå’Œoffsetä¸ºæ­£æ•°
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>
        <span class="cov0" title="0">if limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 1000 // æœ€å¤§é™åˆ¶
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("LIMIT %d OFFSET %d", limit, offset)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package security

import (
        "context"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/sirupsen/logrus"
)

// ZeroTrustPolicy represents a zero trust security policy
type ZeroTrustPolicy struct {
        ID                   string               `json:"id"`
        Name                 string               `json:"name"`
        Description          string               `json:"description"`
        Rules                []SecurityRule       `json:"rules"`
        RequiredClaims       []string             `json:"required_claims"`
        AllowedResources     []string             `json:"allowed_resources"`
        DeniedResources      []string             `json:"denied_resources"`
        TimeRestrictions     *TimeRestriction     `json:"time_restrictions,omitempty"`
        LocationRestrictions *LocationRestriction `json:"location_restrictions,omitempty"`
        DeviceRestrictions   *DeviceRestriction   `json:"device_restrictions,omitempty"`
        CreatedAt            time.Time            `json:"created_at"`
        UpdatedAt            time.Time            `json:"updated_at"`
        Enabled              bool                 `json:"enabled"`
}

// SecurityRule represents a security rule within a policy
type SecurityRule struct {
        ID        string            `json:"id"`
        Type      RuleType          `json:"type"`
        Condition string            `json:"condition"`
        Action    RuleAction        `json:"action"`
        Priority  int               `json:"priority"`
        Metadata  map[string]string `json:"metadata"`
}

// RuleType represents the type of security rule
type RuleType string

const (
        RuleTypeAuthentication RuleType = "authentication"
        RuleTypeAuthorization  RuleType = "authorization"
        RuleTypeRateLimit      RuleType = "rate_limit"
        RuleTypeDataAccess     RuleType = "data_access"
        RuleTypeAudit          RuleType = "audit"
        RuleTypeEncryption     RuleType = "encryption"
)

// RuleAction represents the action to take when a rule is triggered
type RuleAction string

const (
        ActionAllow     RuleAction = "allow"
        ActionDeny      RuleAction = "deny"
        ActionChallenge RuleAction = "challenge"
        ActionLog       RuleAction = "log"
        ActionAlert     RuleAction = "alert"
)

// TimeRestriction represents time-based access restrictions
type TimeRestriction struct {
        AllowedHours   []int    `json:"allowed_hours"` // 0-23
        AllowedDays    []int    `json:"allowed_days"`  // 0-6 (Sunday-Saturday)
        Timezone       string   `json:"timezone"`
        ExceptionDates []string `json:"exception_dates"` // YYYY-MM-DD format
}

// LocationRestriction represents location-based access restrictions
type LocationRestriction struct {
        AllowedCountries []string `json:"allowed_countries"`
        AllowedRegions   []string `json:"allowed_regions"`
        AllowedIPRanges  []string `json:"allowed_ip_ranges"`
        DeniedCountries  []string `json:"denied_countries"`
        DeniedIPRanges   []string `json:"denied_ip_ranges"`
}

// DeviceRestriction represents device-based access restrictions
type DeviceRestriction struct {
        AllowedDeviceTypes []string `json:"allowed_device_types"`
        RequiredDeviceID   bool     `json:"required_device_id"`
        AllowedDeviceIDs   []string `json:"allowed_device_ids"`
        RequireEncryption  bool     `json:"require_encryption"`
        RequireBiometric   bool     `json:"require_biometric"`
}

// AccessRequest represents a request for resource access
type AccessRequest struct {
        UserID    string                 `json:"user_id"`
        Resource  string                 `json:"resource"`
        Action    string                 `json:"action"`
        Context   RequestContext         `json:"context"`
        Claims    map[string]interface{} `json:"claims"`
        Timestamp time.Time              `json:"timestamp"`
}

// RequestContext contains contextual information about the request
type RequestContext struct {
        IPAddress string            `json:"ip_address"`
        UserAgent string            `json:"user_agent"`
        DeviceID  string            `json:"device_id"`
        Location  *Location         `json:"location,omitempty"`
        SessionID string            `json:"session_id"`
        RequestID string            `json:"request_id"`
        Headers   map[string]string `json:"headers"`
}

// Location represents geographical location information
type Location struct {
        Country   string  `json:"country"`
        Region    string  `json:"region"`
        City      string  `json:"city"`
        Latitude  float64 `json:"latitude"`
        Longitude float64 `json:"longitude"`
}

// AccessDecision represents the result of an access control decision
type AccessDecision struct {
        Allowed      bool              `json:"allowed"`
        Reason       string            `json:"reason"`
        PolicyID     string            `json:"policy_id"`
        RuleID       string            `json:"rule_id"`
        Action       RuleAction        `json:"action"`
        Confidence   float64           `json:"confidence"`
        Metadata     map[string]string `json:"metadata"`
        Timestamp    time.Time         `json:"timestamp"`
        SessionToken string            `json:"session_token,omitempty"`
}

// ZeroTrustEngine implements zero trust security architecture
type ZeroTrustEngine struct {
        policies      map[string]*ZeroTrustPolicy
        mu            sync.RWMutex
        logger        *logrus.Logger
        auditLogger   *AuditLogger
        riskEngine    *RiskEngine
        encryptionMgr *EncryptionManager
        complianceMgr *ComplianceManager
}

// NewZeroTrustEngine creates a new zero trust security engine
func NewZeroTrustEngine() *ZeroTrustEngine <span class="cov0" title="0">{
        return &amp;ZeroTrustEngine{
                policies:      make(map[string]*ZeroTrustPolicy),
                logger:        logrus.New(),
                auditLogger:   NewAuditLogger(),
                riskEngine:    NewRiskEngine(),
                encryptionMgr: NewEncryptionManager(),
                complianceMgr: NewComplianceManager(),
        }
}</span>

// AddPolicy adds a new zero trust policy
func (zte *ZeroTrustEngine) AddPolicy(policy *ZeroTrustPolicy) error <span class="cov0" title="0">{
        zte.mu.Lock()
        defer zte.mu.Unlock()

        if policy.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("policy ID cannot be empty")
        }</span>

        <span class="cov0" title="0">policy.CreatedAt = time.Now()
        policy.UpdatedAt = time.Now()

        zte.policies[policy.ID] = policy
        zte.logger.Infof("Added zero trust policy: %s", policy.ID)

        return nil</span>
}

// EvaluateAccess evaluates an access request against zero trust policies
func (zte *ZeroTrustEngine) EvaluateAccess(ctx context.Context, request *AccessRequest) (*AccessDecision, error) <span class="cov0" title="0">{
        startTime := time.Now()

        // Log the access request
        zte.auditLogger.LogAccessRequest(request)

        // Calculate risk score
        riskScore, err := zte.riskEngine.CalculateRiskScore(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                zte.logger.Errorf("Failed to calculate risk score: %v", err)
                riskScore = 0.5 // Default medium risk
        }</span>

        // Find applicable policies
        <span class="cov0" title="0">applicablePolicies := zte.findApplicablePolicies(request)

        if len(applicablePolicies) == 0 </span><span class="cov0" title="0">{
                // No policies found - default deny
                decision := &amp;AccessDecision{
                        Allowed:    false,
                        Reason:     "No applicable policies found",
                        Action:     ActionDeny,
                        Confidence: 1.0,
                        Timestamp:  time.Now(),
                }
                zte.auditLogger.LogAccessDecision(request, decision)
                return decision, nil
        }</span>

        // Evaluate each applicable policy
        <span class="cov0" title="0">var finalDecision *AccessDecision
        highestPriority := -1

        for _, policy := range applicablePolicies </span><span class="cov0" title="0">{
                decision, err := zte.evaluatePolicy(ctx, request, policy, riskScore)
                if err != nil </span><span class="cov0" title="0">{
                        zte.logger.Errorf("Failed to evaluate policy %s: %v", policy.ID, err)
                        continue</span>
                }

                // Use the decision from the highest priority rule
                <span class="cov0" title="0">if decision != nil </span><span class="cov0" title="0">{
                        for _, rule := range policy.Rules </span><span class="cov0" title="0">{
                                if rule.Priority &gt; highestPriority </span><span class="cov0" title="0">{
                                        highestPriority = rule.Priority
                                        finalDecision = decision
                                        finalDecision.PolicyID = policy.ID
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if finalDecision == nil </span><span class="cov0" title="0">{
                // No decision made - default deny
                finalDecision = &amp;AccessDecision{
                        Allowed:    false,
                        Reason:     "No policy evaluation resulted in a decision",
                        Action:     ActionDeny,
                        Confidence: 1.0,
                        Timestamp:  time.Now(),
                }
        }</span>

        // Apply additional security measures based on risk score
        <span class="cov0" title="0">if finalDecision.Allowed &amp;&amp; riskScore &gt; 0.7 </span><span class="cov0" title="0">{
                finalDecision.Action = ActionChallenge
                finalDecision.Reason += " (High risk - additional verification required)"
        }</span>

        // Generate session token if access is allowed
        <span class="cov0" title="0">if finalDecision.Allowed </span><span class="cov0" title="0">{
                sessionToken, err := zte.generateSessionToken(request)
                if err != nil </span><span class="cov0" title="0">{
                        zte.logger.Errorf("Failed to generate session token: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        finalDecision.SessionToken = sessionToken
                }</span>
        }

        // Log the final decision
        <span class="cov0" title="0">zte.auditLogger.LogAccessDecision(request, finalDecision)

        zte.logger.Infof("Access evaluation completed in %v for user %s",
                time.Since(startTime), request.UserID)

        return finalDecision, nil</span>
}

// findApplicablePolicies finds policies that apply to the given request
func (zte *ZeroTrustEngine) findApplicablePolicies(request *AccessRequest) []*ZeroTrustPolicy <span class="cov0" title="0">{
        zte.mu.RLock()
        defer zte.mu.RUnlock()

        var applicable []*ZeroTrustPolicy

        for _, policy := range zte.policies </span><span class="cov0" title="0">{
                if !policy.Enabled </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if resource is allowed
                <span class="cov0" title="0">if len(policy.AllowedResources) &gt; 0 </span><span class="cov0" title="0">{
                        found := false
                        for _, resource := range policy.AllowedResources </span><span class="cov0" title="0">{
                                if zte.matchesResource(request.Resource, resource) </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Check if resource is denied
                <span class="cov0" title="0">for _, resource := range policy.DeniedResources </span><span class="cov0" title="0">{
                        if zte.matchesResource(request.Resource, resource) </span><span class="cov0" title="0">{
                                continue</span> // Skip this policy
                        }
                }

                // Check time restrictions
                <span class="cov0" title="0">if policy.TimeRestrictions != nil &amp;&amp; !zte.checkTimeRestrictions(policy.TimeRestrictions) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check location restrictions
                <span class="cov0" title="0">if policy.LocationRestrictions != nil &amp;&amp; !zte.checkLocationRestrictions(policy.LocationRestrictions, request.Context) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check device restrictions
                <span class="cov0" title="0">if policy.DeviceRestrictions != nil &amp;&amp; !zte.checkDeviceRestrictions(policy.DeviceRestrictions, request.Context) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">applicable = append(applicable, policy)</span>
        }

        <span class="cov0" title="0">return applicable</span>
}

// evaluatePolicy evaluates a single policy against the request
func (zte *ZeroTrustEngine) evaluatePolicy(ctx context.Context, request *AccessRequest, policy *ZeroTrustPolicy, riskScore float64) (*AccessDecision, error) <span class="cov0" title="0">{

        // Check required claims
        for _, claim := range policy.RequiredClaims </span><span class="cov0" title="0">{
                if _, exists := request.Claims[claim]; !exists </span><span class="cov0" title="0">{
                        return &amp;AccessDecision{
                                Allowed:    false,
                                Reason:     fmt.Sprintf("Missing required claim: %s", claim),
                                Action:     ActionDeny,
                                Confidence: 1.0,
                                Timestamp:  time.Now(),
                        }, nil
                }</span>
        }

        // Evaluate rules in priority order
        <span class="cov0" title="0">for _, rule := range policy.Rules </span><span class="cov0" title="0">{
                decision, err := zte.evaluateRule(ctx, request, &amp;rule, riskScore)
                if err != nil </span><span class="cov0" title="0">{
                        zte.logger.Errorf("Failed to evaluate rule %s: %v", rule.ID, err)
                        continue</span>
                }

                <span class="cov0" title="0">if decision != nil </span><span class="cov0" title="0">{
                        decision.RuleID = rule.ID
                        return decision, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, nil</span>
}

// evaluateRule evaluates a single security rule
func (zte *ZeroTrustEngine) evaluateRule(ctx context.Context, request *AccessRequest, rule *SecurityRule, riskScore float64) (*AccessDecision, error) <span class="cov0" title="0">{

        switch rule.Type </span>{
        case RuleTypeAuthentication:<span class="cov0" title="0">
                return zte.evaluateAuthenticationRule(request, rule)</span>
        case RuleTypeAuthorization:<span class="cov0" title="0">
                return zte.evaluateAuthorizationRule(request, rule)</span>
        case RuleTypeRateLimit:<span class="cov0" title="0">
                return zte.evaluateRateLimitRule(request, rule)</span>
        case RuleTypeDataAccess:<span class="cov0" title="0">
                return zte.evaluateDataAccessRule(request, rule)</span>
        case RuleTypeAudit:<span class="cov0" title="0">
                return zte.evaluateAuditRule(request, rule)</span>
        case RuleTypeEncryption:<span class="cov0" title="0">
                return zte.evaluateEncryptionRule(request, rule)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown rule type: %s", rule.Type)</span>
        }
}

// evaluateAuthenticationRule evaluates authentication rules
func (zte *ZeroTrustEngine) evaluateAuthenticationRule(request *AccessRequest, rule *SecurityRule) (*AccessDecision, error) <span class="cov0" title="0">{

        // Check if user is authenticated
        if request.UserID == "" </span><span class="cov0" title="0">{
                return &amp;AccessDecision{
                        Allowed:    false,
                        Reason:     "User not authenticated",
                        Action:     ActionDeny,
                        Confidence: 1.0,
                        Timestamp:  time.Now(),
                }, nil
        }</span>

        // Check for valid session
        <span class="cov0" title="0">if request.Context.SessionID == "" </span><span class="cov0" title="0">{
                return &amp;AccessDecision{
                        Allowed:    false,
                        Reason:     "No valid session",
                        Action:     ActionChallenge,
                        Confidence: 0.9,
                        Timestamp:  time.Now(),
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;AccessDecision{
                Allowed:    true,
                Reason:     "Authentication successful",
                Action:     ActionAllow,
                Confidence: 0.9,
                Timestamp:  time.Now(),
        }, nil</span>
}

// evaluateAuthorizationRule evaluates authorization rules
func (zte *ZeroTrustEngine) evaluateAuthorizationRule(request *AccessRequest, rule *SecurityRule) (*AccessDecision, error) <span class="cov0" title="0">{

        // Check user roles/permissions from claims
        roles, exists := request.Claims["roles"]
        if !exists </span><span class="cov0" title="0">{
                return &amp;AccessDecision{
                        Allowed:    false,
                        Reason:     "No roles found in user claims",
                        Action:     ActionDeny,
                        Confidence: 1.0,
                        Timestamp:  time.Now(),
                }, nil
        }</span>

        // Simple role-based check
        <span class="cov0" title="0">requiredRole := rule.Metadata["required_role"]
        if requiredRole != "" </span><span class="cov0" title="0">{
                userRoles, ok := roles.([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return &amp;AccessDecision{
                                Allowed:    false,
                                Reason:     "Invalid roles format",
                                Action:     ActionDeny,
                                Confidence: 1.0,
                                Timestamp:  time.Now(),
                        }, nil
                }</span>

                <span class="cov0" title="0">hasRole := false
                for _, role := range userRoles </span><span class="cov0" title="0">{
                        if roleStr, ok := role.(string); ok &amp;&amp; roleStr == requiredRole </span><span class="cov0" title="0">{
                                hasRole = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !hasRole </span><span class="cov0" title="0">{
                        return &amp;AccessDecision{
                                Allowed:    false,
                                Reason:     fmt.Sprintf("Missing required role: %s", requiredRole),
                                Action:     ActionDeny,
                                Confidence: 1.0,
                                Timestamp:  time.Now(),
                        }, nil
                }</span>
        }

        <span class="cov0" title="0">return &amp;AccessDecision{
                Allowed:    true,
                Reason:     "Authorization successful",
                Action:     ActionAllow,
                Confidence: 0.9,
                Timestamp:  time.Now(),
        }, nil</span>
}

// evaluateRateLimitRule evaluates rate limiting rules
func (zte *ZeroTrustEngine) evaluateRateLimitRule(request *AccessRequest, rule *SecurityRule) (*AccessDecision, error) <span class="cov0" title="0">{

        // This would integrate with a rate limiting service
        // For now, return allow
        return &amp;AccessDecision{
                Allowed:    true,
                Reason:     "Rate limit check passed",
                Action:     ActionAllow,
                Confidence: 0.8,
                Timestamp:  time.Now(),
        }, nil
}</span>

// evaluateDataAccessRule evaluates data access rules
func (zte *ZeroTrustEngine) evaluateDataAccessRule(request *AccessRequest, rule *SecurityRule) (*AccessDecision, error) <span class="cov0" title="0">{

        // Check data classification and user clearance
        dataClassification := rule.Metadata["data_classification"]
        userClearance, exists := request.Claims["clearance_level"]

        if dataClassification != "" &amp;&amp; exists </span><span class="cov0" title="0">{
                // Simple clearance level check
                clearanceStr, ok := userClearance.(string)
                if !ok || !zte.hasRequiredClearance(clearanceStr, dataClassification) </span><span class="cov0" title="0">{
                        return &amp;AccessDecision{
                                Allowed:    false,
                                Reason:     "Insufficient clearance level for data access",
                                Action:     ActionDeny,
                                Confidence: 1.0,
                                Timestamp:  time.Now(),
                        }, nil
                }</span>
        }

        <span class="cov0" title="0">return &amp;AccessDecision{
                Allowed:    true,
                Reason:     "Data access authorized",
                Action:     ActionAllow,
                Confidence: 0.9,
                Timestamp:  time.Now(),
        }, nil</span>
}

// evaluateAuditRule evaluates audit rules
func (zte *ZeroTrustEngine) evaluateAuditRule(request *AccessRequest, rule *SecurityRule) (*AccessDecision, error) <span class="cov0" title="0">{

        // Log the access attempt
        zte.auditLogger.LogSecurityEvent("AUDIT_RULE_TRIGGERED", map[string]interface{}{
                "user_id":   request.UserID,
                "resource":  request.Resource,
                "action":    request.Action,
                "rule_id":   rule.ID,
                "timestamp": time.Now(),
        })

        return &amp;AccessDecision{
                Allowed:    true,
                Reason:     "Audit logged",
                Action:     ActionLog,
                Confidence: 1.0,
                Timestamp:  time.Now(),
        }, nil
}</span>

// evaluateEncryptionRule evaluates encryption rules
func (zte *ZeroTrustEngine) evaluateEncryptionRule(request *AccessRequest, rule *SecurityRule) (*AccessDecision, error) <span class="cov0" title="0">{

        // Check if connection is encrypted
        isEncrypted := request.Context.Headers["x-forwarded-proto"] == "https" ||
                strings.Contains(request.Context.Headers["user-agent"], "encrypted")

        if !isEncrypted </span><span class="cov0" title="0">{
                return &amp;AccessDecision{
                        Allowed:    false,
                        Reason:     "Encrypted connection required",
                        Action:     ActionDeny,
                        Confidence: 1.0,
                        Timestamp:  time.Now(),
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;AccessDecision{
                Allowed:    true,
                Reason:     "Encryption requirement met",
                Action:     ActionAllow,
                Confidence: 1.0,
                Timestamp:  time.Now(),
        }, nil</span>
}

// Helper methods

func (zte *ZeroTrustEngine) matchesResource(resource, pattern string) bool <span class="cov0" title="0">{
        // Simple wildcard matching
        if pattern == "*" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if strings.HasSuffix(pattern, "*") </span><span class="cov0" title="0">{
                prefix := strings.TrimSuffix(pattern, "*")
                return strings.HasPrefix(resource, prefix)
        }</span>

        <span class="cov0" title="0">return resource == pattern</span>
}

func (zte *ZeroTrustEngine) checkTimeRestrictions(restrictions *TimeRestriction) bool <span class="cov0" title="0">{
        now := time.Now()

        // Check allowed hours
        if len(restrictions.AllowedHours) &gt; 0 </span><span class="cov0" title="0">{
                currentHour := now.Hour()
                allowed := false
                for _, hour := range restrictions.AllowedHours </span><span class="cov0" title="0">{
                        if currentHour == hour </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check allowed days
        <span class="cov0" title="0">if len(restrictions.AllowedDays) &gt; 0 </span><span class="cov0" title="0">{
                currentDay := int(now.Weekday())
                allowed := false
                for _, day := range restrictions.AllowedDays </span><span class="cov0" title="0">{
                        if currentDay == day </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func (zte *ZeroTrustEngine) checkLocationRestrictions(restrictions *LocationRestriction, context RequestContext) bool <span class="cov0" title="0">{
        if context.Location == nil </span><span class="cov0" title="0">{
                return len(restrictions.AllowedCountries) == 0 // Allow if no location info and no restrictions
        }</span>

        // Check allowed countries
        <span class="cov0" title="0">if len(restrictions.AllowedCountries) &gt; 0 </span><span class="cov0" title="0">{
                allowed := false
                for _, country := range restrictions.AllowedCountries </span><span class="cov0" title="0">{
                        if context.Location.Country == country </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check denied countries
        <span class="cov0" title="0">for _, country := range restrictions.DeniedCountries </span><span class="cov0" title="0">{
                if context.Location.Country == country </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func (zte *ZeroTrustEngine) checkDeviceRestrictions(restrictions *DeviceRestriction, context RequestContext) bool <span class="cov0" title="0">{
        // Check device ID requirement
        if restrictions.RequiredDeviceID &amp;&amp; context.DeviceID == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check allowed device IDs
        <span class="cov0" title="0">if len(restrictions.AllowedDeviceIDs) &gt; 0 </span><span class="cov0" title="0">{
                allowed := false
                for _, deviceID := range restrictions.AllowedDeviceIDs </span><span class="cov0" title="0">{
                        if context.DeviceID == deviceID </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func (zte *ZeroTrustEngine) hasRequiredClearance(userClearance, requiredClassification string) bool <span class="cov0" title="0">{
        // Define clearance hierarchy
        clearanceLevels := map[string]int{
                "public":       0,
                "internal":     1,
                "confidential": 2,
                "secret":       3,
                "top_secret":   4,
        }

        userLevel, userExists := clearanceLevels[userClearance]
        requiredLevel, reqExists := clearanceLevels[requiredClassification]

        if !userExists || !reqExists </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return userLevel &gt;= requiredLevel</span>
}

func (zte *ZeroTrustEngine) generateSessionToken(request *AccessRequest) (string, error) <span class="cov0" title="0">{
        // Create JWT token with session information
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "user_id":    request.UserID,
                "session_id": request.Context.SessionID,
                "device_id":  request.Context.DeviceID,
                "ip_address": request.Context.IPAddress,
                "issued_at":  time.Now().Unix(),
                "expires_at": time.Now().Add(time.Hour).Unix(),
        })

        // Sign token with secret key
        secretKey := []byte("your-secret-key") // In production, use a secure key management system
        tokenString, err := token.SignedString(secretKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return tokenString, nil</span>
}

// GetPolicies returns all zero trust policies
func (zte *ZeroTrustEngine) GetPolicies() map[string]*ZeroTrustPolicy <span class="cov0" title="0">{
        zte.mu.RLock()
        defer zte.mu.RUnlock()

        policies := make(map[string]*ZeroTrustPolicy)
        for id, policy := range zte.policies </span><span class="cov0" title="0">{
                policies[id] = policy
        }</span>

        <span class="cov0" title="0">return policies</span>
}

// UpdatePolicy updates an existing policy
func (zte *ZeroTrustEngine) UpdatePolicy(policyID string, updates map[string]interface{}) error <span class="cov0" title="0">{
        zte.mu.Lock()
        defer zte.mu.Unlock()

        policy, exists := zte.policies[policyID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("policy not found: %s", policyID)
        }</span>

        // Apply updates
        <span class="cov0" title="0">if name, ok := updates["name"].(string); ok </span><span class="cov0" title="0">{
                policy.Name = name
        }</span>
        <span class="cov0" title="0">if description, ok := updates["description"].(string); ok </span><span class="cov0" title="0">{
                policy.Description = description
        }</span>
        <span class="cov0" title="0">if enabled, ok := updates["enabled"].(bool); ok </span><span class="cov0" title="0">{
                policy.Enabled = enabled
        }</span>

        <span class="cov0" title="0">policy.UpdatedAt = time.Now()

        zte.logger.Infof("Updated zero trust policy: %s", policyID)
        return nil</span>
}

// DeletePolicy removes a policy
func (zte *ZeroTrustEngine) DeletePolicy(policyID string) error <span class="cov0" title="0">{
        zte.mu.Lock()
        defer zte.mu.Unlock()

        if _, exists := zte.policies[policyID]; !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("policy not found: %s", policyID)
        }</span>

        <span class="cov0" title="0">delete(zte.policies, policyID)
        zte.logger.Infof("Deleted zero trust policy: %s", policyID)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package storage

import (
        "context"
        "fmt"
        "io"
        "mime"
        "path/filepath"
        "strings"
        "time"

        "github.com/minio/minio-go/v7"
        "github.com/minio/minio-go/v7/pkg/credentials"
        "github.com/sirupsen/logrus"
)

// Config MinIOé…ç½®
type Config struct {
        Endpoint        string `json:"endpoint" yaml:"endpoint"`
        AccessKeyID     string `json:"access_key_id" yaml:"access_key_id"`
        SecretAccessKey string `json:"secret_access_key" yaml:"secret_access_key"`
        UseSSL          bool   `json:"use_ssl" yaml:"use_ssl"`
        BucketName      string `json:"bucket_name" yaml:"bucket_name"`
        Region          string `json:"region" yaml:"region"`
}

// DefaultConfig è¿”å›é»˜è®¤é…ç½®
func DefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Endpoint:        "localhost:9000",
                AccessKeyID:     "minioadmin",
                SecretAccessKey: "minioadmin",
                UseSSL:          false,
                BucketName:      "chatbot",
                Region:          "us-east-1",
        }
}</span>

// ObjectInfo å¯¹è±¡ä¿¡æ¯
type ObjectInfo struct {
        Key          string            `json:"key"`
        Size         int64             `json:"size"`
        ContentType  string            `json:"content_type"`
        ETag         string            `json:"etag"`
        LastModified time.Time         `json:"last_modified"`
        Metadata     map[string]string `json:"metadata"`
}

// UploadResult ä¸Šä¼ ç»“æœ
type UploadResult struct {
        Key         string `json:"key"`
        Bucket      string `json:"bucket"`
        Size        int64  `json:"size"`
        ETag        string `json:"etag"`
        ContentType string `json:"content_type"`
        URL         string `json:"url"`
}

// ObjectStorage å¯¹è±¡å­˜å‚¨æ¥å£
type ObjectStorage interface {
        // åŸºç¡€æ“ä½œ
        Upload(ctx context.Context, key string, reader io.Reader, size int64, contentType string) (*UploadResult, error)
        Download(ctx context.Context, key string) (io.ReadCloser, error)
        Delete(ctx context.Context, key string) error
        Exists(ctx context.Context, key string) (bool, error)

        // æ‰¹é‡æ“ä½œ
        ListObjects(ctx context.Context, prefix string, recursive bool) ([]*ObjectInfo, error)
        DeleteMultiple(ctx context.Context, keys []string) error

        // URLç”Ÿæˆ
        GetPresignedURL(ctx context.Context, key string, expires time.Duration) (string, error)
        GetPresignedPutURL(ctx context.Context, key string, expires time.Duration) (string, error)

        // å…ƒæ•°æ®
        GetObjectInfo(ctx context.Context, key string) (*ObjectInfo, error)
        UpdateMetadata(ctx context.Context, key string, metadata map[string]string) error

        // Bucketæ“ä½œ
        CreateBucket(ctx context.Context, bucketName string) error
        ListBuckets(ctx context.Context) ([]string, error)
        DeleteBucket(ctx context.Context, bucketName string) error
}

// MinIOStorage MinIOå­˜å‚¨å®ç°
type MinIOStorage struct {
        client     *minio.Client
        config     *Config
        bucketName string
}

// NewMinIOStorage åˆ›å»ºMinIOå­˜å‚¨
func NewMinIOStorage(config *Config) (*MinIOStorage, error) <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultConfig()
        }</span>

        // åˆ›å»ºMinIOå®¢æˆ·ç«¯
        <span class="cov0" title="0">client, err := minio.New(config.Endpoint, &amp;minio.Options{
                Creds:  credentials.NewStaticV4(config.AccessKeyID, config.SecretAccessKey, ""),
                Secure: config.UseSSL,
                Region: config.Region,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create MinIO client: %w", err)
        }</span>

        <span class="cov0" title="0">storage := &amp;MinIOStorage{
                client:     client,
                config:     config,
                bucketName: config.BucketName,
        }

        // ç¡®ä¿é»˜è®¤bucketå­˜åœ¨
        ctx := context.Background()
        exists, err := client.BucketExists(ctx, config.BucketName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check bucket existence: %w", err)
        }</span>

        <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                err = client.MakeBucket(ctx, config.BucketName, minio.MakeBucketOptions{
                        Region: config.Region,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create bucket: %w", err)
                }</span>
                <span class="cov0" title="0">logrus.Infof("Created MinIO bucket: %s", config.BucketName)</span>
        }

        <span class="cov0" title="0">logrus.Infof("Connected to MinIO: %s (bucket: %s)", config.Endpoint, config.BucketName)
        return storage, nil</span>
}

// Upload ä¸Šä¼ å¯¹è±¡
func (s *MinIOStorage) Upload(ctx context.Context, key string, reader io.Reader, size int64, contentType string) (*UploadResult, error) <span class="cov0" title="0">{
        // è‡ªåŠ¨æ£€æµ‹content type
        if contentType == "" </span><span class="cov0" title="0">{
                contentType = mime.TypeByExtension(filepath.Ext(key))
                if contentType == "" </span><span class="cov0" title="0">{
                        contentType = "application/octet-stream"
                }</span>
        }

        // ä¸Šä¼ é€‰é¡¹
        <span class="cov0" title="0">opts := minio.PutObjectOptions{
                ContentType: contentType,
                UserMetadata: map[string]string{
                        "uploaded_at": time.Now().UTC().Format(time.RFC3339),
                },
        }

        // æ‰§è¡Œä¸Šä¼ 
        info, err := s.client.PutObject(ctx, s.bucketName, key, reader, size, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to upload object: %w", err)
        }</span>

        // ç”Ÿæˆè®¿é—®URL
        <span class="cov0" title="0">url := fmt.Sprintf("%s/%s/%s", s.getEndpointURL(), s.bucketName, key)

        result := &amp;UploadResult{
                Key:         key,
                Bucket:      s.bucketName,
                Size:        info.Size,
                ETag:        info.ETag,
                ContentType: contentType,
                URL:         url,
        }

        logrus.Debugf("Uploaded object: %s (size: %d, etag: %s)", key, info.Size, info.ETag)
        return result, nil</span>
}

// Download ä¸‹è½½å¯¹è±¡
func (s *MinIOStorage) Download(ctx context.Context, key string) (io.ReadCloser, error) <span class="cov0" title="0">{
        object, err := s.client.GetObject(ctx, s.bucketName, key, minio.GetObjectOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get object: %w", err)
        }</span>

        // éªŒè¯å¯¹è±¡æ˜¯å¦å­˜åœ¨
        <span class="cov0" title="0">_, err = object.Stat()
        if err != nil </span><span class="cov0" title="0">{
                object.Close()
                return nil, fmt.Errorf("failed to stat object: %w", err)
        }</span>

        <span class="cov0" title="0">return object, nil</span>
}

// Delete åˆ é™¤å¯¹è±¡
func (s *MinIOStorage) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        err := s.client.RemoveObject(ctx, s.bucketName, key, minio.RemoveObjectOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete object: %w", err)
        }</span>

        <span class="cov0" title="0">logrus.Debugf("Deleted object: %s", key)
        return nil</span>
}

// Exists æ£€æŸ¥å¯¹è±¡æ˜¯å¦å­˜åœ¨
func (s *MinIOStorage) Exists(ctx context.Context, key string) (bool, error) <span class="cov0" title="0">{
        _, err := s.client.StatObject(ctx, s.bucketName, key, minio.StatObjectOptions{})
        if err != nil </span><span class="cov0" title="0">{
                errResp := minio.ToErrorResponse(err)
                if errResp.Code == "NoSuchKey" </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("failed to stat object: %w", err)</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// ListObjects åˆ—å‡ºå¯¹è±¡
func (s *MinIOStorage) ListObjects(ctx context.Context, prefix string, recursive bool) ([]*ObjectInfo, error) <span class="cov0" title="0">{
        opts := minio.ListObjectsOptions{
                Prefix:    prefix,
                Recursive: recursive,
        }

        var objects []*ObjectInfo
        for object := range s.client.ListObjects(ctx, s.bucketName, opts) </span><span class="cov0" title="0">{
                if object.Err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to list objects: %w", object.Err)
                }</span>

                <span class="cov0" title="0">objects = append(objects, &amp;ObjectInfo{
                        Key:          object.Key,
                        Size:         object.Size,
                        ContentType:  object.ContentType,
                        ETag:         object.ETag,
                        LastModified: object.LastModified,
                        Metadata:     object.UserMetadata,
                })</span>
        }

        <span class="cov0" title="0">return objects, nil</span>
}

// DeleteMultiple æ‰¹é‡åˆ é™¤å¯¹è±¡
func (s *MinIOStorage) DeleteMultiple(ctx context.Context, keys []string) error <span class="cov0" title="0">{
        objectsCh := make(chan minio.ObjectInfo)

        // å‘é€è¦åˆ é™¤çš„å¯¹è±¡
        go func() </span><span class="cov0" title="0">{
                defer close(objectsCh)
                for _, key := range keys </span><span class="cov0" title="0">{
                        objectsCh &lt;- minio.ObjectInfo{
                                Key: key,
                        }
                }</span>
        }()

        // æ‰§è¡Œæ‰¹é‡åˆ é™¤
        <span class="cov0" title="0">for err := range s.client.RemoveObjects(ctx, s.bucketName, objectsCh, minio.RemoveObjectsOptions{}) </span><span class="cov0" title="0">{
                if err.Err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete object %s: %w", err.ObjectName, err.Err)
                }</span>
        }

        <span class="cov0" title="0">logrus.Debugf("Deleted %d objects", len(keys))
        return nil</span>
}

// GetPresignedURL è·å–é¢„ç­¾åä¸‹è½½URL
func (s *MinIOStorage) GetPresignedURL(ctx context.Context, key string, expires time.Duration) (string, error) <span class="cov0" title="0">{
        if expires == 0 </span><span class="cov0" title="0">{
                expires = 7 * 24 * time.Hour // é»˜è®¤7å¤©
        }</span>

        <span class="cov0" title="0">url, err := s.client.PresignedGetObject(ctx, s.bucketName, key, expires, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate presigned URL: %w", err)
        }</span>

        <span class="cov0" title="0">return url.String(), nil</span>
}

// GetPresignedPutURL è·å–é¢„ç­¾åä¸Šä¼ URL
func (s *MinIOStorage) GetPresignedPutURL(ctx context.Context, key string, expires time.Duration) (string, error) <span class="cov0" title="0">{
        if expires == 0 </span><span class="cov0" title="0">{
                expires = time.Hour // é»˜è®¤1å°æ—¶
        }</span>

        <span class="cov0" title="0">url, err := s.client.PresignedPutObject(ctx, s.bucketName, key, expires)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate presigned put URL: %w", err)
        }</span>

        <span class="cov0" title="0">return url.String(), nil</span>
}

// GetObjectInfo è·å–å¯¹è±¡ä¿¡æ¯
func (s *MinIOStorage) GetObjectInfo(ctx context.Context, key string) (*ObjectInfo, error) <span class="cov0" title="0">{
        stat, err := s.client.StatObject(ctx, s.bucketName, key, minio.StatObjectOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat object: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;ObjectInfo{
                Key:          stat.Key,
                Size:         stat.Size,
                ContentType:  stat.ContentType,
                ETag:         stat.ETag,
                LastModified: stat.LastModified,
                Metadata:     stat.UserMetadata,
        }, nil</span>
}

// UpdateMetadata æ›´æ–°å¯¹è±¡å…ƒæ•°æ®
func (s *MinIOStorage) UpdateMetadata(ctx context.Context, key string, metadata map[string]string) error <span class="cov0" title="0">{
        // MinIOä¸æ”¯æŒç›´æ¥æ›´æ–°å…ƒæ•°æ®ï¼Œéœ€è¦å¤åˆ¶å¯¹è±¡
        src := minio.CopySrcOptions{
                Bucket: s.bucketName,
                Object: key,
        }

        dst := minio.CopyDestOptions{
                Bucket:          s.bucketName,
                Object:          key,
                UserMetadata:    metadata,
                ReplaceMetadata: true,
        }

        _, err := s.client.CopyObject(ctx, dst, src)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update metadata: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateBucket åˆ›å»ºbucket
func (s *MinIOStorage) CreateBucket(ctx context.Context, bucketName string) error <span class="cov0" title="0">{
        err := s.client.MakeBucket(ctx, bucketName, minio.MakeBucketOptions{
                Region: s.config.Region,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create bucket: %w", err)
        }</span>

        <span class="cov0" title="0">logrus.Infof("Created bucket: %s", bucketName)
        return nil</span>
}

// ListBuckets åˆ—å‡ºæ‰€æœ‰bucket
func (s *MinIOStorage) ListBuckets(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        buckets, err := s.client.ListBuckets(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list buckets: %w", err)
        }</span>

        <span class="cov0" title="0">var names []string
        for _, bucket := range buckets </span><span class="cov0" title="0">{
                names = append(names, bucket.Name)
        }</span>

        <span class="cov0" title="0">return names, nil</span>
}

// DeleteBucket åˆ é™¤bucket
func (s *MinIOStorage) DeleteBucket(ctx context.Context, bucketName string) error <span class="cov0" title="0">{
        err := s.client.RemoveBucket(ctx, bucketName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete bucket: %w", err)
        }</span>

        <span class="cov0" title="0">logrus.Infof("Deleted bucket: %s", bucketName)
        return nil</span>
}

// getEndpointURL è·å–endpoint URL
func (s *MinIOStorage) getEndpointURL() string <span class="cov0" title="0">{
        protocol := "http"
        if s.config.UseSSL </span><span class="cov0" title="0">{
                protocol = "https"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s://%s", protocol, s.config.Endpoint)</span>
}

// GenerateObjectKey ç”Ÿæˆå¯¹è±¡é”®
func GenerateObjectKey(prefix, filename string) string <span class="cov0" title="0">{
        // ç”Ÿæˆæ—¥æœŸè·¯å¾„
        now := time.Now()
        datePath := now.Format("2006/01/02")

        // ç”Ÿæˆå”¯ä¸€ID
        timestamp := now.UnixNano()

        // è·å–æ–‡ä»¶æ‰©å±•å
        ext := filepath.Ext(filename)
        nameWithoutExt := strings.TrimSuffix(filename, ext)

        // æ¸…ç†æ–‡ä»¶åï¼ˆç§»é™¤ç‰¹æ®Šå­—ç¬¦ï¼‰
        cleanName := strings.Map(func(r rune) rune </span><span class="cov0" title="0">{
                if (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= 'A' &amp;&amp; r &lt;= 'Z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') || r == '-' || r == '_' </span><span class="cov0" title="0">{
                        return r
                }</span>
                <span class="cov0" title="0">return '_'</span>
        }, nameWithoutExt)

        // ç»„åˆæœ€ç»ˆçš„key
        <span class="cov0" title="0">return fmt.Sprintf("%s/%s/%s_%d%s", prefix, datePath, cleanName, timestamp, ext)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package types

import (
        "encoding/json"
        "time"
)

// EventType äº‹ä»¶ç±»å‹å¸¸é‡
const (
        EventTypeConnected    = "connected"
        EventTypeDisconnected = "disconnected"
        EventTypeHeartbeat    = "heartbeat"
        EventTypeThrottle     = "throttle"
        EventTypeCancel       = "cancel"
        EventTypeAudioFrame   = "audio_frame"
        EventTypeTTSChunk     = "tts_chunk"
        EventTypeASRPartial   = "asr_partial"
        EventTypeASRFinal     = "asr_final"
        EventTypeLLMDelta     = "llm_delta"
        EventTypeLLMDone      = "llm_done"
        EventTypeReferences   = "references"
        EventTypeError        = "error"
        EventTypeAgentPlan    = "agent_plan"
        EventTypeAgentStep    = "agent_step"
        EventTypeToolResult   = "tool_result"
        EventTypeAgentSummary = "agent_summary"
)

// EventMeta äº‹ä»¶å…ƒæ•°æ®
type EventMeta struct {
        TraceID   string    `json:"trace_id"`
        SessionID string    `json:"session_id"`
        Timestamp time.Time `json:"timestamp"`
        Version   string    `json:"version"`
}

// EventEnvelope äº‹ä»¶ä¿¡å°
type EventEnvelope struct {
        Type string      `json:"type"`
        Data interface{} `json:"data"`
        Meta EventMeta   `json:"meta"`
}

// NewEventEnvelope åˆ›å»ºäº‹ä»¶ä¿¡å°
func NewEventEnvelope(eventType string, data interface{}, sessionID, traceID string) *EventEnvelope <span class="cov0" title="0">{
        return &amp;EventEnvelope{
                Type: eventType,
                Data: data,
                Meta: EventMeta{
                        TraceID:   traceID,
                        SessionID: sessionID,
                        Timestamp: time.Now(),
                        Version:   "1.0",
                },
        }
}</span>

// ToJSON åºåˆ—åŒ–ä¸ºJSON
func (e *EventEnvelope) ToJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(e)
}</span>

// EventFromJSON ä»JSONååºåˆ—åŒ–
func EventFromJSON(data []byte) (*EventEnvelope, error) <span class="cov0" title="0">{
        var event EventEnvelope
        err := json.Unmarshal(data, &amp;event)
        return &amp;event, err
}</span>

// å…·ä½“äº‹ä»¶æ•°æ®ç»“æ„

// AudioFrameData éŸ³é¢‘å¸§æ•°æ®
type AudioFrameData struct {
        Audio       []byte `json:"audio"`
        Timestamp   int64  `json:"timestamp"`
        SequenceNum int32  `json:"sequence_num"`
        SampleRate  int32  `json:"sample_rate"`
        Channels    int8   `json:"channels"`
        FrameSize   int16  `json:"frame_size"`
}

// TTSChunkData TTSéŸ³é¢‘å—æ•°æ®
type TTSChunkData struct {
        Audio     []byte `json:"audio"`
        Timestamp int64  `json:"timestamp"`
        Format    string `json:"format"`
        IsLast    bool   `json:"is_last"`
}

// ASRData ASRè¯†åˆ«æ•°æ®
type ASRData struct {
        Text       string  `json:"text"`
        Confidence float64 `json:"confidence"`
        IsFinal    bool    `json:"is_final"`
        Language   string  `json:"language"`
}

// LLMDeltaData LLMæµå¼å“åº”æ•°æ®
type LLMDeltaData struct {
        Content string `json:"content"`
        Role    string `json:"role"`
        Delta   string `json:"delta"`
}

// ThrottleData é™æµæ•°æ®
type ThrottleData struct {
        Reason       string `json:"reason"`
        RetryAfterMs int    `json:"retry_after_ms"`
        CurrentRate  int32  `json:"current_rate"`
        MaxRate      int32  `json:"max_rate"`
}

// HeartbeatData å¿ƒè·³æ•°æ®
type HeartbeatData struct {
        Timestamp int64 `json:"timestamp"`
        Sequence  int32 `json:"sequence"`
}

// ErrorData é”™è¯¯æ•°æ®
type ErrorData struct {
        Code    string `json:"code"`
        Message string `json:"message"`
        Details string `json:"details"`
}

// ReferenceData å¼•ç”¨æ•°æ®
type ReferenceData struct {
        ID       string                 `json:"id"`
        Source   string                 `json:"source"`
        Content  string                 `json:"content"`
        Score    float64                `json:"score"`
        Metadata map[string]interface{} `json:"metadata"`
}

// AgentPlanData Agentè§„åˆ’æ•°æ®
type AgentPlanData struct {
        Steps       []string `json:"steps"`
        Reasoning   string   `json:"reasoning"`
        Tools       []string `json:"tools"`
        EstimatedMs int      `json:"estimated_ms"`
}

// AgentStepData Agentæ­¥éª¤æ•°æ®
type AgentStepData struct {
        StepIndex   int    `json:"step_index"`
        Description string `json:"description"`
        Status      string `json:"status"`
        StartTime   int64  `json:"start_time"`
        EndTime     int64  `json:"end_time"`
}

// ToolResultData å·¥å…·ç»“æœæ•°æ®
type ToolResultData struct {
        ToolName string      `json:"tool_name"`
        Input    interface{} `json:"input"`
        Output   interface{} `json:"output"`
        Success  bool        `json:"success"`
        Error    string      `json:"error,omitempty"`
        Duration int64       `json:"duration_ms"`
}

// AudioHeader éŸ³é¢‘å¸§å¤´éƒ¨
type AudioHeader struct {
        SessionID   string `json:"session_id"`
        SequenceNum int32  `json:"sequence_num"`
        SampleRate  int32  `json:"sample_rate"`
        Channels    int8   `json:"channels"`
        FrameSize   int16  `json:"frame_size"`
        Timestamp   int64  `json:"timestamp"`
        Format      string `json:"format"`
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
